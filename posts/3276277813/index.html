<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C Primer Plus笔记 | WELLS Blog</title><meta name="keywords" content="开发"><meta name="author" content="Wells"><meta name="copyright" content="Wells"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C Primer Plus笔记"><meta name="application-name" content="C Primer Plus笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C Primer Plus笔记"><meta property="og:url" content="https://we11s.github.io/posts/3276277813/index.html"><meta property="og:site_name" content="WELLS Blog"><meta property="og:description" content="C语言概述C程序的基本结构​       程序由一个或多个函数组成，必须有 main()函数。 ​        函数由函数头和函数体组成。函数头包括函数名、传入该函数的信息类型和函数的返回类型。通过函数名后的圆括号可识别出函数，圆括号里可能为空，可能有参数。函数体被花括号括起来，由一系列语句、声明"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://we11s.github.io/img/cover/65a00feec63ae.jpg"><meta property="article:author" content="Wells"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://we11s.github.io/img/cover/65a00feec63ae.jpg"><meta name="description" content="C语言概述C程序的基本结构​       程序由一个或多个函数组成，必须有 main()函数。 ​        函数由函数头和函数体组成。函数头包括函数名、传入该函数的信息类型和函数的返回类型。通过函数名后的圆括号可识别出函数，圆括号里可能为空，可能有参数。函数体被花括号括起来，由一系列语句、声明"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://we11s.github.io/posts/3276277813/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w人呢人呢！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://well5-wellsblog.hf.space',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技","🔍 脑洞大开"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Wells","link":"链接: ","source":"来源: WELLS Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'WELLS Blog',
  title: 'C Primer Plus笔记',
  postAI: '',
  pageFillDescription: 'C语言概述, C程序的基本结构, 多个函数, 关键字与保留标识符, 本章注意点：, 标识符名, 转义序列, 参数中的%d在打印时有什么作用？, 数据与C, 数据类型关键字, 不同数据类型的储存, 整数的储存, 浮点数的储存, 进制, 进制书面表示, 初始化变量时的进制表示, 输出中的进制表示, 进制的转化（1）–负数, 十进制转二进制（十进制为负数）, 二进制转十进制（符号位为1）, 进制的转换（2）-正数, 数值溢出, 整数, 浮点值的上溢和下溢, 字符, 非打印字符, 本章注意点：, 变量初始化, getchar()函数的使用, 声明变量的作用, 数据类型应与打印类型一致, 断行输入, sizeof()函数, 输入的数据类型与设定数据类型不一致的情况, 字符串和格式化, 字符串与char数组, 常量和C预处理器, strlen()函数, printf()的转化说明修饰符, scanf（）, 读取字符串的规则, amp的使用, scanf()的读取规则, scanf()中的使用规则, 返回值, 读取小数值, 本章注意点：, X与39X39的区别, sizeof 何时使用了圆括号, const限定符, 运算符、表达式和语句, 运算符, 基本运算符, 赋值运算符, 求模运算符-%, 一元运算符与二元运算符, 递增递减运算符, 关系运算符, 逗号运算符, 逻辑运算符, 备选拼写：iso646.h头文件, 判断范围问题, 条件运算符——?, amp运算符-查找地址, 间接运算符-*, 运算符的优先级, 类型转化, 强制类型转换运算符, 本章注意点：, 循环, while循环, for循环, do….while循环, 本章注意点：, 逻辑判断符号与赋值符号不要混淆, 分支与跳转, if、else、else if语句, 数值的范围判断问题, continue语句, break语句, 多重选择：switch和break, case多重标签, getchar()和putchar()函数, ctype.h库, 数组, 指定数组大小, 未指定数组大小, 初始化数组, 声明数组形参, 指定初始化器（适用于C99）, 二维数组, 声明, 初始化, 其他多维数组, const修饰数组, 变长数组（适用C99）, 声明一个带二维变长数组参数的函数, 复合字面量（使用C99）, 创建, 使用, 本章注意点：, 数组名是数组首元素的地址。, 多维数组的双重间接性质, 数组中sizeof()的使用, 指针, 声明指针, 1.声明变量的指针, 2.声明多维数组的指针, 3.声明函数指针, 4.声明指向指针的指针, 8种基本用法, 指针运算与递增递减操作, 解引用未初始化的指针, 函数指针, 指针的兼容性, 本章注意点：, 指针加法, 函数, 函数的声明、定义与引用, 函数的声明, 函数的定义, 函数引用, 函数参数的传递, 1.变量, 2.数组, 字符串, 定义字符串, 字符串常量, char类型数组, 指向char的指针, 数组形式和指针形式的区别, 指针, 注：, 一些神奇的语句, Bug日记语言概述程序的基本结构程序由一个或多个函数组成必须有函数函数由函数头和函数体组成函数头包括函数名传入该函数的信息类型和函数的返回类型通过函数名后的圆括号可识别出函数圆括号里可能为空可能有参数函数体被花括号括起来由一系列语句声明组成函数头以下为函数体声明语句语句多个函数一个文件中包含两个函数函数原型函数定义开始该程序的输出如下分析函数在程序中出现了次第次是函数原型告知编译器在程序中要使用该函数第次以函数调用的形式出现在中最后一次出现在函数定义中单独不运行的原因在典型的程序中只有函数会在程序启动时自动执行其他函数不会在程序启动时自动执行除非它们被显式地从函数或其他函数中调用在您提供的代码示例中只有函数会在程序启动时执行因为它是程序的入口点其他函数如函数只有在被调用时才会执行关键字与保留标识符关键字是语言的词汇不能用它们作为标识符如变量名保留标识符语言已经指定了它们的用途或保留它们的使用权如果你使用这些标识符来表示其他意思会导致一些问题保留标识符包括那些以下划线字符开头的标识符和标准库函数名如本章注意点标识符名可以用小写字母大写字母数字和下划线来命名而且名称的第个字符必须是字符或下划线不能是数字操作系统和库经常使用以一个或两个下划线字符开始的标识符如因此最好避免在自己的程序中使用这种名称转义序列换行符是一个转义序列转义序列用于代表难以表示或无法输入的字符如代表键代表键退格键每个转义序列都以反斜杠字符开始反转义符的使用通常发生在字符串文字用双引号或单引号括起来的文本中以便在其中插入特殊字符或控制字符所以一般来说反转义符需要在字符串文字中使用不管是在双引号中还是单引号中参数中的在打印时有什么作用相当于是一个占位符其作用是指明输出值的位置提醒程序要在该处打印一个变量表明把变量作为十进制整数打印函数名中的这个表示格式提醒用户这是一种格式化打印函数数据与数据类型关键字给出的关键字标准添加的关键字标准添加的关键字注在语言中用关键字来表示基本的整数类型后个关键字和和新增的用于提供基本整数类型的变式例如和关键字用于指定字母和其他字符如和另外类型也可以表示较小的整数和表示带小数点的数类型表示布尔值或和分别表示复数和虚数或只用于非负值的场合这种类型与有符号类型表示的范围不同用于表示正负号的位现在用于表示另一个二进制位所以无符号整型可以表示更大的数例如位允许的取值范围是而不是不同数据类型的储存整数的储存整数类型通常以二进制补码形式存储在内存中补码表示法用于表示正数负数和零以转化为例确定绝对值的二进制表示将负数的绝对值转换为正数的二进制表示首先找出的绝对值即并将其转换为二进制的二进制表示为取反将这个正数的二进制表示中的每个位都取反即变为变为现在将上一步得到的二进制表示中的每一位取反变为变为得到加接下来在取反后的二进制数上加接下来在取反后的结果上加添加符号位符号位是二进制表示中的一个特殊位用于表示一个数的正负在有符号整数表示法中符号位通常是最高位最左边的位用来表示整数的正负性在得到的结果前面添加符号位因为原数是负数所以最高位为最终的补码表示为整数的最大最小值标准对基本数据类型只规定了允许的最小大小对于位机和的最小取值范围是对于位机的最小取值范围是对于和最小取值范围是对于最小取值范围是类型是为了支持位的需求最小取值范围是的最小取值范围是浮点数的储存以标准位可以用于表示大约个有效数字的浮点数位可以用于表示大约到位的有效数字以单精度浮点数位为例遵循标准这个标准定义了浮点数的二进制表示方式以及进行浮点数运算的规则位用于表示符号位正负号表示正数表示负数位用于表示指数部分剩下的位用于表示尾数部分以转化为例将整数部分转换为二进制将整数部分转换为二进制得到将小数部分转换为二进制将小数部分转换为二进制通常可以将小数部分乘以并取整数部分然后将余数作为下一位的小数部分一直重复直到小数部分为或者达到所需的精度对于这个过程如下整数部分是小数部分更新为整数部分是小数部分更新为整数部分是小数部分更新为因此的二进制表示为将整数部分和小数部分组合将整数部分和小数部分组合在一起得到二进制表示规范化在中浮点数采用科学计数法表示其中二进制小数点位于左边的第一个非零位前面因此需要将二进制数规范化将小数点移到合适的位置在这种情况下将小数点移到最左边得到规范化的二进制表示为确定指数和尾数指数因为小数点向左移了位所以指数为在中还需要加上一个偏移值因此指数为以位表示指数二进制为尾数小数点左边的部分是尾数即组合符号指数和尾数符号位因为是正数所以符号位为指数上面计算得到的位指数为尾数上面计算得到的尾数为最终将这些组合在一起得到位的浮点数表示为这就是的单精度浮点数表示其中第一个位是符号位接下来的位是指数剩下的位是尾数这个二进制表示可以转换为十进制浮点数为注偏移值的作用使次方数换算为二进制时不出现小数点偏移值的确定即确定最小次方数以位为例位精度有位二进制用来表示次方数故次方的范围数位即占去位剩下正负进行平分故最小的次方数位故偏移值为加上偏移值后次方数不存在负数的情况因使用过二进制的科学计数法小数点前一定为故尾数部分只取小数点后的一部分进制进制书面表示表示二进制也记作字母表示八进制也记为表示为十进制也记作表示十六进制数也记作初始化变量时的进制表示加或者表示二进制加表示八进制加或表示进制不加默认表示进制可在整数输入的数值后添加表示此整数以位进制运算如可在浮点数后输入表示此浮点数以位进行运算默认为位进行运算以便提高运算效率如输出中的进制表示表示有符号十进制输出或表示以十六进制输出表示以八进制输出表示输出单精度浮点数表示输出长整型十进制整数表示输出长整型八进制整数表示输出长整型十六进制整数表示输出双精度浮点数格式对应的是单个字符格式对应的是字符串表示输出类型的十进制整数表示输出类型的八进制整数表示输出类型的十六进制整数表示输出整数表示输出十六进制整数表示输出八进制整数表示输出整数表示输出无符号整数表示输出以指数计数法的浮点数表示输出以指数计数法的长浮点数表示输出以十六进制指数计数法的浮点数表示输出百分号在不支持的编译器中或代替表示指针自动选择以或输出作为函数的输出注修饰符不能用于浮点数类型它只能用于整数数据类型默认八进制和十六进制都是整数类型数值输出时如果要在八进制和十六进制值前显示和前缀要分别在转换说明中加入即在后加入表示输出浮点数并保留小数点后一位表示输出浮点数且小数点前至少一字节不足空格补足并保留两位小数可用于输出类型的变量但不能用于赋值进制的转化负数十进制转二进制十进制为负数当将负数从十进制转换为二进制时通常会使用二进制补码表示法这是因为在计算机内部负数通常以二进制补码的形式存储下面是将负数转换为二进制的一般过程确定负数的绝对值首先确定负数的绝对值例如如果要将转换为二进制绝对值是将绝对值转换为二进制将绝对值转换为二进制的标准方法是使用除取余法或称为短除法不断将绝对值除以同时记录每一步的余数将余数以逆序的方式排列就得到了二进制表示例如对于绝对值过程如下余余余然后将这些余数逆序排列得到二进制数将二进制数取反在二进制补码中正数的补码和原码相同但负数的补码需要将其绝对值的二进制数取反即变为变为在上面的例子中二进制数取反后变为将取反后的结果加最后一步是将取反后的结果加在上面的例子中加上符号位最终加上符号位在二进制补码中符号位是最左边的位表示正数表示负数在上面的例子中要表示将最左边的位设置为得到最终结果所以将负数转换为二进制补码的结果是这个过程可以用于将任何负数转换为二进制补码请注意不同的编程语言可能有不同的方式来表示二进制补码但这个过程是通用的二进制转十进制符号位为找到符号位首先从二进制表示中找到符号位在二进制补码中符号位是最左边的位表示负数表示正数取反将除符号位以外的所有位取反即变为变为这是为了得到负数的绝对值的二进制表示加对取反后的结果加以得到负数的绝对值的二进制补码表示计算绝对值的十进制将上一步得到的二进制数转换为十进制这是标准的二进制到十进制转换从最右边的位最低位开始将每个位的值乘以的幂然后相加直到处理完所有位加上负号根据最初的符号位将正数的绝对值前面添加负号让我们以一个例子来说明这个过程假设我们有一个位的二进制补码找到符号位符号位是最左边的位表示负数取反去除符号位并将其余位取反得到加对取反后的结果加得到计算绝对值的十进制将转换为十进制从右到左第位是第位是第位是第位是第位是第位是第位是第位是因为符号位是计算总和加上负号最初的符号位是所以最终结果是即因此二进制补码对应的十进制值是这个过程可以用于将任何负数的二进制补码表示转换为十进制进制的转换正数正数的转化无需像负数取反加一直接将除符号位的二进制转化为十进制即可数值溢出整数程序实例函数使用说明显示类型的值超出系统允许的最大值运行结果分析可以把无符号整数看作是汽车的里程表当达到它能表示的最大值时会重新从起始点开始整数也是类似的情况它们主要的区别是在超过最大值时类型的变量从开始而类型的变量则从从绝对值最大开始浮点值的上溢和下溢上溢当计算导致数字过大超过当前类型能表达的范围时就会发生上溢在这种情况下会给赋一个表示无穷大的特定值而且显示该值为或或者具有无穷含义的其他内容下溢当出现下溢的时候计算机只好把尾数部分的位向右移空出第个二进制位并丢弃最后一个二进制数以十进制为例把一个有位有效数字的数如除以得到的结果是虽然得到了结果但是在计算过程中却损失了原末尾有效位上的数字语言把损失了类型全精度的浮点值称为低于正常的浮点值现在库已提供了用于检查计算是否会产生低于正常值的函数字符类型用于储存字符如字母或标点符号但是从技术层面看是整数类型在语言中用单引号括起来的单个字符被称为字符常量编译器一发现就会将其转换成相应的代码值非打印字符见有些字符打印不出来例如一些代表行为的字符如退格换行终端响铃或蜂鸣以下有两种方法方法一使用码例如蜂鸣字符的值是因此可以这样写方法二使用转义符转义序列赋给字符变量时必须用单引号把转义序列括起来例如假设有下面一行代码转义序列含义转移符号含义警报垂直制表符退格反斜杠换页单引号换行双引号回车问号水平制表符十六进制值是位十六进制数字即每个可表示中的一个数八进制值必须是有效的八进制数即每个可表示中的一个数可省略数字前多余的默认也为进制但为了防止出问题建议补全为位任意符号输出对应符号对于和等同于使用的十进制对应数据效果何时使用码何时使用转义序列如果要在转义序列假设使用和码之间选择请选择前者即这样的写法不仅更好记而且可移植性更高在不使用码的系统中仍然有效本章注意点变量初始化需要每个值进行初始化否则会造成错误函数的使用实例你的体重相等重量的白金价值获取用户的输入假设白金的价格是每盎司用于把英镑常衡盎司转换为金衡盎司程序的输出在屏幕上一闪而过此时可使用在程序中添加下面一行代码但程序的输出依旧在屏幕上一闪而过本例需要调用两次函数分析在这种情况下键入并按下键发送一个换行符然后读取键入的数字第个读取换行符第个让程序暂停等待输入原因在你输入自己的数值后按下回车函数读取用户输入的体重值时回车键会被当作输入的一部分并被存储在输入缓冲区中函数会读取用户输入的数值但回车键仍然留在缓冲区中并且函数会获取回车键字符声明变量的作用声明为变量创建和标记存储空间数据类型应与打印类型一致实例更多的特性为位和为位的系统输出结果该例表明使用错误的转换说明会得到意想不到的结果原因情况一例如第一行输出内存中的数位相同不同数据类型中不同的位数所表示含义不一样造成输出错误也如和这两个数据类型情况二例如第三四行输出不同的修饰符可以截断成不同类型值从二进制的后往前读取位数把以二进制格式写成一个位数是使用只会查看后位所以显示的值是与此类似输出的最后一行先显示了的完整值然后由于使用了只显示了储存在后位的值注意在使用函数时切记检查每个待打印值都有对应的转换说明还要检查转换说明的类型是否与待打印值的类型相匹配断行输入只要不在引号内部或一个单词中间断行就可以被分为两行函数是语言的内置运算符以字节为单位给出指定类型的大小和提供转换说明匹配的返回类型一些不支持和的编译器可用或代替输入的数据类型与设定数据类型不一致的情况把一个类型的数值初始化给不同类型的变量时编译器会把值转换成与变量匹配的类型这将导致部分数据丢失例如用类型的值初始化类型的变量用类型的值初始化类型的变量第个声明的值是编译器把浮点数转换成整数时会直接丢弃截断小数部分而不进行四舍五入第个声明会损失一些精度因为只保证了类型前位的精度字符串和格式化字符串与数组字符串是一个或多个字符的序列双引号不是字符串的一部分双引号仅告知编译器它括起来的是字符串正如单引号用于标识单个字符一样语言没有专门用于储存字符串的变量类型字符串都被储存在类型的数组数组是同类型数据元素的有序序列中数组由连续的存储单元组成字符串中的字符被储存在相邻的存储单元中数组末尾位置的字符这是空字符语言用它标记字符串的结束空字符不是数字它是非打印字符中的字符串一定以空字符结束这意味着数组的容量必须至少比待存储字符串中的字符数多常量和预处理器假设程序中的多处使用一个常量有时需要改变它的值毕竟税率通常是浮动的如果程序使用符号常量则只需更改符号常量的定义不用在程序中查找使用常量的地方然后逐一修改语言还提供了一个更好的方案预处理器只需在程序顶部添加下面一行用大写表示符号常量是语言一贯的传统这样在程序中看到全大写的名称就立刻明白这是一个符号常量而非变量头文件和分别提供了与整数类型和浮点类型大小限制相关的详细信息如果在程序中包含头文件就可编写下面的代码中的一些明示常量中的一些明示常量函数函数给出字符串中的字符长度输出时可以使用在早期版本中换成或的转化说明修饰符修饰符含义标记表描述了种标记空格和可以不使用标记或使用多个标记不会对输出结果造成影响表示输出时采用左对齐这表示要输出的整数值为正数时要在其前面显示加号而负数仍然会显示减号空格有符号值若为正则在值前面显示前导空格不显示任何符号若为负则在值前面显示减号标记覆盖一个空格把结果转换为另一种形式如果是格式则以开始如果是或格式则以或开始对于所有的浮点格式保证了即使后面没有任何数字也打印一个小数点字符对于和格式防止结果后面的被删除通常情况下整数会用空格来填充以满足指定的宽度但使用可以指示用零字符来填充用于右对齐的情况示例数字最小字段宽度如果该字段不能容纳待打印的数字或字符串系统会使用更宽的字段示例数字对于和转换表示小数点右边数字的位数对于和转换表示有效数字最大位数对于转换表示待打印字符的最大数量对于整型转换表示待打印数字的最小位数如有必要使用前来达到这个位数只使用表示其后跟随一个所以和相同示例打印一个浮点数字段宽度为字符其中小数点后有两位数字和整型转换说明一起使用表示或类型的值示例和整型转换说明一起使用表示或类型的值示例和整型转换说明一起使用表示或类型的值这些类型定义在中示例和整型转换说明一起使用表示或类型的值示例和整型转换说明一起使用表示或类型的值示例和浮点转换说明一起使用表示类型的值示例和整型转换说明一起使用表示类型的值是两个指针差值的类型示例和整型转换说明一起使用表示类型的值是返回的类型示例注中的使用可以代表此处的数值由后面的变量进行决定如此处的字符宽度由进行决定保留小数位数由进行决定读取字符串的规则在读取输入时就已完成把空字符放入字符串末尾这项工作它在遇到第个空白空格制表符或换行符时就不再读取输入的使用如果用读取基本变量类型的值在变量名前加上一个如果用把字符串读入字符数组中不要使用的读取规则每次读取一个字符跳过所有的空白字符直至遇到第个非空白字符才开始读取不断地读取和保存字符直至遇到非数字字符然后把非数字字符放回输入这意味着程序在下一次读取输入时首先读到的是上一次读取丢弃的非数字字符如果第个非空白字符是而不是数字将停在那里并把放回输入中不会把值赋给指定变量程序在下一次读取输入时首先读到的字符是如果程序只使用转换说明就一直无法越过读下一个字符中的使用规则使用可以使跳过前两个函数的赋值在上述代码中跳过两个整数把第个整数拷贝给返回值函数返回读取数据的数量所以如果读取对应类型则返回如果读取不成功则不返回在转换值之前出现问题会返回一个特殊值通常被定义为读取小数值由于输入的小数在语言中默认作为进行处理所以对应的数据类型需要使用否则会出错本章注意点与的区别区别之一在于是基本类型而是派生类型数组区别之二是实际上由两个字符组成和空字符何时使用了圆括号圆括号的使用时机否取决于运算对象是类型还是特定量运算对象是类型时圆括号必不可少但是对于特定量可有可无也就是说对于类型应写成或对于特定量可写成或尽管如此还是建议所有情况下都使用圆括号如限定符标准新增了关键字用于限定一个变量为只读这使得成为一个只读值可以在计算中使用可以打印但是不能更改值运算符表达式和语句运算符基本运算符注没有指数运算符不过的标准数学库提供了一个函数用于指数运算例如返回的次幂赋值运算符并不意味着相等而是一个赋值运算符赋值行为从右往左进行读作把值赋给变量求模运算符用于整数运算求模运算符给出其左侧整数除以右侧整数的余数一元运算符与二元运算符一元运算符只有一个运算对象如二元运算符有两个运算对象如递增递减运算符递增运算符递增运算符执行简单的任务将其运算对象递增递减运算符的前缀形式和后缀形式的区别在最后的输出结果中会发现而这因为后缀在运算过程中在使用完成后再进行递增而前缀先进行递增而后进行计算结合优先级只有圆括号的优先级比递增递减运算符高因此表示的是而不是不过后者无效因为递增和递减运算符只能影响一个变量或者更普遍地说只能影响一个可修改的左值而组合本身不是可修改的左值关系运算符运算符含义小于大于小于或等于大于或等于等于不等于注可以通过关系运算符判断字符但不能判断字符串根据区分大小写通过关系运算符可以比较浮点数但最好使用进行判断因为浮点数在储存时会造成舍入误差造成原本相等的两数不相等可使用函数返回绝对值来进行比较浮点数函数所需的头文件浮点数两数相等所自定义的允许误差逗号运算符逗号运算符扩展了循环的灵活性以便在循环头中包含更多的表达式逗号运算符并不局限于在循环中使用但是这是它最常用的地方逗号运算符有两个其他性质首先它保证了被它分隔的表达式从左往右求值但逗号运算符无法在计算中插入使用以改变计算顺序如是错误的写法假设在写数字时不小心输入了逗号这不是语法错误编译器会将其解释为一个逗号表达式即是逗号左侧的子表达式是右侧的子表达式逗号也可用作分隔符逗号运算符会依次计算每个表达式并返回最后一个表达式的值作为整个逗号运算符表达式的值逻辑运算符逻辑运算符含义与或非备选拼写头文件标准新增了可代替逻辑运算符的拼写它们被定义在头文件中如果在程序中包含该头文件便可用代替代替代替判断范围问题运算符可用于测试范围例如要测试是否在的范围内可以这样写千万不要模仿数学上的写法千万不要这样写由于运算符的求值顺序是从左往右所以编译器把测试表达式解释为子表达式的值要么是为真要么是为假这两个值都小于所以不管的值是多少整个表达式都恒为真因此在范围测试中要使用条件运算符以下述代码为例上述语句翻译为如果大于那么将设置为否则设置为运算符查找地址一元运算符给出变量的存储地址地址通常用十六进制形式表示是输出地址的转换说明间接运算符间接运算符该运算符有时也称为解引用运算符用于给出储存在指针指向地址上的值找出指向的值以上代码相当于如下代码不要把间接运算符和二元乘法运算符混淆虽然它们使用的符号相同但语法功能不同运算符的优先级优先级运算符结合律后缀运算符类型名称列表从左到右一元运算符从右到左类型转换运算符类型名称从右到左乘除法运算符从左到右加减法运算符从左到右移位运算符从左到右关系运算符从左到右相等运算符从左到右位运算符从左到右位运算符从左到右位运算符从左到右逻辑运算符从左到右逻辑运算符从左到右条件运算符从右到左赋值运算符从右到左逗号运算符从左到右一元运算和的优先级相同但结合律是从右往左所以先求值然后才是类型转化在语句和表达式中如果使用混合类型会采用一套规则进行自动类型转换基本的类型转换规则当类型转换出现在表达式时无论是还是的和都会被自动转换成如有必要会被转换成涉及两种类型的运算两个值会被分别转换成两种类型的更高级别在赋值表达式语句中计算的最终结果会被转换成被赋值变量的类型这个过程可能导致类型升级或降级当作为函数参数传递时和被转换成被转换成类型升级通常都不会有什么问题但是类型降级会导致较低类型可能放不下整个数字强制类型转换运算符有时需要进行精确的类型转换或者在程序中表明类型转换的意图这种情况下要用到强制类型转换即在某个量的前面放置用圆括号括起来的类型名第行使用自动类型转换首先和相加得然后为了匹配类型的变量被类型转换截断为整数第行和在相加之前都被转换成整数所以把的和赋给变量本章注意点许多其他语言都会回避该程序中的三重赋值但是完全没问题赋值的顺序是从右往左在语言中除法操作默认会执行整数除法即如果操作数都是整数结果将会是整数而不是浮点数整数除法会截断计算结果的小数部分丢弃整个小数部分不会四舍五入结果在定义函数时需要在最上面进行函数原型声明未进行函数的声明或未指定参数类型的情况下会导致参数升级为不正确的数据类型在函数调用中显式使用强制类型转换可以修复这个问题把强制类型转换为正确的类型所以最好在开头进行函数的原型声明循环循环使用格式判断条件此处不加条件成立的执行语句通过括号的数值最后是否为来进行判断一个真假若为则为假若不为则为真但语言中为假而为真后加表示执行空语句循环使用格式语句语句语句第个表达式是初始化只会在循环开始时执行一次第个表达式是测试条件在执行循环之前对表达式求值如果表达式为假循环结束第个表达式执行更新在每次循环结束时执行注在循环中可以省略一个或多个语句但分号不能省略在语句的所定义的变量是局部变量只在此循环内的语句中有效循环使用格式执行语句可为单一语句或者复合语句判断条件此处一定要加分号循环在执行完循环体后才执行测试条件所以至少执行循环体一次本章注意点逻辑判断符号与赋值符号不要混淆语句一语句二语句一中为判断是否等于语句二为将赋值给最后将的参数给最后造成语句二的循环不断进行分支与跳转语句使用格式判断语句此处不加分号执行语句可为单语句或多语句执行语句可为单语句或多语句执行语句可为单语句或多语句与配对原则与离它最近的匹配除非最近的被花括号括起来数值的范围判断问题语句语句让程序跳过语句后在循环内的代码让程序重新进入循环还可用作占位符例如下面的循环读取并丢弃输入的数据直至读到行末尾语句程序执行到循环中的语句时会终止包含它的循环并继续执行下一阶段多重选择和使用格式整数值包括类型值表达式中只包含整型常量执行语句值表达式中只包含整型常量执行语句执行语句注只处理了第个字符语句让程序离开语句跳至语句后面的下一条语句如果没有语句就会从匹配标签开始执行到末尾语句可用于循环和语句中但是只能用于循环中多重标签可以在语句中使用多重标签假设如果是字母语句会定位到标签为的位置由于该标签没有关联语句所以程序流直接执行下一条语句即如果是字母程序流会直接定位到本质上两个标签都指的是相同的语句和函数函数不带任何参数它从输入队列中返回下一个字符例如下面的语句读取下一个字符输入并把该字符的值赋给变量与上一句等效函数打印它的参数例如下面的语句把之前赋给的值作为字符打印出来于上一句等效由于这些函数只处理字符所以它们比更通用的和函数更快更简洁而且注意和不需要转换说明因为它们只处理字符这两个函数通常定义在头文件库有一系列专门处理字符的函数头文件包含了这些函数的原型这些函数接受一个字符作为参数如果该字符属于某特殊的类别就返回一个非零值真否则返回假数组数组是按顺序储存的一系列类型相同的值声明是一个内含个元素的数组每个元素都可以储存类型的值数组的第个元素是第个元素是以此类推直到注意数组元素的编号从开始不是从开始字符组与字符串的差别字符串最末尾有由空字符而字符组没有如果类型的数组末尾包含一个表示字符串末尾的空字符则该数组中的内容就构成了一个字符串指定数组大小在标准之前声明数组时只能在方括号中使用整型常量表达式所谓整型常量表达式是由整型常量构成的表达式可以可以可以不可以数组大小必须大于不可以数组大小必须大于不可以数组大小必须是整数可以已被强制转换为整型常量之前不允许之前不允许未指定数组大小编译器会把数组的大小设置为足够装得下初始化的值初始化数组从开始支持这种初始化如上所示用以逗号分隔的值列表用花括号括起来来初始化数组各值之间用逗号分隔在逗号和值之间可以使用空格根据上面的初始化把赋给数组的首元素以此类推除在声明时可使用对数组进行赋值其他时候只能用变量序号对数组进行逐一赋值注使用声明数组可把数组设置为只读声明数组形参因为数组名是该数组首元素的地址作为实际参数的数组名要求形式参数是一个与之匹配的指针只有在这种情况下才会把和解释成一样也就是说是指向的指针由于函数原型可以省略参数名所以下面种原型都是等价的但是在函数定义中不能省略参数名指定初始化器适用于把初始化为而规定可以在初始化列表中使用带方括号的下标指明待初始化的元素指定初始化的一些特性如果指定初始化器后面有更多的值那么后面这些值将被用于初始化指定元素后面的元素如该例中的初始化列表中的片段那么后面这些值将被用于初始化指定元素后面的元素第二如果再次初始化指定的元素那么最后的初始化将会取代之前的初始化例如程序清单中初始化列表开始时把初始化为但是又被后面的指定初始化初始化为二维数组声明数据类型变量主数组个数每个主数组所需的个数初始化例初始化时也可省略内部的花括号只保留最外面的一对花括号只要保证初始化的数值个数正确初始化的效果与上面相同但是如果初始化的数值不够则按照先后顺序逐行初始化直到用完所有的值其他多维数组二维数组的相关内容都适用于三维数组或更多维的数组修饰数组如果程序稍后尝试改变数组元素的值编译器将生成一个编译期错误消息如果此时声明指向这个数组此时指针也必须用修饰且不能修改解引用指针的值否则都将报错不允许不允许但可以进行指针加法让指向没问题注意把数据或非数据的地址初始化为指向的指针或为其赋值是合法的此时不能修改解引用指针的值变长数组适用在创建数组时可以使用变量指定数组的维度注变长数组中的变不是指可以修改已创建数组的大小一旦创建了变长数组它的大小则保持不变这里的变指的是声明一个带二维变长数组参数的函数注前两个形参和用作第个形参二维数组的两个维度因为的声明要使用和所以在形参列表中必须在声明之前先声明这两个形参以下为错误写法变形标准规定可以省略原型中的形参名但是在这种情况下必须用星号来代替省略的维度需要注意的是在函数定义的形参列表中声明的变长数组并未实际创建数组和传统的语法类似变长数组名实际上是一个指针这说明带变长数组形参的函数实际上是在原始数组中处理数组因此可以修改传入的数组复合字面量使用字面量是除符号常量外的常量例如是类型字面量是类型的字面量创建下面的复合字面量创建了一个和数组相同的匿名数组也有两个类型的值复合字面量其中即是复合字面量的类型名初始化有数组名的数组时可以省略数组大小复合字面量也可以省略大小编译器会自动计算数组当前的元素个数内含个元素的复合字面量使用因为复合字面量是匿名的所以不能先创建然后再使用它必须在创建的同时使用它用法一使用指针记录地址用法二把复合字面量作为实际参数传递给带有匹配形式参数的函数本章注意点数组名是数组首元素的地址如果是一个数组下面的语句成立数组名是该数组首元素的地址多维数组的双重间接性质假设有下面的声明内含数组的数组然后数组名是该数组首元素的地址因为是数组首元素的地址所以的值和的值相同而本身是一个内含两个整数的数组所以的值和它首元素一个整数的地址即的值相同简而言之是一个占用一个大小对象的地址而是一个占用两个大小对象的地址由于这个整数和内含两个整数的数组都开始于同一个地址所以的值相同给指针或地址加其值会增加对应类型大小的数值在这方面和不同因为指向的对象占用了两个大小而指向的对象只占用一个大小因此和的值不同与等价这相当于解引用一个指针在指针前使用运算符或在数组名后使用带下标的运算符得到引用对象代表的值其中解引用主数组的结果就是次数组即成立总结将数组理解成数组的数组因占用地址为首元素的数据类型大小及其个数是一个占用一个大小对象的地址而是一个占用两个大小对象的地址由于主数组为的合集故和的值不同即成立解引用主数组形参就是得到主数组的第一个值也就是次数组数组中的使用在数组中被视为整型常量可以用于声明数组内的数目如指针指针是一个值为内存地址的变量或数据对象声明指针声明变量的指针因声明指针变量时必须指定指针所指向变量的类型因为不同的变量类型占用不同的存储空间一些指针操作要求知道操作对象的大小另外程序必须知道储存在指定地址上的数据类型以下为声明指针的例子是指向类型变量的指针是指向类型变量的指针都是指向类型变量的指针类型说明符表明了指针所指向对象的类型星号表明声明的变量是一个指针声明多维数组的指针多维数组的指针会有不同大小的地址因此多维数组的指针在声明是必须指向一个内含对应个数和对应文件类型的数组例如指向一个内含两个类型值的数组前面有圆括号的版本先与结合因此声明的是一个指向数组内含两个类型的值的指针区别于是一个内含两个指针元素的数组每个元素都指向的指针由于优先级高先与结合所以成为一个内含两个元素的数组然后表示数组内含两个指针最后表示数组中的指针都指向类型的值因此这行代码声明了两个指向的指针声明函数指针方式一函数返回类型指针名函数列表声明函数指针指针名函数名将函数的地址赋值给函数指针函数名实际上是函数地址方式二函数返回类型指针名函数列表函数名声明并初始化函数指针声明指向指针的指针指向的指针数据类型指针名被指向的指针例如指向类型的指针指向类型的指针种基本用法赋值解引用取址指针与整数相加递增指针指针减去一个整数递减指针指针求差注关系运算符可以比较两个指针的值可以用一个指针减去另一个指针得到一个整数或者用一个指针减去一个整数得到另一个指针指针和指针不能直接相加指针运算与递增递减操作特别注意只有指针变量可以进行递增递减操作如数组名字符串常量等指针常量等不能进行递增递减操作正确错误解引用未初始化的指针切记创建一个指针时系统只分配了储存指针本身的内存并未分配储存数据的内存指针未被初始化其值是一个随机值所以不知道将储存在何处这可能不会出什么错也可能会擦写数据或代码或者导致程序崩溃函数指针在语言中函数指针允许我们将函数的地址存储在指针变量中并通过该指针变量来调用函数其调用格式与函数相同指针名参数列表使用实例声明函数指针将函数的地址赋值给函数指针调用函数将函数的地址赋值给函数指针调用函数指针的兼容性指针之间的赋值比数值类型之间的赋值要严格两个类型的指针不能相互赋值本章注意点指针加法在中指针加指的是增加一个存储单元指针加的操作并不是简单地将指针的值增加而是将指针向后移动一个存储单元的大小对数组而言这意味着把加后的地址是下一个元素的地址而不是下一个字节的地址函数函数的声明定义与引用函数的声明函数定义的数据返回类型函数名参数列表函数的定义数据返回类型函数名参数列表函数体返回变量函数引用函数名参数列表函数参数的传递变量编写一个处理基本类型如的函数时要选择是传递类型的值还是传递指向的指针通常都是直接传递数值只有程序需要在函数中改变该数值时才会传递指针这意味着在语言中函数参数传递是按值传递的这意味着在函数调用时实参的值会被复制到形参中实参不会因为函数中的语句而被修改但可利用指针修改实参的内存地址所对应的值来进行修改实参例交换两个参数的值是所以指向这意味着用即可表示的值这正是我们需要的不要写成这样这条语句相当于数组对于数组别无选择必须传递指针因为这样做效率高如果一个函数按值传递数组则必须分配足够的空间来储存原数组的副本然后把原数组所有的数据拷贝至新的数组中如果把数组的地址传递给函数让函数直接处理原数组则效率要高字符串定义字符串用双引号括起来的内容称为字符串字面量也叫作字符串常量双引号中的字符和编译器自动加入末尾的字符都作为字符串储存在内存中等价于字符串常量例如类型数组例如指向的指针例如注如果要在字符串内部使用双引号必须在双引号前面加上一个反斜杠字符串串联规则从标准起如果字符串字面量之间没有间隔或者用空白字符分隔包括换行会将其视为串联起来的字符串字面量数组形式和指针形式的区别数组数组形式在计算机的内存中分配为一个内含字母数个元素的数组每个元素对应一个字符还加上一个末尾的空字符每个元素被初始化为字符串字面量对应的字符通常字符串都作为可执行文件的一部分储存在数据段中当把程序载入内存时也载入了程序中的字符串字符串储存在静态存储区中但是程序在开始运行时才会为该数组分配内存此时才将字符串拷贝到数组中注意此时字符串有两个副本一个是在静态内存中的字符串字面量另一个是储存在数组中的字符串即以下流程字符串的内存分配字符串的初始化字符串的存储位置字符串的拷贝注此时编译器便把数组名识别为该数组首元素地址数组名的别名这里关键要理解在数组形式中数组名是地址常量不能更改如果改变了则意味着改变了数组的存储位置即地址可以进行类似数组名这样的操作标识数组的下一个元素但是不允许进行数组名这样的操作指针指针形式也使得编译器为字符串在静态存储区预留元素的空间另外一旦开始执行程序它会为指针变量留出一个储存位置并把字符串的地址储存在指针变量中注该变量最初指向该字符串的首字符但是它的值可以改变因此可以使用递增运算符例如将指向第个字符用双引号括起来的内容被视为指向该字符串储存位置的指针类似于字符数组的指针只指向第一个字母这类似于把数组名作为指向该数组位置的指针注字符串字面量被视为数据由于指向这个数据所以应该把声明为指向数据的指针这意味着不能用改变它所指向的数据但是仍然可以改变的值即指向的位置如果把一个字符串字面量拷贝给一个数组就可以随意改变数据除非把数组声明为函数和函数一样函数也属于系列的输入输出函数但是与不同的是函数只显示字符串而且自动在显示的字符串末尾加上换行符一些神奇的语句学习过程中碰到了一些我觉得很神奇的语句逻辑运算符在赋值中的直接使用此时在中嵌入函数此时程序先运行函数后将函数的返回值输入给若为整数则返回若为非整数则返回在中的括号中填入数字若括号中的数值不为即可执行循环可利用的返回值对变量进行赋值获取字符同时进行判断等同于给赋一个值把和作比较但区别于运算符的优先级比高所以先对表达式求值由于这是关系表达式所以其值不是就是真或假然后把该值赋给由于保证在给数组分配空间时指向数组后面第一个位置的指针仍是有效的指针可写出一些简洁的函数数组元素之和使用指针算法把数组元素的值加起来让指针指向下一个元素注意使用这种越界指针超出数组有含义的内存地址的函数调用更为简洁多维数组的解引用与加法操作代替数组表示法日记循环局部变量错误源代码错误地方在错误的循环处被重新定义变成循环的局部变量',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-13 00:21:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 22
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="WELLS Blog" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">WELLS Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/summarize/"><i class="anzhiyufont anzhiyu-icon-list-ul faa-tada" style="font-size: 0.9em;"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于我</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc"></div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF-Web/" style="font-size: 1.05rem;">CTF-Web<sup>15</sup></a><a href="/tags/CTF-WriteUp/" style="font-size: 1.05rem;">CTF-WriteUp<sup>3</sup></a><a href="/tags/Tools/" style="font-size: 1.05rem;">Tools<sup>1</sup></a><a href="/tags/Web-FileUpload/" style="font-size: 1.05rem;">Web-FileUpload<sup>1</sup></a><a href="/tags/Web-Middleware/" style="font-size: 1.05rem;">Web-Middleware<sup>1</sup></a><a href="/tags/Web-PHP/" style="font-size: 1.05rem;">Web-PHP<sup>3</sup></a><a href="/tags/Web-SQL/" style="font-size: 1.05rem;">Web-SQL<sup>4</sup></a><a href="/tags/Web-Unserialize/" style="font-size: 1.05rem;">Web-Unserialize<sup>1</sup></a><a href="/tags/Web-XSS/" style="font-size: 1.05rem;">Web-XSS<sup>3</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url">编程</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%BC%80%E5%8F%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>开发</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C Primer Plus笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-24T12:28:28.000Z" title="发表于 2023-09-24 20:28:28">2023-09-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-03-12T16:21:02.503Z" title="更新于 2024-03-13 00:21:02">2024-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">17.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C Primer Plus笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为China"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>China</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/cover/65a00feec63ae.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://we11s.github.io/posts/3276277813/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url">编程</a><a href="/tags/%E5%BC%80%E5%8F%91/" tabindex="-1" itemprop="url">开发</a><h1 id="CrawlerTitle" itemprop="name headline">C Primer Plus笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Wells</span><time itemprop="dateCreated datePublished" datetime="2023-09-24T12:28:28.000Z" title="发表于 2023-09-24 20:28:28">2023-09-24</time><time itemprop="dateCreated datePublished" datetime="2024-03-12T16:21:02.503Z" title="更新于 2024-03-13 00:21:02">2024-03-13</time></header><h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a><strong>C语言概述</strong></h1><h2 id="C程序的基本结构"><a href="#C程序的基本结构" class="headerlink" title="C程序的基本结构"></a>C程序的基本结构</h2><p>​       程序由一个或多个函数组成，<strong>必须有 main()函数。</strong></p>
<p>​        函数由函数头和函数体组成。函数头包括函数名、传入该函数的信息类型和函数的返回类型。通过函数名后的圆括号可识别出函数，圆括号里可能为空，可能有参数。函数体被花括号括起来，由一系列语句、声明组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">//函数头</span></span><br><span class="line"><span class="comment">/* 以下为函数体 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q;  <span class="comment">//声明</span></span><br><span class="line">    q = <span class="number">1</span>;  <span class="comment">//语句</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d is neat.\n&quot;</span>,q);  <span class="comment">//语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* two_func.c -- 一个文件中包含两个函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* ANSI/ISO C函数原型 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I will summon the butler function.\n&quot;</span>);</span><br><span class="line">butler();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes. Bring me some tea and writeable</span></span><br><span class="line"><span class="string">DVDs.\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* 函数定义开始 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You rang, sir?\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I will summon the butler function.</span><br><span class="line">You rang, sir?</span><br><span class="line">Yes.Bring me some tea and writeable DVDs.</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>​       <code>butler()</code> 函数在程序中出现了3 次。第1 次是函数原型（prototype），告知编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出现在 <code>main()</code>中；最后一次出现在函数定义（function definition）中，</p>
<p><strong><code>butler（）</code>单独不运行的原因：</strong></p>
<p>​        在典型的C程序中，<strong>只有<code>main</code>函数会在程序启动时自动执行</strong>。其他函数不会在程序启动时自动执行，除非它们被显式地从<code>main</code>函数或其他函数中调用。在您提供的代码示例中，只有<code>main</code>函数会在程序启动时执行，因为它是程序的入口点。其他函数，如<code>butler</code>函数，只有在被调用时才会执行。</p>
<h2 id="关键字与保留标识符"><a href="#关键字与保留标识符" class="headerlink" title="关键字与保留标识符"></a>关键字与保留标识符</h2><p>​        <strong>关键字</strong>是C语言的词汇。不能用它们作为标识符（如，变量名）。</p>
<p>​        <strong>保留标识符</strong>（reserved identifier），C语言已经指定了它们的用途或保留它们的使用权，如果你使用这些标识符来表示其他意思会导致一些问题。保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf()。</p>
<h2 id="本章注意点："><a href="#本章注意点：" class="headerlink" title="本章注意点："></a><strong>本章注意点：</strong></h2><hr>
<h3 id="标识符名"><a href="#标识符名" class="headerlink" title="标识符名"></a>标识符名</h3><p>可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第1个字符必须是字符或下划线，<strong>不能是数字</strong>。</p>
<p>操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如，_kcab），因此最好避免在自己的程序中使用这种名称。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\t代表Tab键，\b代表Backspace键（退格键）。<strong>每个转义序列都以反斜杠字符（\）开始。</strong></p>
<p>​        反转义符的使用通常发生在<strong>字符串文字（用双引号或单引号括起来的文本）</strong>中，以便在其中插入特殊字符或控制字符。所以，一般来说，反转义符需要在字符串文字中使用，不管是在双引号(“”)中还是单引号(‘’)中。</p>
<h3 id="参数中的-d在打印时有什么作用？"><a href="#参数中的-d在打印时有什么作用？" class="headerlink" title="参数中的%d在打印时有什么作用？"></a>参数中的%d在打印时有什么作用？</h3><p><code>%d</code>相当于是一个占位符，其作用是指明输出值的位置。</p>
<p><code>%</code>提醒程序，要在该处打印一个变量，d表明把变量作为十进制整数打印。</p>
<p><code>printf()</code>函数名中的这个 <code>f</code>表示 “format”（格式），提醒用户这是一种格式化打印函数。</p>
<hr>
<h1 id="数据与C"><a href="#数据与C" class="headerlink" title="数据与C"></a><strong>数据与C</strong></h1><h2 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h2><table>
<thead>
<tr>
<th>K&amp;R给出的关键字</th>
<th>C90标准添加的关键字</th>
<th>C99标准添加的关键字</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>signed</td>
<td>_Bool</td>
</tr>
<tr>
<td>long</td>
<td>void</td>
<td>_Complex</td>
</tr>
<tr>
<td>short</td>
<td></td>
<td>_Imaginary</td>
</tr>
<tr>
<td>unsigned</td>
<td></td>
<td></td>
</tr>
<tr>
<td>char</td>
<td></td>
<td></td>
</tr>
<tr>
<td>float</td>
<td></td>
<td></td>
</tr>
<tr>
<td>double</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>注：</strong>在C语言中</p>
<p>​        用<code>int</code>关键字来表示基本的整数类型。后3个关键字（<code>long</code>、<code>short</code>和<code>unsigned</code>）和C90新增的<code>signed</code>用于提供基本整数类型的变式，例如<code>unsigned short int</code>和<code>long long int</code>。</p>
<p>​        <code>char</code>关键字用于指定字母和其他字符（如，#、$、%和*）。另外，char类型也可以表示较小的整数。</p>
<p>​        <code>float</code>、<code>double</code>和<code>long double</code>表示带小数点的数。</p>
<p>​        <code>_Bool</code> 类型表示布尔值（ <code>true</code> 或<code>false</code> ） ， <code>_complex</code> 和<code>_Imaginary</code>分别表示复数和虚数。</p>
<p>​        <code>unsigned int</code>或<code>unsigned</code>只用于非负值的场合。这种类型与有符号类型表示的范围不同。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。例如，16位<code>unsigned int</code>允许的取值范围是<code>0～65535</code>，而不是-32768～32767。</p>
<h2 id="不同数据类型的储存"><a href="#不同数据类型的储存" class="headerlink" title="不同数据类型的储存"></a>不同数据类型的储存</h2><h3 id="整数的储存"><a href="#整数的储存" class="headerlink" title="整数的储存"></a>整数的储存</h3><p>整数类型通常以<strong>二进制补码</strong>形式存储在内存中。补码表示法用于表示正数、负数和零。</p>
<p><strong>以转化-56为例：</strong></p>
<ol>
<li><p><strong>确定绝对值的二进制表示：</strong>将负数的绝对值转换为正数的二进制表示。</p>
<p>​        首先，找出-56的绝对值，即56，并将其转换为二进制。56的二进制表示为111000。</p>
</li>
<li><p><strong>取反：</strong>将这个正数的二进制表示中的每个位都取反，即0变为1，1变为0。</p>
<p>​       现在，将上一步得到的二进制表示中的每一位取反，0变为1，1变为0，得到000111。</p>
</li>
<li><p><strong>加1：</strong>接下来，在取反后的二进制数上加1。</p>
<p>​       接下来，在取反后的结果上加1。000111 + 1 &#x3D; 001000。</p>
</li>
<li><p><strong>添加符号位：</strong>符号位是二进制表示中的一个特殊位，用于表示一个数的正负。在有符号整数表示法中，符号位通常是最高位（最左边的位），用来表示整数的正负性。</p>
<p>在得到的结果前面添加符号位，因为原数是负数，所以最高位为1。最终的补码表示为1001000&#96;。</p>
</li>
</ol>
<p><strong>整数的最大最小值</strong></p>
<ul>
<li>C 标准对基本数据类型只规定了允许的最小大小。</li>
<li>对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64 位的需求， 最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long 的最小取值范围是[0,18446744073709551615]</li>
</ul>
<h3 id="浮点数的储存"><a href="#浮点数的储存" class="headerlink" title="浮点数的储存"></a>浮点数的储存</h3><p>以IEEE 754标准，32位可以用于表示大约7个有效数字的浮点数，64位可以用于表示大约15到17位的有效数字。</p>
<p>以<strong>单精度浮点数（32位）</strong>为例：</p>
<p>​        遵循IEEE 754标准，这个标准定义了浮点数的二进制表示方式以及进行浮点数运算的规则。</p>
<ul>
<li>1位用于表示符号位（正负号），0表示正数，1表示负数。</li>
<li>8位用于表示指数部分（exponent）。</li>
<li>剩下的23位用于表示尾数部分（mantissa）。</li>
</ul>
<p><strong>以转化42.625为例</strong></p>
<ol>
<li><p><strong>将整数部分转换为二进制</strong>：</p>
<p>将整数部分42转换为二进制，得到<code>101010</code>。</p>
</li>
<li><p><strong>将小数部分转换为二进制</strong>：</p>
<p>将小数部分0.625转换为二进制。通常，可以将小数部分乘以2并取整数部分，然后将余数作为下一位的小数部分，一直重复直到小数部分为0或者达到所需的精度。对于0.625，这个过程如下：</p>
<ul>
<li>0.625 * 2 &#x3D; 1.25，整数部分是1，小数部分更新为0.25。</li>
<li>0.25 * 2 &#x3D; 0.5，整数部分是0，小数部分更新为0.5。</li>
<li>0.5 * 2 &#x3D; 1.0，整数部分是1，小数部分更新为0.0。</li>
</ul>
<p>因此，0.625的二进制表示为<code>0.101</code>。</p>
</li>
<li><p><strong>将整数部分和小数部分组合</strong>：</p>
<p>将整数部分<code>101010</code>和小数部分<code>0.101</code>组合在一起，得到二进制表示<code>101010.101</code>。</p>
</li>
<li><p><strong>规范化</strong>：</p>
<p>在IEEE 754中，浮点数采用科学计数法表示，其中二进制小数点位于左边的第一个非零位前面。因此，需要将二进制数规范化，将小数点移到合适的位置。在这种情况下，将小数点移到最左边，得到规范化的二进制表示为<code>1.01010101 x 2^5</code>。</p>
</li>
<li><p><strong>确定指数和尾数</strong>：</p>
<ul>
<li>指数：因为小数点向左移了5位，所以指数为5。在IEEE 754中，还需要加上一个偏移值（127），因此指数为5 + 127 &#x3D; 132。以8位表示指数，二进制为<code>10000100</code>。</li>
<li>尾数：小数点左边的部分是尾数，即<code>01010101</code>。</li>
</ul>
</li>
<li><p><strong>组合符号、指数和尾数</strong>：</p>
<ul>
<li>符号位：因为42.625是正数，所以符号位为0。</li>
<li>指数：上面计算得到的8位指数为<code>10000100</code>。</li>
<li>尾数：上面计算得到的尾数为<code>01010101</code>。</li>
</ul>
</li>
</ol>
<p>最终，将这些组合在一起得到32位的浮点数表示为：<code>0 10000100 01010101000000000000000</code></p>
<p>这就是42.625的单精度浮点数表示，其中第一个位是符号位，接下来的8位是指数，剩下的23位是尾数。这个二进制表示可以转换为十进制浮点数为42.625。</p>
<p><strong>注：</strong></p>
<p><strong>偏移值的作用：使次方数换算为二进制时不出现小数点</strong></p>
<p><strong>偏移值的确定即确定最小次方数：</strong>（以32位为例）</p>
<p>​        32位精度有8位二进制用来表示次方数，故次方的范围数位(2**8 -1)即255。0占去1位，剩下正负进行平分，故最小的次方数位-127，故偏移值为127，加上偏移值后次方数不存在负数的情况</p>
<p><strong>因使用过二进制的科学计数法，小数点前一定为1，故尾数部分只取小数点后的一部分</strong></p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="进制书面表示"><a href="#进制书面表示" class="headerlink" title="进制书面表示"></a><strong>进制书面表示</strong></h3><ul>
<li>1011B表示二进制1011，也记作（1011）2</li>
<li>1357O(字母O)表示八进制1357，也记为（1357）8</li>
<li>2049D表示为十进制2049，也记作（2049）10</li>
<li>3FB9H表示十六进制数3FB9，也记作（3FB9）16</li>
</ul>
<h3 id="初始化变量时的进制表示"><a href="#初始化变量时的进制表示" class="headerlink" title="初始化变量时的进制表示"></a>初始化变量时的进制表示</h3><ul>
<li>加<code>0b</code>或者<code>0B</code>表示二进制</li>
<li>加<code>0</code>表示八进制</li>
<li>加<code>0x</code>或<code>0X</code>表示16进制</li>
<li>不加默认表示10进制</li>
</ul>
<p>可在<strong>整数</strong>输入的数值后添加<code>L/l</code>表示此整数以32位进制运算，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">7L</span></span><br></pre></td></tr></table></figure>

<p>可在浮点数后输入f表示此浮点数以32位float进行运算（默认为64位double进行运算），以便提高运算效率，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">7.0f</span></span><br></pre></td></tr></table></figure>



<h3 id="输出中的进制表示"><a href="#输出中的进制表示" class="headerlink" title="输出中的进制表示"></a>输出中的进制表示</h3><ul>
<li><code>%d/%i</code>表示有符号十进制输出</li>
<li><code>%x</code>或<code>%X</code>表示以十六进制输出</li>
<li><code>%o</code>表示以八进制输出</li>
<li><code>%f</code>表示输出单精度浮点数</li>
<li><code>%ld</code>表示输出长整型十进制整数</li>
<li><code>%lo</code>表示输出长整型八进制整数</li>
<li><code>%lx</code>表示输出长整型十六进制整数</li>
<li><code>%lf</code>表示输出双精度浮点数</li>
<li><code>%c</code>格式对应的是单个字符</li>
<li><code>%s</code>格式对应的是字符串</li>
<li><code>%hd</code>表示输出short类型的十进制整数</li>
<li><code>%ho</code>表示输出short类型的八进制整数</li>
<li><code>%hx</code>表示输出short类型的十六进制整数</li>
<li><code>%lld</code>表示输出<code>long long int</code>整数</li>
<li><code>%llx</code>表示输出<code>long long int</code>十六进制整数</li>
<li><code>%llo</code>表示输出<code>long long int</code>八进制整数</li>
<li><code>%llu</code>表示输出<code>long long unsigned</code>整数</li>
<li><code>%u</code>表示输出无符号整数</li>
<li><code>%e/%E</code>表示输出以指数计数法的浮点数</li>
<li><code>%le/%E</code>表示输出以指数计数法的长浮点数</li>
<li><code>%a/%A</code>表示输出以十六进制指数计数法的浮点数</li>
<li><code>%%</code>表示输出百分号</li>
<li><code>%p</code>（在不支持<code>%p</code>的编译器中<code>%u</code> 或<code>%lu</code> 代替<code>%p</code>）表示指针</li>
<li><code>%g/%G</code>自动选择以<code>%f</code>或<code>%e</code>输出</li>
<li><code>%zd</code>作为函数<code>sizeof()</code>的输出</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li><p><code>unsigned</code> 修饰符不能用于浮点数类型。它只能用于整数数据类型</p>
</li>
<li><p>默认八进制和十六进制都是整数类型数值</p>
</li>
<li><p>输出时，如果要在八进制和十六进制值前显示<code>0</code>和<code>0x</code>前缀，要分别在转换说明中加入#（即在%后加入#）</p>
</li>
<li><p><code>%1f</code>表示输出浮点数并保留小数点后一位</p>
</li>
<li><p><code>%1.2f</code>表示输出浮点数且小数点前至少一字节（不足空格补足）并保留两位小数</p>
</li>
<li><p><code>%d</code>可用于输出<code>char</code>类型的变量，但不能用于<code>scanf()</code>赋值</p>
</li>
</ul>
<h3 id="进制的转化（1）–负数"><a href="#进制的转化（1）–负数" class="headerlink" title="进制的转化（1）–负数"></a>进制的转化（1）–负数</h3><h4 id="十进制转二进制（十进制为负数）"><a href="#十进制转二进制（十进制为负数）" class="headerlink" title="十进制转二进制（十进制为负数）"></a>十进制转二进制（十进制为负数）</h4><p>当将负数从十进制转换为二进制时，通常会使用二进制补码表示法。这是因为在计算机内部，负数通常以二进制补码的形式存储。下面是将负数转换为二进制的一般过程：</p>
<ol>
<li><p><strong>确定负数的绝对值</strong>：首先，确定负数的绝对值。例如，如果要将-5转换为二进制，绝对值是5。</p>
</li>
<li><p><strong>将绝对值转换为二进制</strong>：将绝对值转换为二进制的标准方法是使用除2取余法（或称为短除法）：</p>
<ul>
<li>不断将绝对值除以2，同时记录每一步的余数。</li>
<li>将余数以逆序的方式排列，就得到了二进制表示。例如，对于绝对值5，过程如下：<ul>
<li>5 ÷ 2 &#x3D; 2 余 1</li>
<li>2 ÷ 2 &#x3D; 1 余 0</li>
<li>1 ÷ 2 &#x3D; 0 余 1</li>
</ul>
</li>
<li>然后，将这些余数逆序排列，得到二进制数101。</li>
</ul>
</li>
<li><p><strong>将二进制数取反</strong>：在二进制补码中，正数的补码和原码相同，但负数的补码需要将其绝对值的二进制数取反，即0变为1，1变为0。在上面的例子中，二进制数101取反后变为010。</p>
</li>
<li><p><strong>将取反后的结果加1</strong>：最后一步是将取反后的结果加1。在上面的例子中，010 + 1 &#x3D; 011。</p>
</li>
<li><p><strong>加上符号位</strong>：最终，加上符号位。在二进制补码中，符号位是最左边的位，0表示正数，1表示负数。在上面的例子中，要表示-5，将最左边的位设置为1，得到最终结果1101。</p>
</li>
</ol>
<p>所以，将负数-5转换为二进制补码的结果是1101。这个过程可以用于将任何负数转换为二进制补码。请注意，不同的编程语言可能有不同的方式来表示二进制补码，但这个过程是通用的。</p>
<h4 id="二进制转十进制（符号位为1）"><a href="#二进制转十进制（符号位为1）" class="headerlink" title="二进制转十进制（符号位为1）"></a>二进制转十进制（符号位为1）</h4><ol>
<li><p><strong>找到符号位</strong>：首先，从二进制表示中找到符号位。在二进制补码中，符号位是最左边的位，1表示负数，0表示正数。</p>
</li>
<li><p><strong>取反</strong>：将除符号位以外的所有位取反，即0变为1，1变为0。这是为了得到负数的绝对值的二进制表示。</p>
</li>
<li><p><strong>加1</strong>：对取反后的结果加1，以得到负数的绝对值的二进制补码表示。</p>
</li>
<li><p><strong>计算绝对值的十进制</strong>：将上一步得到的二进制数转换为十进制。这是标准的二进制到十进制转换。从最右边的位（最低位）开始，将每个位的值乘以2的幂，然后相加，直到处理完所有位。</p>
</li>
<li><p><strong>加上负号</strong>：根据最初的符号位，将正数的绝对值前面添加负号。</p>
</li>
</ol>
<p>让我们以一个例子来说明这个过程。假设我们有一个8位的二进制补码：11011010。</p>
<ol>
<li>找到符号位：符号位是最左边的位，1表示负数。</li>
<li>取反：去除符号位并将其余位取反，得到00100110。</li>
<li>加1：对取反后的结果加1，得到00100111。</li>
<li>计算绝对值的十进制：将00100111转换为十进制。从右到左，第1位是1，第2位是2，第3位是4，第4位是0，第5位是0，第6位是0，第7位是0，第8位是-128（因为符号位是1）。计算总和：1 + 2 + 4 + 0 + 0 + 0 + 0 + (-128) &#x3D; -121。</li>
<li>加上负号：最初的符号位是1，所以最终结果是-(-121)，即121。</li>
</ol>
<p>因此，二进制补码11011010对应的十进制值是121。这个过程可以用于将任何负数的二进制补码表示转换为十进制。</p>
<h3 id="进制的转换（2）-正数"><a href="#进制的转换（2）-正数" class="headerlink" title="进制的转换（2）-正数"></a>进制的转换（2）-正数</h3><p>​     正数的转化无需像负数-取反、加一，直接将除符号位的二进制转化为十进制即可</p>
<h2 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>程序实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（printf()函数使用%u说明显示unsigned int类型的值）。*/</span></span><br><span class="line"><span class="comment">/* toobig.c-- 超出系统允许的最大int值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-2147483648</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">2147483647</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">4294967295</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, i - <span class="number">1</span>, i - <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, k, k + <span class="number">1</span>, k + <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u %u %u\n&quot;</span>, j, j + <span class="number">1</span>, j + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-2147483648 2147483647 2147483646</span><br><span class="line">2147483647 -2147483648 -2147483647</span><br><span class="line">4294967295 0 1</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 <code>i</code> 也是类似的情况。它们主要的区别是，在超过最大值时，<code>unsigned int 类型</code>的变量 <code>j</code> 从 0开始；而<code>int类型</code>的变量i则从−2147483648（从绝对值最大）开始。</p>
<h3 id="浮点值的上溢和下溢"><a href="#浮点值的上溢和下溢" class="headerlink" title="浮点值的上溢和下溢"></a>浮点值的上溢和下溢</h3><p><strong>上溢：</strong></p>
<p>​      当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。在这种情况下会给toobig赋一个表示<strong>无穷大的特定值</strong>，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。</p>
<p><strong>下溢：</strong></p>
<p>​      当出现下溢的时候，计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。</p>
<p>C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。</p>
<p>在C 语言中， 用单引号（<code>&#39; &#39;</code>）括起来的单个字符被称为字符常量。编译器一发现<code>&#39;A&#39;</code>，就会将其转换成相应的代码值。</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>见<code>C Primer Plus 140-144</code></p>
<p>有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）</p>
<p>以下有两种方法</p>
<p>方法一：使用ASCII码</p>
<p>例如，蜂鸣字符的ASCII值是7，因此可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> beep = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>方法二：使用转义符</p>
<p>转义序列赋给字符变量时，必须用单引号把转义序列括起来。<br>例如，假设有下面一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> nerf = <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>转义序列</strong></th>
<th align="center"><strong>含义</strong></th>
<th align="center"><strong>转移符号</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\a</code></td>
<td align="center">警报</td>
<td align="center"><code>\v</code></td>
<td align="center">垂直制表符</td>
</tr>
<tr>
<td align="center"><code>\b</code></td>
<td align="center">退格</td>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
<tr>
<td align="center"><code>\f</code></td>
<td align="center">换页</td>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行</td>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车</td>
<td align="center"><code>\?</code></td>
<td align="center">问号</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">水平制表符</td>
<td align="center"><code>\xhhh</code></td>
<td align="center">十六进制值 (<code>hhh</code> 是1～3位十六进制数字，即每个h可表示 0~f中的一个数，)</td>
</tr>
<tr>
<td align="center"><code>\000</code></td>
<td align="center">八进制值 (oo 必须是有效的八进制数，即每个o可表示 0~7中的一个数，可<strong>省略数字前多余的0</strong>默认也为8进制，但为了防止出问题建议补全为3位)</td>
<td align="center"><code>\+任意符号</code></td>
<td align="center">输出对应符号</td>
</tr>
</tbody></table>
<p>对于<code>\0oo</code>和<code>\xhh</code>，等同于使用ASCII的十进制对应数据效果</p>
<p>何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用<code>&#39;\f&#39;</code>）和ASCII码（’<code>\014</code>‘）之间选择，请选择前者（即’<code>\f</code>‘）。这样的写法不仅更好记，而且可移植性更高。’\f’在不使用ASCII码的系统中，仍然有效。</p>
<h2 id="本章注意点：-1"><a href="#本章注意点：-1" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>需要每个值进行初始化，否则会造成错误</p>
<h3 id="getchar-函数的使用"><a href="#getchar-函数的使用" class="headerlink" title="getchar()函数的使用"></a><code>getchar()</code>函数的使用</h3><p>实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* platinum.c -- your weight in platinum */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> weight; <span class="comment">/* 你的体重 */</span></span><br><span class="line"><span class="type">float</span> value; <span class="comment">/* 相等重量的白金价值 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Are you worth your weight in platinum?\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s check it out.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter your weight in pounds: &quot;</span>);</span><br><span class="line"><span class="comment">/* 获取用户的输入 */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;weight);</span><br><span class="line"><span class="comment">/* 假设白金的价格是每盎司$1700 */</span></span><br><span class="line"><span class="comment">/* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*/</span></span><br><span class="line">value = <span class="number">1700.0</span> * weight * <span class="number">14.5833</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Your weight in platinum is worth $%.2f.\n&quot;</span>, value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are easily worth that! If platinum prices drop,\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;eat more to maintain your value.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出在<strong>屏幕上一闪而过</strong>，此时可使用，在程序中添加下面一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<p>但程序的输出依旧在<strong>屏幕上一闪而过</strong>，本例，需要调用两次<code>getchar()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getchar();</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>



<p><strong>分析</strong>：</p>
<p>​        在这种情况下，键入 <code>156</code> 并按下<code>Enter</code>键（发送一个换行符），然后<code>scanf()</code>读取键入的数字，第1个<code>getchar()</code>读取换行符，第2个<code>getchar()</code>让程序暂停，等待输入。</p>
<p><strong>原因：</strong></p>
<p>​        在你输入自己的数值后按下回车，<code>scanf</code>函数读取用户输入的体重值时，回车键会被当作输入的一部分，并被存储在输入缓冲区中。<code>scanf</code>函数会读取用户输入的数值，但回车键仍然留在缓冲区中，并且<code>getchar()</code>函数会获取回车键字符。</p>
<h3 id="声明变量的作用"><a href="#声明变量的作用" class="headerlink" title="声明变量的作用"></a>声明变量的作用</h3><p>​       声明为变量创建和标记存储空间</p>
<h3 id="数据类型应与打印类型一致"><a href="#数据类型应与打印类型一致" class="headerlink" title="数据类型应与打印类型一致"></a>数据类型应与打印类型一致</h3><p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* print2.c--更多printf()的特性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> un = <span class="number">3000000000</span>; <span class="comment">/* int为32位和short为16</span></span><br><span class="line"><span class="comment">位的系统 */</span></span><br><span class="line"><span class="type">short</span> end = <span class="number">200</span>;</span><br><span class="line"><span class="type">long</span> big = <span class="number">65537</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> verybig = <span class="number">12345678908642</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;un = %u and not %d\n&quot;</span>, un, un);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end = %hd and %d\n&quot;</span>, end, end);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big = %ld and not %hd\n&quot;</span>, big, big);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;verybig= %lld and not %ld\n&quot;</span>, verybig, verybig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">un = 3000000000 and not -1294967296</span><br><span class="line">end = 200 and 200</span><br><span class="line">big = 65537 and not 1</span><br><span class="line">verybig= 12345678908642 and not 1942899938</span><br></pre></td></tr></table></figure>

<p>该例表明，<strong>使用错误的转换说明</strong>会得到意想不到的结果。</p>
<p>原因：</p>
<p>情况一：例如第一行输出</p>
<p><strong>内存中的数位相同：不同数据类型中不同的位数所表示含义不一样，造成输出错误</strong>，也如：long long int 和double这两个数据类型</p>
<p>情况二：例如第三、四行输出</p>
<p><strong>不同的修饰符可以截断成不同类型值，printf（）从二进制的后往前读取位数</strong></p>
<p>把 65537 以二进制格式写成一个 32 位数是<code>00000000000000010000000000000001</code>。使用%hd， printf()只会查看后 16 位，所以显示的值是 1。与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。</p>
<p><strong>注意：</strong></p>
<p><strong>在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</strong></p>
<h3 id="断行输入"><a href="#断行输入" class="headerlink" title="断行输入"></a>断行输入</h3><p>​    只要不在引号内部或一个单词中间断行，就可以被分为两行</p>
<h3 id="sizeof-函数"><a href="#sizeof-函数" class="headerlink" title="sizeof()函数"></a><code>sizeof()</code>函数</h3><p>sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不<br>支持C99和C11的编译器可用%u或%lu代替%zd。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type int has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;type int has a size of %u bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;type int has a size of %lu bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>



<h3 id="输入的数据类型与设定数据类型不一致的情况"><a href="#输入的数据类型与设定数据类型不一致的情况" class="headerlink" title="输入的数据类型与设定数据类型不一致的情况"></a>输入的数据类型与设定数据类型不一致的情况</h3><p>把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>; <span class="comment">/* 用double类型的值初始化int类型的变量 */</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>; <span class="comment">/* 用double类型的值初始化float类型的变量 */</span></span><br></pre></td></tr></table></figure>

<p>第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了float类型前6位的精度。</p>
<hr>
<h1 id="字符串和格式化"><a href="#字符串和格式化" class="headerlink" title="字符串和格式化"></a><strong>字符串和格式化</strong></h1><h2 id="字符串与char数组"><a href="#字符串与char数组" class="headerlink" title="字符串与char数组"></a>字符串与<code>char</code>数组</h2><p><strong>字符串</strong>（character string）是一个或多个字符的序列，双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。</p>
<p>C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组（数组是同类型数据元素的有序序列）中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中</p>
<p>数组末尾位置的字符<code>\0</code> 。这是空字符（ null character），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符。C中的字符串一定以空字符结束，这意味着<strong>数组的容量必须至少比待存储字符串中的字符数多1</strong>。</p>
<h2 id="常量和C预处理器"><a href="#常量和C预处理器" class="headerlink" title="常量和C预处理器"></a>常量和C预处理器</h2><p>假设程序中的多处使用一个常量，有时需要改变它的值。毕竟，税率通常是浮动的。如果程序使用符号常量，则只需更改符号。常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。C语言还提供了一个更好的方案——<strong>C预处理器</strong>。只需在程序顶部添加下面一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAXRATE 0.015</span></span><br></pre></td></tr></table></figure>

<p>用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。</p>
<p>C头文件<code>limits.h</code>和<code>float.h</code>分别提供了与整数类型和浮点类型大小限制相关的详细信息。</p>
<p>如果在程序中包含limits.h头文件，就可编写下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Maximum int value on this system = %d\n&quot;</span>,INT_MAX);</span><br></pre></td></tr></table></figure>

<p><code>limits.h</code>中的一些明示常量</p>
<p><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="./65a012741520d.jpg"></p>
<p><code>float.h</code>中的一些明示常量</p>
<p><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="./65a01277e389b.jpg"></p>
<h2 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen()函数"></a><code>strlen()</code>函数</h2><p><code>strlen()</code>函数给出字符串中的字符长度</p>
<p>输出时可以使用<code>%zd</code>，在早期版本中换成<code>%u</code>或<code>%lu</code></p>
<h2 id="printf-的转化说明修饰符"><a href="#printf-的转化说明修饰符" class="headerlink" title="printf()的转化说明修饰符"></a>printf()的转化说明修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>表4.5描述了5种标记(-、+、空格、#和0)，可以不使用标记或使用多个标记(不会对输出结果造成影响)<br />-表示输出时采用左对齐。 <br />+这表示要输出的整数值为正数时，要在其前面显示加号（+），而负数仍然会显示减号（-）<br />空格：有符号值若为正，则在值前面显示前导空格(不显示任何符号); 若为负，则在值前面显示减号+标记覆盖一个空格<br />#:把结果转换为另一种形式。如果是<code>%o</code> 格式，则以<code>0</code>开始:如果是<code>%X</code>或格式，则以<code>0X</code>或<code>0X</code>开始:对于所有的浮点格式，#保证了即使后面没有任何数字，也打印一个小数点字符。对于<code>%g</code> 和<code>%G</code>格式，<code>#</code>防止结果后面的0被删除<br />通常情况下，整数会用空格来填充以满足指定的宽度，但使用<code>0</code>可以指示用零字符来填充。（用于右对齐的情况）<br />示例:”<code>%-10d</code>“</td>
</tr>
<tr>
<td>数字</td>
<td>最小字段宽度<br/>如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段<br />示例:”<code>%4d</code>“</td>
</tr>
<tr>
<td>.数字</td>
<td>对于<code>%e、%E 和%f</code> 转换，表示小数点右边数字的位数<br/>对于<code>%q和%G</code>转换，表示有效数字最大位数<br/>对于<code>%s</code>转换，表示待打印字符的最大数量<br/>对于整型转换，表示待打印数字的最小位数<br/>如有必要，使用前%0来达到这个位数<br/>只使用.表示其后跟随一个0，所以<code>%.f</code>和<code>%.0f</code>相同<br />示例:<code>&quot;%5.2f&quot;</code>打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字</td>
</tr>
<tr>
<td>h</td>
<td>和整型转换说明一起使用，表示<code>short int</code>或<code>unsigned short int</code>类型的值示例:<code>&quot;%hu&quot;、&quot;%hx&quot;、&quot;%6.4hd&quot;</code></td>
</tr>
<tr>
<td>hh</td>
<td>和整型转换说明一起使用，表示<code>signed char</code>或<code>unsigned char</code>类型的值<br />示例:“<code>%hhu</code>“、”<code>%hhx</code>“、”%<code>6.4hhd</code>“</td>
</tr>
<tr>
<td>j</td>
<td>和整型转换说明一起使用，表示intmax_t或uintmax_t类型的值。这些类型定义在stdint.h中<br />示例:”%jd”、”<code>%8jx</code>“</td>
</tr>
<tr>
<td>l</td>
<td>和整型转换说明一起使用，表示long int或unsignedlongint类型的值<br />示例:”&amp;ld”、”%8lu”</td>
</tr>
<tr>
<td>ll</td>
<td>和整型转换说明一起使用，表示long long int或unsigned long long int类型的值(C99)<br />示例:”<code>%lld</code>“、”<code>%81lu</code>“</td>
</tr>
<tr>
<td>L</td>
<td>和浮点转换说明一起使用，表示long double类型的值<br />示例:”<code>%Ld</code>“、”<code>%10.4Le</code>“</td>
</tr>
<tr>
<td>t</td>
<td>和整型转换说明一起使用，表示ptrdiff_t类型的值。ptrdiff_t是两个指针差值的类型(C99)<br />示例:”<code>%td</code>“、”<code>%12ti</code>“</td>
</tr>
<tr>
<td>z</td>
<td>和整型转换说明一起使用，表示size_t类型的值。size_t是sizeof返回的类型(C99)<br />示例:”<code>%zd</code>“、”<code>%12zd</code>“</td>
</tr>
</tbody></table>
<p>注：<code>printf()</code>中*的使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Weight = %*.*f\n&quot;</span>, width, precision, weight);</span><br></pre></td></tr></table></figure>

<p>可以代表此处的数值由后面的变量进行决定，如此处的字符宽度由<em>width</em>进行决定，保留小数位数由<em>precision</em>进行决定</p>
<h2 id="scanf（）"><a href="#scanf（）" class="headerlink" title="scanf（）"></a><code>scanf（）</code></h2><h3 id="读取字符串的规则"><a href="#读取字符串的规则" class="headerlink" title="读取字符串的规则"></a><strong>读取字符串的规则</strong></h3><p>​	<code>scanf()</code>在读取输入时就已完成把空字符放入字符串末尾这项工作.它在遇到<strong>第1个空白</strong>（空格、制表符或换行符）时就<strong>不再读取输</strong>入。</p>
<h3 id="的使用"><a href="#的使用" class="headerlink" title="&amp;的使用"></a><code>&amp;</code>的使用</h3><p>​	如果用<code>scanf()</code>读取基本变量类型的值，在变量名前加上一个&amp;；<br>​	如果用<code>scanf()</code>把字符串读入字符数组中，不要使用&amp;。</p>
<h3 id="scanf-的读取规则"><a href="#scanf-的读取规则" class="headerlink" title="scanf()的读取规则"></a>scanf()的读取规则</h3><p>每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取</p>
<p><code>scanf()</code>不断地读取和保存字符，直至遇到非数字字符。</p>
<p>然后<code>scanf()</code>把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。</p>
<p>如果第1个非空白字符是A而不是数字，<code>scanf()</code>将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用<code>%d</code>转换说明，<code>scanf()</code>就一直无法越过A读下一个字符。</p>
<h3 id="scanf-中的使用规则"><a href="#scanf-中的使用规则" class="headerlink" title="scanf()中的使用规则"></a><code>scanf()</code>中的使用规则</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span>, &amp;n);</span><br></pre></td></tr></table></figure>

<p>使用*可以使<code>scanf()</code>跳过前两个函数的赋值,在上述代码中跳过两个整数，把第3个整数拷贝给n</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>scanf()</code>函数返回读取数据的数量，所以如果读取对应类型则返回1，如果读取不成功则不返回0，在转换值之前出现问题，会返回一个特殊值EOF（通常被定义为-1）。</p>
<h3 id="读取小数值"><a href="#读取小数值" class="headerlink" title="读取小数值"></a>读取小数值</h3><p>由于输入的小数在c语言中默认作为double进行处理，所以对应的数据类型需要使用<code>&amp;lf</code>，否则会出错。</p>
<h2 id="本章注意点：-2"><a href="#本章注意点：-2" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<h3 id="X-与-X-的区别"><a href="#X-与-X-的区别" class="headerlink" title="&quot;X&quot;与&#39;X&#39;的区别"></a><code>&quot;X&quot;</code>与<code>&#39;X&#39;</code>的区别</h3><p>区别之一在于’x’是基本类型（char），而”x”是派生类型（char数组）</p>
<p>区别之二是”x”实际上由两个字符组成：’x’和空字符\0</p>
<h3 id="sizeof-何时使用了圆括号"><a href="#sizeof-何时使用了圆括号" class="headerlink" title="sizeof 何时使用了圆括号"></a><code>sizeof</code> 何时使用了圆括号</h3><p>圆括号的使用时机否取决于运算对象是类型还是特定量。运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此，还是<strong>建议所有情况下都使用圆括号</strong>，如<code>sizeof(6.28)</code></p>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><code>const</code>限定符</h3><p>C90标准新增了const关键字，用于限定一个变量为只读.这使得成为一个<strong>只读值</strong>，可以在计算中使用， 可以打印， 但是不能更改值。</p>
<hr>
<h1 id="运算符、表达式和语句"><a href="#运算符、表达式和语句" class="headerlink" title="运算符、表达式和语句"></a><strong>运算符、表达式和语句</strong></h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><code>=、+、-、*、/</code></p>
<p>注：C 没有指数运算符。不过，C 的标准数学库提供了一个<code>pow()</code>函数用于指数运算。例如，<code>pow(3.5, 2.2)</code>返回3.5的2.2次幂。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>&#x3D;并不意味着“相等”</strong>，而是一个赋值运算符。赋值行为从右往左进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bmw = <span class="number">2002</span>;</span><br></pre></td></tr></table></figure>

<p>读作“把值2002赋给变量bmw”</p>
<h3 id="求模运算符"><a href="#求模运算符" class="headerlink" title="求模运算符-%"></a>求模运算符-<code>%</code></h3><p>用于整数运算，求模运算符给出其左侧整数除以右侧整数的余数</p>
<h3 id="一元运算符与二元运算符"><a href="#一元运算符与二元运算符" class="headerlink" title="一元运算符与二元运算符"></a>一元运算符与二元运算符</h3><p>一元运算符：只有一个运算对象，如：-16</p>
<p>二元运算符：有两个运算对象，如：23-14</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p><strong>递增运算符：<code>++</code></strong></p>
<p>递增运算符执行简单的任务，将其运算对象递增1。</p>
<p><strong>递减运算符：<code>--</code></strong></p>
<p><strong><code>++</code>的前缀形式和后缀形式的区别</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>，</span><br><span class="line"><span class="type">int</span> b， c；</span><br><span class="line">b = a++</span><br><span class="line">c = ++a</span><br></pre></td></tr></table></figure>

<p>在最后的输出结果中会发现，b&#x3D;1而c&#x3D;3；这因为后缀在运算过程中在a使用完成后再进行递增，而前缀先进行递增而后进行计算。</p>
<p><strong>结合优先级</strong></p>
<p>只有圆括号的优先级比递增递减运算符高。因此， <code>x*y++</code> 表示的是<code>(x)*(y++)</code> ， 而不是<code>(x+y)++</code>。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合<code>x*y</code>本身不是可修改的左值。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于或等于</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
</tbody></table>
<p>注：</p>
<p>可以通过关系运算符判断字符，但不能判断字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">a = (ch != <span class="string">&#x27;s&#x27;</span>)<span class="comment">//根据ASCII区分大小写</span></span><br></pre></td></tr></table></figure>



<p>通过关系运算符可以比较浮点数，但最好使用<code>&lt;</code>、<code>&gt;</code>进行判断，因为浮点数在储存时会造成舍入误差造成原本相等的两数不相等。可使用fabs()函数-返回绝对值来进行比较浮点数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span><span class="comment">//fabs()函数所需的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">double</span> response;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;What is the value of pi?\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)<span class="comment">//浮点数两数相等所自定义的允许误差</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Close enough!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式</p>
<p>逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值。(但逗号运算符无法在计算中插入使用以改变计算顺序，如：<code>b = 3 * 5 - 10, * 2 + 15</code>是错误的写法)</p>
<p>假设在写数字时不小心输入了逗号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">houseprice = <span class="number">249</span>,<span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<p>这不是语法错误，C 编译器会将其解释为一个逗号表达式，即<code>houseprice = 249</code> 是逗号左侧的子表达式，<code>500;</code> 是右侧的子表达式。</p>
<p><strong>逗号也可用作分隔符。</strong></p>
<p>逗号运算符会依次计算每个表达式，并返回最后一个表达式的值作为整个逗号运算符表达式的值。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
</tbody></table>
<h4 id="备选拼写：iso646-h头文件"><a href="#备选拼写：iso646-h头文件" class="headerlink" title="备选拼写：iso646.h头文件"></a><strong>备选拼写：iso646.h头文件</strong></h4><p>C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用<code>and代替&amp;&amp;、or代替||、not代替!</code>。</p>
<h4 id="判断范围问题"><a href="#判断范围问题" class="headerlink" title="判断范围问题"></a><strong>判断范围问题</strong></h4><p>&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90～100的范围内，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (range &gt;= <span class="number">90</span> &amp;&amp; range &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good show!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>千万不要模仿数学上的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">90</span> &lt;= range &lt;= <span class="number">100</span>) <span class="comment">// 千万不要这样写！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good show!\n&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：</span></span><br><span class="line"><span class="comment">(90 &lt;= range) &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>子表达式90 &lt;&#x3D; range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，**在范围测试中要使用&amp;&amp;**。</p>
<h3 id="条件运算符——"><a href="#条件运算符——" class="headerlink" title="条件运算符——?:"></a>条件运算符——<code>?:</code></h3><p>以下述代码为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure>

<p>上述语句翻译为：如果a大于b，那么将max设置为a；否则，设置为b。</p>
<h3 id="运算符-查找地址"><a href="#运算符-查找地址" class="headerlink" title="&amp;运算符-查找地址"></a><code>&amp;</code>运算符-查找地址</h3><p>一元&amp;运算符给出变量的存储地址。PC地址通常用十六进制形式表示</p>
<p><code>%p</code>是输出地址的转换说明</p>
<h3 id="间接运算符"><a href="#间接运算符" class="headerlink" title="间接运算符-*"></a>间接运算符-<code>*</code></h3><p>间接运算符<code>*</code> ，该运算符有时也称为解引用运算符。<code>*</code>用于给出储存在指针指向地址上的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;bah;</span><br><span class="line">val = *ptr; <span class="comment">// 找出ptr指向的值</span></span><br></pre></td></tr></table></figure>

<p>以上代码相当于如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = bah;</span><br></pre></td></tr></table></figure>



<p><strong>不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。</strong></p>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合律</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>后缀运算符：[]   ()   ·   -&gt;   ++   –(类型名称){列表}</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>一元运算符：++   –   !   ~   +   -   *   &amp;   sizeof_Alignof</td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td>类型转换运算符：(类型名称)</td>
<td>从右到左</td>
</tr>
<tr>
<td>4</td>
<td>乘除法运算符：*   &#x2F;   %</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>加减法运算符：+   -</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>移位运算符：&lt;&lt;   &gt;&gt;</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>关系运算符：&lt;&lt;&#x3D;   &gt;&gt;&#x3D;</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>相等运算符：&#x3D;&#x3D;   !&#x3D;</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>位运算符 AND：&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td>位运算符 XOR：^</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td>位运算符 OR：|</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td>逻辑运算符 AND：&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td>逻辑运算符 OR：||</td>
<td>从左到右</td>
</tr>
<tr>
<td>14</td>
<td>条件运算符：?:</td>
<td>从右到左</td>
</tr>
<tr>
<td>15</td>
<td>赋值运算符：    &#x3D;     +&#x3D;     -&#x3D;    *&#x3D;    &#x2F;&#x3D;    %&#x3D;    &amp;&#x3D;    ^&#x3D;    |&#x3D;     &lt;&lt;&#x3D;    &gt;&gt;&#x3D;</td>
<td>从右到左</td>
</tr>
<tr>
<td>16</td>
<td>逗号运算符：，</td>
<td>从左到右</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total += *start++;</span><br></pre></td></tr></table></figure>

<p>一元运算<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code></p>
<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>在语句和表达式中，如果使用混合类型，C会采用一套规则进行自动类型转换。</p>
<p><strong>基本的类型转换规则</strong></p>
<ol>
<li>当类型转换出现在表达式时，无论是<code>unsigned</code>还是<code>signed</code>的<code>char</code>和<code>short</code>都会被自动转换成<code>int</code>，如有必要会被转换成<code>unsigned int</code></li>
<li>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。</li>
<li>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级</li>
<li>当作为函数参数传递时，char和short被转换成int，float被转换成double。</li>
</ol>
<p>类型升级通常都不会有什么问题，但是类型降级会导致较低类型可能放不下整个数字。</p>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p>有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mice = <span class="number">1.6</span> + <span class="number">1.7</span>;</span><br><span class="line">mice = (<span class="type">int</span>)<span class="number">1.6</span> + (<span class="type">int</span>)<span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>

<p>第1行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配<code>int</code> 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。</p>
<h2 id="本章注意点：-3"><a href="#本章注意点：-3" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<p>许多其他语言都会回避该程序中的<strong>三重赋值</strong>，但是C完全没问题。赋值的顺序是从右往左</p>
<p>在C语言中，除法操作默认会执行整数除法，即<strong>如果操作数都是整数，结果将会是整数，</strong>而不是浮点数.整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果.</p>
<p>在定义函数时，需要在最上面进行<strong>函数原型声明</strong></p>
<p>未进行函数的声明或未指定参数类型的情况下，会导致参数升级为不正确的数据类型，在函数调用中显式使用强制类型转换，可以修复这个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pound ((<span class="type">int</span>)f); <span class="comment">// 把f强制类型转换为正确的类型</span></span><br></pre></td></tr></table></figure>

<p>（<strong>所以最好在开头进行函数的原型声明</strong>）</p>
<hr>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>使用格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断条件)<span class="comment">//此处不加；</span></span><br><span class="line">    条件成立的执行语句；</span><br></pre></td></tr></table></figure>

<p><code>while</code>通过括号的数值最后是否为0来进行判断一个真假，若为0则为假，若不为0则为真（但c语言中0为假，而1为真）。</p>
<p><code>while()</code>后加<code>;</code>表示执行空语句</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>使用格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(语句a;语句b;语句c)</span><br></pre></td></tr></table></figure>

<p>第1个表达式是初始化，只会在<code>for</code>循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假，循环结束。第3个表达式执行更新，在每次循环结束时执行。</p>
<p>注：在for循环中，可以省略一个或多个语句，但分号不能省略。</p>
<p><strong>在<code>for</code>语句的<code>（）</code>所<em>定义的变量</em>是局部变量，只在此for循环内的语句中有效</strong></p>
<h2 id="do…-while循环"><a href="#do…-while循环" class="headerlink" title="do….while循环"></a>do….while循环</h2><p>使用格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句<span class="comment">//可为单一语句或者复合语句</span></span><br><span class="line"><span class="keyword">while</span> ( 判断条件 )；<span class="comment">//此处一定要加分号</span></span><br></pre></td></tr></table></figure>

<p>do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次</p>
<h2 id="本章注意点：-4"><a href="#本章注意点：-4" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<h3 id="逻辑判断符号与赋值符号不要混淆"><a href="#逻辑判断符号与赋值符号不要混淆" class="headerlink" title="逻辑判断符号与赋值符号不要混淆"></a>逻辑判断符号与赋值符号不要混淆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(a == <span class="number">1</span>);<span class="comment">//语句一</span></span><br><span class="line"><span class="keyword">while</span>(a = <span class="number">1</span>);<span class="comment">//语句二</span></span><br></pre></td></tr></table></figure>

<p>语句一中为判断a是否等于1</p>
<p>语句二为将1赋值给a，最后将1的参数给while最后造成语句二的循环不断进行</p>
<hr>
<h1 id="分支与跳转"><a href="#分支与跳转" class="headerlink" title="分支与跳转"></a><strong>分支与跳转</strong></h1><h2 id="if、else、else-if语句"><a href="#if、else、else-if语句" class="headerlink" title="if、else、else if语句"></a>if、else、else if语句</h2><p>使用格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断语句)<span class="comment">//此处不加分号</span></span><br><span class="line">  执行语句；<span class="comment">//可为单语句或多语句</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">  执行语句；<span class="comment">//可为单语句或多语句</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  执行语句；<span class="comment">//可为单语句或多语句</span></span><br></pre></td></tr></table></figure>

<p><strong>else与if配对原则</strong>：else与离它最近的if匹配，除非最近的if被花括号括起来</p>
<h3 id="数值的范围判断问题"><a href="#数值的范围判断问题" class="headerlink" title="数值的范围判断问题"></a>数值的范围判断问题</h3><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h2><p>​	continue 语句让程序跳过continue 语句后在循环内的代码，让程序重新进入循环。</p>
<p>​	continue还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h2><p>程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。</p>
<h2 id="多重选择：switch和break"><a href="#多重选择：switch和break" class="headerlink" title="多重选择：switch和break"></a>多重选择：<code>switch</code>和<code>break</code></h2><p>使用格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (整数值（包括<span class="type">char</span>类型）。)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 值:<span class="comment">//表达式中只包含整型常量</span></span><br><span class="line">	执行语句</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 值:<span class="comment">//表达式中只包含整型常量</span></span><br><span class="line">	执行语句</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>switch</code>只处理了第1个字符</p>
<p><code>break</code>语句让程序离开<code>switch</code>语句，跳至<code>switch</code>语句后面的下一条语句。如果没有<code>break</code>语句，就会从匹配标签开始执行到<code>switch</code>末尾</p>
<p><code>break</code> 语句可用于循环和<code>switch</code> 语句中， 但是<code>continue</code>只能用于循环中。</p>
<h3 id="case多重标签"><a href="#case多重标签" class="headerlink" title="case多重标签"></a>case多重标签</h3><p>可以在switch语句中使用多重case标签</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: a_ct++;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: e_ct++;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设如果<code>ch</code>是字母a，switch语句会定位到标签为<code>case &#39;a&#39;</code> :的位置。由于该标签没有关联<code>break</code>语句，所以程序流直接执行下一条语<br>句，即a_ct++;。如果 <code>ch</code>是字母A，程序流会直接定位到<code>case &#39;A&#39;</code> :。本质上，两个标签都指的是相同的语句。</p>
<h2 id="getchar-和putchar-函数"><a href="#getchar-和putchar-函数" class="headerlink" title="getchar()和putchar()函数"></a><code>getchar()</code>和<code>putchar()</code>函数</h2><p><strong>getchar()函数不带任何参数</strong>，它从输入队列中返回下一个字符。<br>例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);<span class="comment">//与上一句等效</span></span><br></pre></td></tr></table></figure>

<p>putchar()函数<strong>打印它的参数</strong>。例如，下面的语句把之前赋给ch的<br>值作为字符打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);<span class="comment">//于上一句等效</span></span><br></pre></td></tr></table></figure>

<p>由于这些函数只处理字符， 所以它们比更通用的<code>scanf()</code> 和<code>printf()</code>函数更快、更简洁。而且，注意 <code>getchar()</code>和 <code>putchar()</code>不需要转换说明，因为它们只处理字符。这两个函数通常定义在 <code>stdio.h</code>头文件</p>
<h2 id="ctype-h库"><a href="#ctype-h库" class="headerlink" title="ctype.h库"></a><code>ctype.h</code>库</h2><p>​	C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数， 如果该字符属于某特殊的类别， 就返回一个非零值（真）；否则，返回0（假）。</p>
<p><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="./65a0127b5d47f.jpg"></p>
<p><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="./65a01277e389b.jpg"></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h1><p>数组（array）是按顺序储存的一系列类型相同的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> debts[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>声明<code>debts</code>是一个内含20个元素的数组，每个元素都可以储存<code>float</code> 类型的值。数组的第1 个元素是<code>debts[0]</code> ， 第2 个元素是<code>debts[1]</code>，以此类推，直到<code>debts[19]</code>。</p>
<p><strong>注意，数组元素的编号从0开始，不是从1开始。</strong></p>
<p>字符组与字符串的差别</p>
<p>字符串最末尾有由<strong>空字符</strong><code>\0</code>，而字符组没有。如果<code>char</code>类型的数组末尾包含一个表示字符串末尾的空字符\0，则该<br>数组中的内容就构成了一个字符串</p>
<h2 id="指定数组大小"><a href="#指定数组大小" class="headerlink" title="指定数组大小"></a>指定数组大小</h2><p>在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>;</span><br><span class="line"><span class="type">float</span> a1[<span class="number">5</span>]; <span class="comment">// 可以</span></span><br><span class="line"><span class="type">float</span> a2[<span class="number">5</span>*<span class="number">2</span> + <span class="number">1</span>]; <span class="comment">//可以</span></span><br><span class="line"><span class="type">float</span> a3[<span class="keyword">sizeof</span>(<span class="type">int</span>) + <span class="number">1</span>]; <span class="comment">//可以</span></span><br><span class="line"><span class="type">float</span> a4[<span class="number">-4</span>]; <span class="comment">// 不可以，数组大小必须大于0</span></span><br><span class="line"><span class="type">float</span> a5[<span class="number">0</span>]; <span class="comment">// 不可以，数组大小必须大于0</span></span><br><span class="line"><span class="type">float</span> a6[<span class="number">2.5</span>]; <span class="comment">// 不可以，数组大小必须是整数</span></span><br><span class="line"><span class="type">float</span> a7[(<span class="type">int</span>)<span class="number">2.5</span>]; <span class="comment">// 可以，已被强制转换为整型常量</span></span><br><span class="line"><span class="type">float</span> a8[n]; <span class="comment">// C99之前不允许</span></span><br><span class="line"><span class="type">float</span> a9[m]; <span class="comment">// C99之前不允许</span></span><br></pre></td></tr></table></figure>





<h2 id="未指定数组大小"><a href="#未指定数组大小" class="headerlink" title="未指定数组大小"></a>未指定数组大小</h2><p>编译器会把数组的大小设置为足够装得下初始化的值。</p>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> powers[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>&#125;; <span class="comment">/* 从ANSI C开始支持这种初始化 */</span></span><br></pre></td></tr></table></figure>

<p>如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（<code>powers[0]</code>），以此类推</p>
<p>除在声明时可使用<code>&#123;&#125;</code>对数组进行赋值，其他时候只能用<code>变量[序号] =</code> 对数组进行逐一赋值</p>
<p>注：使用const声明数组，可把数组设置为只读</p>
<h2 id="声明数组形参"><a href="#声明数组形参" class="headerlink" title="声明数组形参"></a>声明数组形参</h2><p>​	因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样。也就是说，ar是指向int的指针。由于函数<br>原型可以省略参数名，所以下面4种原型都是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [], <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>但是，在函数定义中不能省略参数名。</strong></p>
<h2 id="指定初始化器（适用于C99）"><a href="#指定初始化器（适用于C99）" class="headerlink" title="指定初始化器（适用于C99）"></a>指定初始化器（适用于C99）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">6</span>] = &#123;[<span class="number">5</span>] = <span class="number">212</span>&#125;; <span class="comment">// 把arr[5]初始化为212</span></span><br></pre></td></tr></table></figure>

<p>而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素</p>
<p>指定初始化的一些特性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, [<span class="number">4</span>] = <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, [<span class="number">1</span>] = <span class="number">29</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。如该例中的初始化列表中的片段：[4] &#x3D;<br>31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。</li>
<li>第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。。例如，程序清单10.5中，初始化列表开始<br>时把days[1]初始化为28，但是days[1]又被后面的指定初始化[1] &#x3D;29初始化为29。</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量[主数组个数][每个主数组所需的个数]</span><br></pre></td></tr></table></figure>



<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> rain[<span class="number">5</span>][<span class="number">12</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">4.3</span>,<span class="number">4.3</span>,<span class="number">4.3</span>,<span class="number">3.0</span>,<span class="number">2.0</span>,<span class="number">1.2</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">2.4</span>,<span class="number">3.5</span>,<span class="number">6.6</span>&#125;,</span><br><span class="line">&#123;<span class="number">8.5</span>,<span class="number">8.2</span>,<span class="number">1.2</span>,<span class="number">1.6</span>,<span class="number">2.4</span>,<span class="number">0.0</span>,<span class="number">5.2</span>,<span class="number">0.9</span>,<span class="number">0.3</span>,<span class="number">0.9</span>,<span class="number">1.4</span>,<span class="number">7.3</span>&#125;,</span><br><span class="line">&#123;<span class="number">9.1</span>,<span class="number">8.5</span>,<span class="number">6.7</span>,<span class="number">4.3</span>,<span class="number">2.1</span>,<span class="number">0.8</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">1.1</span>,<span class="number">2.3</span>,<span class="number">6.1</span>,<span class="number">8.4</span>&#125;,</span><br><span class="line">&#123;<span class="number">7.2</span>,<span class="number">9.9</span>,<span class="number">8.4</span>,<span class="number">3.3</span>,<span class="number">1.2</span>,<span class="number">0.8</span>,<span class="number">0.4</span>,<span class="number">0.0</span>,<span class="number">0.6</span>,<span class="number">1.7</span>,<span class="number">4.3</span>,<span class="number">6.2</span>&#125;,</span><br><span class="line">&#123;<span class="number">7.6</span>,<span class="number">5.6</span>,<span class="number">3.8</span>,<span class="number">2.8</span>,<span class="number">3.8</span>,<span class="number">0.2</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.3</span>,<span class="number">2.6</span>,<span class="number">5.2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。</p>
<h2 id="其他多维数组"><a href="#其他多维数组" class="headerlink" title="其他多维数组"></a>其他多维数组</h2><p>二维数组的相关内容都适用于三维数组或更多维的数组。</p>
<h2 id="const修饰数组"><a href="#const修饰数组" class="headerlink" title="const修饰数组"></a><code>const</code>修饰数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息。</p>
<p>如果此时声明指向这个<code>const</code>数组，<strong>此时指针也必须用<code>const</code>修饰</strong>，且不能修改解引用指针的值，否则都将报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pd = <span class="number">29.89</span>; <span class="comment">// 不允许</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.22</span>; <span class="comment">//不允许</span></span><br></pre></td></tr></table></figure>

<p>但可以进行指针加法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd++; <span class="comment">/* 让pd指向rates[1] -- 没问题 */</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>把<code>const</code>数据或<code>非const</code>数据的地址初始化为指向<code>const</code>的指针或为其赋值是合法的，此时不能修改解引用指针的值</p>
<h2 id="变长数组（适用C99）"><a href="#变长数组（适用C99）" class="headerlink" title="变长数组（适用C99）"></a>变长数组（适用C99）</h2><p><strong>在创建数组时，可以使用变量指定数组的维度。</strong></p>
<p>注：变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：</p>
<h3 id="声明一个带二维变长数组参数的函数"><a href="#声明一个带二维变长数组参数的函数" class="headerlink" title="声明一个带二维变长数组参数的函数"></a>声明一个带二维变长数组参数的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> ar[rows][cols])</span>;</span><br></pre></td></tr></table></figure>

<p>注：前两个形参（rows和cols）用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声明这两个形参。</p>
<p>以下为错误写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> ar[rows][cols], <span class="type">int</span> rows, <span class="type">int</span> cols)</span>;</span><br></pre></td></tr></table></figure>

<p>变形</p>
<p>C99&#x2F;C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> ar[*][*])</span>;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong></p>
<ul>
<li>在函数定义的形参列表中声明的变长数组并未实际创建数组。</li>
<li>和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。</li>
</ul>
<h2 id="复合字面量（使用C99）"><a href="#复合字面量（使用C99）" class="headerlink" title="复合字面量（使用C99）"></a>复合字面量（使用C99）</h2><p><strong>字面量是除符号常量外的常量</strong>。例如，5是int类型字面量， 81.3是double类型的字面量</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>下面的复合字面量创建了一个和diva数组相同的<strong>匿名数组</strong>，也有两个int类型的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125; <span class="comment">// 复合字面量</span></span><br></pre></td></tr></table></figure>

<p><strong>其中<code>int [2]</code>即是复合字面量的类型名。</strong></p>
<p>初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> [])&#123;<span class="number">50</span>, <span class="number">20</span>, <span class="number">90</span>&#125; <span class="comment">// 内含3个元素的复合字面量</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它</p>
<p>用法一：使用指针记录地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pt1;</span><br><span class="line">pt1 = (<span class="type">int</span> [<span class="number">2</span>]) &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>用法二：把复合字面量作为实际参数传递给带有匹配形式参数的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> total3;</span><br><span class="line">total3 = sum((<span class="type">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>





<h2 id="本章注意点：-5"><a href="#本章注意点：-5" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<h3 id="数组名是数组首元素的地址。"><a href="#数组名是数组首元素的地址。" class="headerlink" title="数组名是数组首元素的地址。"></a>数组名是数组首元素的地址。</h3><p>如果flizny是一个数组，下面的语句成立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure>



<h3 id="多维数组的双重间接性质"><a href="#多维数组的双重间接性质" class="headerlink" title="多维数组的双重间接性质"></a>多维数组的双重间接性质</h3><p>假设有下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">/* 内含int数组的数组 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后数组名zippo是该数组首元素的地址。</li>
<li>1.因为<code>zippo</code>是数组首元素的地址，所以<code>zippo</code>的值和<code>&amp;zippo[0]</code>的值相同。而<code>zippo[0]</code>本身是一个内含两个整数的数组，所以<code>zippo[0]</code><br>的值和它首元素（一个整数）的地址（即<code>&amp;zippo[0][0]</code>的值）相同。</li>
<li>简而言之，<code>zippo[0]</code>是一个占用一个int大小对象的地址，而<code>zippo</code>是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以<code>zippo</code>、<code>zippo[0]</code>、<code>zippo[0][0]</code>的值相同。</li>
<li>2.给指针或地址加1，其值会增加对应类型大小的数值。在这方面，<code>zippo</code>和<code>zippo[0]</code>不同，因为<code>zippo</code>指向的对象占用了两个<code>int</code>大小，而<code>zippo[0]</code> 指向的对象只占用一个int 大小。因此， <code>zippo + 1</code> 和<code>zippo[0] + 1</code>的值不同。</li>
<li>3.<code>**zippo</code>与<code>*&amp;zippo[0][0]</code>等价，这相当于<code>zippo[0][0]</code></li>
<li>4.解引用一个指针（在指针前使用<code>*</code>运算符）或在数组名后使用带下标的<code>[]</code>运算符，得到引用对象代表的值。其中解引用主数组的结果就是次数组，即 <code>*zippo == zippo[0]</code>成立。</li>
<li>总结：<strong>将数组理解成数组的数组。</strong>因占用地址为首元素的数据类型大小及其个数，<code>zippo[0]</code>是一个占用一个int大小对象的地址，而<code>zippo</code>是一个占用两个int大小对象的地址。由于主数组为<code>zippo[]</code>的合集，故<code>zippo + 1</code> 和<code>zippo[0] + 1</code>的值不同。即<code>zippo + 1 == zippo[1]</code>成立，<code>zippo[0]+1 == zippo[0][1]</code>。解引用主数组形参就是得到主数组的第一个值，也就是次数组<code>zippo[0]</code></li>
</ul>
<h3 id="数组中sizeof-的使用"><a href="#数组中sizeof-的使用" class="headerlink" title="数组中sizeof()的使用"></a>数组中<code>sizeof()</code>的使用</h3><p>在数组中<code>sizeof()</code>被视为整型常量，可以用于声明数组内的数目，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br></pre></td></tr></table></figure>









<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h1><p>指针（pointer）是一个值为内存地址的变量（或数据对象）。</p>
<h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><h3 id="1-声明变量的指针"><a href="#1-声明变量的指针" class="headerlink" title="1.声明变量的指针"></a>1.声明变量的指针</h3><p>因声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。</p>
<p>以下为声明指针的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi; <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="type">char</span> * pc; <span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="type">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure>

<p>类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。</p>
<h3 id="2-声明多维数组的指针"><a href="#2-声明多维数组的指针" class="headerlink" title="2.声明多维数组的指针"></a>2.声明多维数组的指针</h3><p>多维数组的指针会有不同大小的地址，因此多维数组的指针在声明是必须指向一个内含对应个数和对应文件类型的数组</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (* pz)[<span class="number">2</span>]; <span class="comment">// pz指向一个内含两个int类型值的数组</span></span><br></pre></td></tr></table></figure>

<p>前面有圆括号的版本，<code>*</code>先与<code>pz</code>结合，因此声明的是一个指向数组（内含两个<code>int</code>类型的值）的指针。</p>
<p>区别于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pax[<span class="number">2</span>]; <span class="comment">// pax是一个内含两个指针元素的数组，每个元素都指向int的指针</span></span><br></pre></td></tr></table></figure>

<p>由于[]优先级高，先与<code>pax</code>结合，所以<code>pax</code>成为一个内含两个元素的数组。然后<code>*</code>表示<code>pax</code>数组内含两个指针。最后，<code>int</code>表示<code>pax</code>数组中的指针都指向<code>int</code>类型的值。因此，这行代码声明了两个指向<code>int</code>的指针</p>
<h3 id="3-声明函数指针"><a href="#3-声明函数指针" class="headerlink" title="3.声明函数指针"></a>3.声明函数指针</h3><p>方式一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数返回类型 (*指针名)(函数列表); <span class="comment">// 声明函数指针</span></span><br><span class="line"></span><br><span class="line">指针名 = 函数名; <span class="comment">// 将add函数的地址赋值给函数指针（函数名实际上是函数地址）</span></span><br></pre></td></tr></table></figure>

<p>方式二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数返回类型 (*指针名)(函数列表) = &amp;函数名; <span class="comment">// 声明并初始化函数指针</span></span><br></pre></td></tr></table></figure>



<h3 id="4-声明指向指针的指针"><a href="#4-声明指向指针的指针" class="headerlink" title="4.声明指向指针的指针"></a>4.声明指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向的指针数据类型** 指针名 = &amp;被指向的指针</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = &amp;num;        <span class="comment">// 指向int类型的指针</span></span><br><span class="line"><span class="type">int</span>** ptrToPtr = &amp;ptr;  <span class="comment">// 指向int*类型的指针</span></span><br></pre></td></tr></table></figure>



<h2 id="8种基本用法"><a href="#8种基本用法" class="headerlink" title="8种基本用法"></a>8种基本用法</h2><ol>
<li>赋值</li>
<li>解引用</li>
<li>取址</li>
<li>指针与整数相加</li>
<li>递增指针</li>
<li>指针减去一个整数</li>
<li>递减指针</li>
<li>指针求差</li>
</ol>
<p>注：</p>
<ul>
<li><p>关系运算符可以比较两个指针的值</p>
</li>
<li><p>可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。</p>
</li>
<li><p>指针和指针不能直接相加</p>
</li>
</ul>
<h2 id="指针运算与递增递减操作"><a href="#指针运算与递增递减操作" class="headerlink" title="指针运算与递增递减操作"></a>指针运算与递增递减操作</h2><p>特别注意，只有<strong>指针变量</strong>可以进行递增递减操作，如数组名，字符串常量等<strong>指针常量</strong>等不能进行递增递减操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;NO&quot;</span></span><br><span class="line"><span class="type">char</span> * pi = <span class="string">&quot;YES&quot;</span></span><br><span class="line">++pi; <span class="comment">//正确</span></span><br><span class="line">++a;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>






<h2 id="解引用未初始化的指针"><a href="#解引用未初始化的指针" class="headerlink" title="解引用未初始化的指针"></a>解引用未初始化的指针</h2><p>切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。</p>
<p>指针未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在C语言中，函数指针允许我们将函数的地址存储在指针变量中，并通过该指针变量来调用函数。其调用格式与函数相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针名（参数列表）;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*operation)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明函数指针</span></span><br><span class="line"></span><br><span class="line">    operation = add; <span class="comment">// 将add函数的地址赋值给函数指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addition: %d\n&quot;</span>, operation(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 调用add函数</span></span><br><span class="line"></span><br><span class="line">    operation = subtract; <span class="comment">// 将subtract函数的地址赋值给函数指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Subtraction: %d\n&quot;</span>, operation(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 调用subtract函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指针的兼容性"><a href="#指针的兼容性" class="headerlink" title="指针的兼容性"></a>指针的兼容性</h2><p>指针之间的赋值比数值类型之间的赋值要严格。两个类型的指针不能相互赋值。</p>
<h2 id="本章注意点：-6"><a href="#本章注意点：-6" class="headerlink" title="本章注意点："></a>本章注意点：</h2><hr>
<h3 id="指针加法"><a href="#指针加法" class="headerlink" title="指针加法"></a>指针加法</h3><p>在C中，指针加1指的是增加一个存储单元，指针加1的操作并不是简单地将指针的值增加1，而是将指针向后移动一个存储单元的大小。。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h1><h2 id="函数的声明、定义与引用"><a href="#函数的声明、定义与引用" class="headerlink" title="函数的声明、定义与引用"></a>函数的声明、定义与引用</h2><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数定义的数据返回类型 函数名(参数列表);</span><br></pre></td></tr></table></figure>

<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据返回类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> 返回变量;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表)</span><br></pre></td></tr></table></figure>



<h2 id="函数参数的传递"><a href="#函数参数的传递" class="headerlink" title="函数参数的传递"></a>函数参数的传递</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><p>编写一个处理基本类型（如，<code>int</code>）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针</p>
<p>这意味着在C语言中，函数参数传递是按值传递的，这意味着在函数调用时，实参的值会被复制到形参中。实参不会因为函数中的语句而被修改，但可利用指针，修改实参的内存地址所对应的值来进行修改实参。</p>
<p>例：交换两个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span>* u, <span class="type">int</span>* v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span>* u, <span class="type">int</span>* v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *u;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">u的值是&amp;x，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：</span></span><br><span class="line"><span class="comment">	temp = u;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    *u = *v;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这条语句相当于：</span></span><br><span class="line"><span class="comment">	x = y;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    *v = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><p>​	对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h1><h2 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h2><p>​	用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的<code>\0</code>字符， 都作为字符串储存在内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> m1[<span class="number">40</span>] = <span class="string">&quot;Limit yourself to one line&#x27;s worth.&quot;</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> m1[<span class="number">40</span>] = &#123; <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\&quot;, &#x27;</span>s<span class="number">&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>



<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;HeyJWEI&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="char类型数组"><a href="#char类型数组" class="headerlink" title="char类型数组"></a><code>char</code>类型数组</h3><p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;HEYJW&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指向char的指针"><a href="#指向char的指针" class="headerlink" title="指向char的指针"></a>指向char的指针</h3><p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * pi = <span class="string">&quot;HeyJWEI&quot;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>注</strong>：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）</p>
<p><strong>字符串串联规则</strong>：从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔（包括换行），C会将其视为串联起来的字符串字面量。</p>
<h3 id="数组形式和指针形式的区别"><a href="#数组形式和指针形式的区别" class="headerlink" title="数组形式和指针形式的区别"></a>数组形式和指针形式的区别</h3><p><strong>数组</strong></p>
<p>​	数组形式在计算机的内存中分配为一个内含 字母数+1 个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符’\0’），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在<strong>静态存储区</strong>（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将<strong>字符串拷贝到数组中</strong>。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在数组中的字符串。</p>
<p><strong>即以下流程</strong>	</p>
<ol>
<li><p>字符串的内存分配</p>
</li>
<li><p>字符串的初始化</p>
</li>
<li><p>字符串的存储位置</p>
</li>
<li><p>字符串的拷贝</p>
<p>注：此时编译器便把<strong>数组名识别为该数组首元素地址</strong>（<code>&amp;数组名[0]</code>）的别名。这里关键要理解，在数组形式中，<strong>数组名</strong>是地址常<br>量。<strong>不能更改ar1，如果改变了ar1，则意味着改变了数组的存储位置（即地址）</strong>。可以<strong>进行类似 数组名+1</strong>这样的操作，标识数组的下一个元素。但是<strong>不允许进行++数组名</strong>这样的操作。</p>
</li>
</ol>
<h4 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a><strong>指针</strong></h4><p>指针形式（<code>*pt1</code>）也使得编译器为字符串在静态存储区预留元素的空间。另外，一旦开始执行程序，它会为指针变量<code>pt1</code>留出一个储存位置，并把字符串的地址储存在指针变量中。</p>
<p>注：</p>
<p>​	该变量最初指向该字符串的首字符，但是它的值可以改变。<strong>因此，可以使用递增运算符。</strong>例如，++pt1将指向第 2 个字符</p>
<p>​	用双引号括起来的内容被视为指向该字符串储存位置的指针(类似于字符数组的指针，只指向第一个字母)。这类似于把数组名作为指向该数组位置的指针。</p>
<h4 id="注："><a href="#注：" class="headerlink" title="注："></a><strong>注：</strong></h4><p>字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。</p>
<p><code>puts()</code>函数</p>
<p>和<code>printf()</code>函数一样，<code>puts()</code>函数也属于<code>stdio.h</code>系列的输入&#x2F;输出函数。但是，与<code>printf()</code>不同的是，<code>puts()</code>函数只显示字符串，而且自动在显示的字符串末尾加上换行符</p>
<h1 id="一些神奇的语句"><a href="#一些神奇的语句" class="headerlink" title="一些神奇的语句"></a><strong>一些神奇的语句</strong></h1><p>学习过程中碰到了一些我觉得很神奇的语句</p>
<p>1.逻辑运算符在赋值中的直接使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">10</span>==<span class="number">2</span>);<span class="comment">//此时a = 0</span></span><br></pre></td></tr></table></figure>



<p>2.在<code>while()</code>中嵌入<code>scanf()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a));<span class="comment">//此时程序先运行scanf()函数后将函数的返回值输入给while，若为整数则返回1，若为非整数则返回0</span></span><br></pre></td></tr></table></figure>



<p>3.在<code>while()</code>中的括号中填入数字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//若括号中的数值不为0，即可执行while循环</span></span><br></pre></td></tr></table></figure>



<p>4.可利用<code>scanf()</code>的返回值对变量进行赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c)</span><br></pre></td></tr></table></figure>



<p>5.获取字符同时进行判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (</span><br><span class="line">(ch = getchar()) <span class="comment">// 给ch赋一个值</span></span><br><span class="line">!= <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 把ch和\n作比较</span></span><br></pre></td></tr></table></figure>

<p>但区别于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ch = getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>​	!&#x3D;运算符的优先级比&#x3D;高，所以先对表达式getchar() !&#x3D; ‘\n’求值。由于这是关系表达式，所以其值不是1就是0（真或假）。然后，把该值赋给ch。</p>
<p>6.由于C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。可写出一些简洁的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> marbles[SIZE] = &#123; <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span> &#125;; <span class="type">long</span> answer;</span><br><span class="line">answer = sump(marbles, marbles + SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is</span></span><br><span class="line"><span class="string">%ld.\n&quot;</span>, answer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">total += *start; <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">start++; <span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">&#125; <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，使用这种“越界”指针（超出数组有含义的内存地址）的函数调用更为简洁</p>
<p>7.多维数组的解引用与加法操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（*(*(zippo+<span class="number">2</span>) + <span class="number">1</span>)）</span><br><span class="line"> <span class="comment">//代替数组表示法（zippo[2][1]）</span></span><br></pre></td></tr></table></figure>





<h1 id="Bug日记"><a href="#Bug日记" class="headerlink" title="Bug日记"></a><strong>Bug日记</strong></h1><p><strong>1.for循环局部变量错误</strong></p>
<p>源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MONTHS 12    <span class="comment">// number of months in a year</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEARS   5    <span class="comment">// number of years of data</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// initializing rainfall data for 2010 - 2014</span></span><br><span class="line">	<span class="type">float</span> rain[YEARS][MONTHS] = &#123;</span><br><span class="line">		&#123;<span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">2.4</span>, <span class="number">3.5</span>, <span class="number">6.6</span>&#125;,</span><br><span class="line">		&#123;<span class="number">8.5</span>, <span class="number">8.2</span>, <span class="number">1.2</span>, <span class="number">1.6</span>, <span class="number">2.4</span>, <span class="number">0.0</span>, <span class="number">5.2</span>, <span class="number">0.9</span>, <span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">1.4</span>, <span class="number">7.3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">9.1</span>, <span class="number">8.5</span>, <span class="number">6.7</span>, <span class="number">4.3</span>, <span class="number">2.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">6.1</span>, <span class="number">8.4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7.2</span>, <span class="number">9.9</span>, <span class="number">8.4</span>, <span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.7</span>, <span class="number">4.3</span>, <span class="number">6.2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7.6</span>, <span class="number">5.6</span>, <span class="number">3.8</span>, <span class="number">2.8</span>, <span class="number">3.8</span>, <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.3</span>, <span class="number">2.6</span>, <span class="number">5.2</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> year, month;</span><br><span class="line">	<span class="type">float</span> subtot = <span class="number">1</span>, total;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; YEAR    RAINFALL  (inches)\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (year = <span class="number">0</span>, total = <span class="number">0</span>; year &lt; YEARS; year++) &#123;</span><br><span class="line">		<span class="comment">// for each year, sum rainfall for each month</span></span><br><span class="line">		subtot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> *zhizheng = rain[year], subtot = <span class="number">0</span>; zhizheng &lt; &amp;rain[year][MONTHS] ; zhizheng++)<span class="comment">//错误地方</span></span><br><span class="line">			subtot +=  *zhizheng;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%5d %15.1f\n&quot;</span>, <span class="number">2010</span> + year, subtot);</span><br><span class="line">		total += subtot; <span class="comment">// total for all years</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在错误的for循环处，subtot被重新定义，变成for循环的局部变量</strong></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Wells</div><div class="post-copyright__author_desc">Learning Web Security....</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://we11s.github.io/posts/3276277813/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://we11s.github.io/posts/3276277813/')">C Primer Plus笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://we11s.github.io/posts/3276277813/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C Primer Plus笔记&amp;url=https://we11s.github.io/posts/3276277813/&amp;pic=/img/cover/65a00feec63ae.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://we11s.github.io" target="_blank">WELLS Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%BC%80%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>开发<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/cover/qpVVcgdCWbozEeAj.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2607722179/"><img class="prev-cover" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/cover/LsuYJMijZBKcFude.jpg" onerror="onerror=null;src='/img/image404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/2587301464/"><img class="next-cover" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/cover/65a7edbe771eb.jpg" onerror="onerror=null;src='/img/image404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SQL语句笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/firend404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/c0f1977daac9a.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff">WELLS BLOG</b></div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这里存放着我学习<b style="color:#fff">CTF</b>和<b style="color:#fff">编程</b>的相关笔记</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">希望这里的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>能对你有所帮助。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Wells</h1><div class="author-info__desc">Learning Web Security....</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/we11s" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">C语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">C程序的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">多个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">关键字与保留标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%90%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">标识符名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84-d%E5%9C%A8%E6%89%93%E5%8D%B0%E6%97%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">参数中的%d在打印时有什么作用？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8EC"><span class="toc-number">2.</span> <span class="toc-text">数据与C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">不同数据类型的储存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">整数的储存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">浮点数的储存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">进制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E4%B9%A6%E9%9D%A2%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">进制书面表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E6%97%B6%E7%9A%84%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">初始化变量时的进制表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%AD%E7%9A%84%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">输出中的进制表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E5%8C%96%EF%BC%881%EF%BC%89%E2%80%93%E8%B4%9F%E6%95%B0"><span class="toc-number">2.3.4.</span> <span class="toc-text">进制的转化（1）–负数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%BA%E8%B4%9F%E6%95%B0%EF%BC%89"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">十进制转二进制（十进制为负数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%88%E7%AC%A6%E5%8F%B7%E4%BD%8D%E4%B8%BA1%EF%BC%89"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">二进制转十进制（符号位为1）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%882%EF%BC%89-%E6%AD%A3%E6%95%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text">进制的转换（2）-正数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%BA%A2%E5%87%BA"><span class="toc-number">2.4.</span> <span class="toc-text">数值溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%80%BC%E7%9A%84%E4%B8%8A%E6%BA%A2%E5%92%8C%E4%B8%8B%E6%BA%A2"><span class="toc-number">2.4.2.</span> <span class="toc-text">浮点值的上溢和下溢</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-number">2.5.</span> <span class="toc-text">字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6"><span class="toc-number">2.5.1.</span> <span class="toc-text">非打印字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-1"><span class="toc-number">2.6.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.6.1.</span> <span class="toc-text">变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getchar-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.2.</span> <span class="toc-text">getchar()函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.6.3.</span> <span class="toc-text">声明变量的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%B8%8E%E6%89%93%E5%8D%B0%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%87%B4"><span class="toc-number">2.6.4.</span> <span class="toc-text">数据类型应与打印类型一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="toc-number">2.6.5.</span> <span class="toc-text">断行输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.6.</span> <span class="toc-text">sizeof()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AE%BE%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.6.7.</span> <span class="toc-text">输入的数据类型与设定数据类型不一致的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">字符串和格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Echar%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">字符串与char数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8CC%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">常量和C预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strlen-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">strlen()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printf-%E7%9A%84%E8%BD%AC%E5%8C%96%E8%AF%B4%E6%98%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">printf()的转化说明修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scanf%EF%BC%88%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">scanf（）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">3.5.1.</span> <span class="toc-text">读取字符串的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">&amp;的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-%E7%9A%84%E8%AF%BB%E5%8F%96%E8%A7%84%E5%88%99"><span class="toc-number">3.5.3.</span> <span class="toc-text">scanf()的读取规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.5.4.</span> <span class="toc-text">scanf()中的使用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.5.5.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B0%8F%E6%95%B0%E5%80%BC"><span class="toc-number">3.5.6.</span> <span class="toc-text">读取小数值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-2"><span class="toc-number">3.6.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#X-%E4%B8%8E-X-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.1.</span> <span class="toc-text">&quot;X&quot;与&#39;X&#39;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BA%86%E5%9C%86%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.6.2.</span> <span class="toc-text">sizeof 何时使用了圆括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.6.3.</span> <span class="toc-text">const限定符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.</span> <span class="toc-text">运算符、表达式和语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%A8%A1%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.3.</span> <span class="toc-text">求模运算符-%</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.4.</span> <span class="toc-text">一元运算符与二元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.5.</span> <span class="toc-text">递增递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.6.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.7.</span> <span class="toc-text">逗号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.8.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E9%80%89%E6%8B%BC%E5%86%99%EF%BC%9Aiso646-h%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">备选拼写：iso646.h头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%8C%83%E5%9B%B4%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.8.2.</span> <span class="toc-text">判断范围问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%94%E2%80%94"><span class="toc-number">4.1.9.</span> <span class="toc-text">条件运算符——?:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%9F%A5%E6%89%BE%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.10.</span> <span class="toc-text">&amp;运算符-查找地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.11.</span> <span class="toc-text">间接运算符-*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.1.12.</span> <span class="toc-text">运算符的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">强制类型转换运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-3"><span class="toc-number">4.3.</span> <span class="toc-text">本章注意点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.2.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do%E2%80%A6-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.3.</span> <span class="toc-text">do….while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-4"><span class="toc-number">5.4.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%AC%A6%E5%8F%B7%E4%B8%8D%E8%A6%81%E6%B7%B7%E6%B7%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">逻辑判断符号与赋值符号不要混淆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E4%B8%8E%E8%B7%B3%E8%BD%AC"><span class="toc-number">6.</span> <span class="toc-text">分支与跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E3%80%81else%E3%80%81else-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.1.</span> <span class="toc-text">if、else、else if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">数值的范围判断问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.2.</span> <span class="toc-text">continue语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.3.</span> <span class="toc-text">break语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9%EF%BC%9Aswitch%E5%92%8Cbreak"><span class="toc-number">6.4.</span> <span class="toc-text">多重选择：switch和break</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case%E5%A4%9A%E9%87%8D%E6%A0%87%E7%AD%BE"><span class="toc-number">6.4.1.</span> <span class="toc-text">case多重标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getchar-%E5%92%8Cputchar-%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">getchar()和putchar()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ctype-h%E5%BA%93"><span class="toc-number">6.6.</span> <span class="toc-text">ctype.h库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.1.</span> <span class="toc-text">指定数组大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.2.</span> <span class="toc-text">未指定数组大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">7.4.</span> <span class="toc-text">声明数组形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8EC99%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">指定初始化器（适用于C99）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.6.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">7.6.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.6.2.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.7.</span> <span class="toc-text">其他多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84"><span class="toc-number">7.8.</span> <span class="toc-text">const修饰数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%EF%BC%88%E9%80%82%E7%94%A8C99%EF%BC%89"><span class="toc-number">7.9.</span> <span class="toc-text">变长数组（适用C99）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%B8%A6%E4%BA%8C%E7%BB%B4%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.9.1.</span> <span class="toc-text">声明一个带二维变长数组参数的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88%E4%BD%BF%E7%94%A8C99%EF%BC%89"><span class="toc-number">7.10.</span> <span class="toc-text">复合字面量（使用C99）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">7.10.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">7.10.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-5"><span class="toc-number">7.11.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E6%98%AF%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">7.11.1.</span> <span class="toc-text">数组名是数组首元素的地址。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%8C%E9%87%8D%E9%97%B4%E6%8E%A5%E6%80%A7%E8%B4%A8"><span class="toc-number">7.11.2.</span> <span class="toc-text">多维数组的双重间接性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%ADsizeof-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.11.3.</span> <span class="toc-text">数组中sizeof()的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88"><span class="toc-number">8.1.</span> <span class="toc-text">声明指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.1.</span> <span class="toc-text">1.声明变量的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.2.</span> <span class="toc-text">2.声明多维数组的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.1.3.</span> <span class="toc-text">3.声明函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A3%B0%E6%98%8E%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.1.4.</span> <span class="toc-text">4.声明指向指针的指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">8种基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E4%B8%8E%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">8.3.</span> <span class="toc-text">指针运算与递增递减操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">8.4.</span> <span class="toc-text">解引用未初始化的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.5.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">8.6.</span> <span class="toc-text">指针的兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A-6"><span class="toc-number">8.7.</span> <span class="toc-text">本章注意点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8A%A0%E6%B3%95"><span class="toc-number">8.7.1.</span> <span class="toc-text">指针加法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">函数的声明、定义与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">9.1.1.</span> <span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.1.2.</span> <span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">函数引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">9.2.</span> <span class="toc-text">函数参数的传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F"><span class="toc-number">9.2.1.</span> <span class="toc-text">1.变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.1.</span> <span class="toc-text">定义字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">字符串常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">10.1.2.</span> <span class="toc-text">char类型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91char%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">10.1.3.</span> <span class="toc-text">指向char的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E5%92%8C%E6%8C%87%E9%92%88%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.4.</span> <span class="toc-text">数组形式和指针形式的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88-1"><span class="toc-number">10.1.4.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A"><span class="toc-number">10.1.4.2.</span> <span class="toc-text">注：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.</span> <span class="toc-text">一些神奇的语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bug%E6%97%A5%E8%AE%B0"><span class="toc-number">12.</span> <span class="toc-text">Bug日记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6864a512/" title="PHP文件包含"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/cover/qpVVcgdCWbozEeAj.jpg" onerror="this.onerror=null;this.src='/img/image404.png'" alt="PHP文件包含"/></a><div class="content"><a class="title" href="/posts/6864a512/" title="PHP文件包含">PHP文件包含</a><time datetime="2024-05-28T16:01:57.000Z" title="发表于 2024-05-29 00:01:57">2024-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/67440817/" title="XXE-primer"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/defualt/2.jpg" onerror="this.onerror=null;this.src='/img/image404.png'" alt="XXE-primer"/></a><div class="content"><a class="title" href="/posts/67440817/" title="XXE-primer">XXE-primer</a><time datetime="2024-05-12T12:31:39.000Z" title="发表于 2024-05-12 20:31:39">2024-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3150507853/" title="SQLMap"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/defualt/1.jpg" onerror="this.onerror=null;this.src='/img/image404.png'" alt="SQLMap"/></a><div class="content"><a class="title" href="/posts/3150507853/" title="SQLMap">SQLMap</a><time datetime="2024-04-02T11:21:07.000Z" title="发表于 2024-04-02 19:21:07">2024-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1876369856/" title="2024KalmarCTF-WEB复盘"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/cover/XfqUOidClMslsgAT.jpg" onerror="this.onerror=null;this.src='/img/image404.png'" alt="2024KalmarCTF-WEB复盘"/></a><div class="content"><a class="title" href="/posts/1876369856/" title="2024KalmarCTF-WEB复盘">2024KalmarCTF-WEB复盘</a><time datetime="2024-03-19T05:16:51.000Z" title="发表于 2024-03-19 13:16:51">2024-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2304588875/" title="中间件漏洞"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/cover/mIwxsCuQIaRdwhUD.jpg" onerror="this.onerror=null;this.src='/img/image404.png'" alt="中间件漏洞"/></a><div class="content"><a class="title" href="/posts/2304588875/" title="中间件漏洞">中间件漏洞</a><time datetime="2024-03-12T13:55:33.000Z" title="发表于 2024-03-12 21:55:33">2024-03-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:wel1s@outlook.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/avatar.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/we11s" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title="博客框架为Hexo"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/badge/frame-hexo.svg" alt="博客框架为Hexo"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/badge/theme.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/badge/source-github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/badge/copyright.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="Wells" target="_blank">Wells</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/null"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://we11s.github.io/" title="博客"><img class="back-menu-item-icon" src= "/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/image404.png&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/summarize/"><i class="anzhiyufont anzhiyu-icon-list-ul faa-tada" style="font-size: 0.9em;"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于我</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF-Web/" style="font-size: 0.88rem;">CTF-Web<sup>15</sup></a><a href="/tags/CTF-WriteUp/" style="font-size: 0.88rem;">CTF-WriteUp<sup>3</sup></a><a href="/tags/Tools/" style="font-size: 0.88rem;">Tools<sup>1</sup></a><a href="/tags/Web-Middleware/" style="font-size: 0.88rem;">Web-Middleware<sup>1</sup></a><a href="/tags/Web-PHP/" style="font-size: 0.88rem;">Web-PHP<sup>3</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="/js/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("2023/9/19 12:50:02"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，CTFer.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Wells 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://well5-wellsblog.hf.space',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://well5-wellsblog.hf.space',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="/js/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>